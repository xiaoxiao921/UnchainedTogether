#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GeometryCollectionNodes

#include "Basic.hpp"

#include "Chaos_structs.hpp"
#include "DataflowCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GeometryCollectionEngine_structs.hpp"
#include "FractureEngine_structs.hpp"


namespace SDK
{

// Enum GeometryCollectionNodes.EFloatArrayToIntArrayFunctionEnum
// NumValues: 0x0007
enum class EFloatArrayToIntArrayFunctionEnum : uint8
{
	Dataflow_FloatToInt_Function_Floor       = 0,
	Dataflow_FloatToInt_Function_Ceil        = 1,
	Dataflow_FloatToInt_Function_Round       = 2,
	Dataflow_FloatToInt_Function_Truncate    = 3,
	Dataflow_FloatToInt_NonZeroToIndex       = 4,
	Dataflow_FloatToInt_ZeroToIndex          = 5,
	Dataflow_Max                             = 6,
};

// Enum GeometryCollectionNodes.ECompareOperation1Enum
// NumValues: 0x0006
enum class ECompareOperation1Enum : uint8
{
	Dataflow_Compare_Equal                   = 0,
	Dataflow_Compare_Smaller                 = 1,
	Dataflow_Compare_SmallerOrEqual          = 2,
	Dataflow_Compare_Greater                 = 3,
	Dataflow_Compare_GreaterOrEqual          = 4,
	Dataflow_Max                             = 5,
};

// Enum GeometryCollectionNodes.EStatisticsOperationEnum
// NumValues: 0x0007
enum class EStatisticsOperationEnum : uint8
{
	Dataflow_EStatisticsOperationEnum_Min    = 0,
	Dataflow_EStatisticsOperationEnum_Max    = 1,
	Dataflow_EStatisticsOperationEnum_Mean   = 2,
	Dataflow_EStatisticsOperationEnum_Median = 3,
	Dataflow_EStatisticsOperationEnum_Mode   = 4,
	Dataflow_EStatisticsOperationEnum_Sum    = 5,
	Dataflow_Max                             = 6,
};

// Enum GeometryCollectionNodes.EDataflowFieldFalloffType
// NumValues: 0x0006
enum class EDataflowFieldFalloffType : uint8
{
	Dataflow_FieldFalloffType_None           = 0,
	Dataflow_FieldFalloffType_Linear         = 1,
	Dataflow_FieldFalloffType_Inverse        = 2,
	Dataflow_FieldFalloffType_Squared        = 3,
	Dataflow_FieldFalloffType_Logarithmic    = 4,
	Dataflow_Max                             = 5,
};

// Enum GeometryCollectionNodes.EDataflowSetMaskConditionType
// NumValues: 0x0004
enum class EDataflowSetMaskConditionType : uint8
{
	Dataflow_SetMaskConditionType_Always     = 0,
	Dataflow_SetMaskConditionType_IFF_NOT_Interior = 1,
	Dataflow_SetMaskConditionType_IFF_NOT_Exterior = 2,
	Dataflow_Max                             = 3,
};

// Enum GeometryCollectionNodes.EDataflowWaveFunctionType
// NumValues: 0x0005
enum class EDataflowWaveFunctionType : uint8
{
	Dataflow_WaveFunctionType_Cosine         = 0,
	Dataflow_WaveFunctionType_Gaussian       = 1,
	Dataflow_WaveFunctionType_Falloff        = 2,
	Dataflow_WaveFunctionType_Decay          = 3,
	Dataflow_Max                             = 4,
};

// Enum GeometryCollectionNodes.EDataflowFloatFieldOperationType
// NumValues: 0x0007
enum class EDataflowFloatFieldOperationType : uint8
{
	Dataflow_FloatFieldOperationType_Multiply = 0,
	Dataflow_FloatFieldFalloffType_Divide    = 1,
	Dataflow_FloatFieldFalloffType_Add       = 2,
	Dataflow_FloatFieldFalloffType_Substract = 3,
	Dataflow_FloatFieldFalloffType_Min       = 4,
	Dataflow_FloatFieldFalloffType_Max       = 5,
	Dataflow_Max                             = 6,
};

// Enum GeometryCollectionNodes.EDataflowVectorFieldOperationType
// NumValues: 0x0006
enum class EDataflowVectorFieldOperationType : uint8
{
	Dataflow_VectorFieldOperationType_Multiply = 0,
	Dataflow_VectorFieldFalloffType_Divide   = 1,
	Dataflow_VectorFieldFalloffType_Add      = 2,
	Dataflow_VectorFieldFalloffType_Substract = 3,
	Dataflow_VectorFieldFalloffType_CrossProduct = 4,
	Dataflow_Max                             = 5,
};

// Enum GeometryCollectionNodes.ESetMaterialOperationTypeEnum
// NumValues: 0x0003
enum class ESetMaterialOperationTypeEnum : uint8
{
	Dataflow_SetMaterialOperationType_Add    = 0,
	Dataflow_SetMaterialOperationType_Insert = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EConvexOverlapRemovalMethodEnum
// NumValues: 0x0005
enum class EConvexOverlapRemovalMethodEnum : uint8
{
	Dataflow_EConvexOverlapRemovalMethod_None = 0,
	Dataflow_EConvexOverlapRemovalMethod_All = 1,
	Dataflow_EConvexOverlapRemovalMethod_OnlyClusters = 2,
	Dataflow_EConvexOverlapRemovalMethod_OnlyClustersVsClusters = 3,
	Dataflow_Max                             = 4,
};

// Enum GeometryCollectionNodes.EClusterSizeMethodEnum
// NumValues: 0x0005
enum class EClusterSizeMethodEnum : uint8
{
	Dataflow_ClusterSizeMethod_ByNumber      = 0,
	Dataflow_ClusterSizeMethod_ByFractionOfInput = 1,
	Dataflow_ClusterSizeMethod_BySize        = 2,
	Dataflow_ClusterSizeMethod_ByGrid        = 3,
	Dataflow_Max                             = 4,
};

// Enum GeometryCollectionNodes.EFloatToIntFunctionEnum
// NumValues: 0x0005
enum class EFloatToIntFunctionEnum : uint8
{
	Dataflow_FloatToInt_Function_Floor       = 0,
	Dataflow_FloatToInt_Function_Ceil        = 1,
	Dataflow_FloatToInt_Function_Round       = 2,
	Dataflow_FloatToInt_Function_Truncate    = 3,
	Dataflow_Max                             = 4,
};

// Enum GeometryCollectionNodes.EVisibiltyOptionsEnum
// NumValues: 0x0003
enum class EVisibiltyOptionsEnum : uint8
{
	Dataflow_VisibilityOptions_Visible       = 0,
	Dataflow_VisibilityOptions_Invisible     = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EMakeBoxDataTypeEnum
// NumValues: 0x0003
enum class EMakeBoxDataTypeEnum : uint8
{
	Dataflow_MakeBox_DataType_MinMax         = 0,
	Dataflow_MakeBox_DataType_CenterSize     = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EMathConstantsEnum
// NumValues: 0x000F
enum class EMathConstantsEnum : uint8
{
	Dataflow_MathConstants_Pi                = 0,
	Dataflow_MathConstants_HalfPi            = 1,
	Dataflow_MathConstants_TwoPi             = 2,
	Dataflow_MathConstants_FourPi            = 3,
	Dataflow_MathConstants_InvPi             = 4,
	Dataflow_MathConstants_InvTwoPi          = 5,
	Dataflow_MathConstants_Sqrt2             = 6,
	Dataflow_MathConstants_InvSqrt2          = 7,
	Dataflow_MathConstants_Sqrt3             = 8,
	Dataflow_MathConstants_InvSqrt3          = 9,
	Dataflow_FloatToInt_Function_E           = 10,
	Dataflow_FloatToInt_Function_Gamma       = 11,
	Dataflow_FloatToInt_Function_GoldenRatio = 12,
	Dataflow_FloatToInt_Function_ZeroTolerance = 13,
	Dataflow_Max                             = 14,
};

// Enum GeometryCollectionNodes.EMeshBooleanOperationEnum
// NumValues: 0x0004
enum class EMeshBooleanOperationEnum : uint8
{
	Dataflow_MeshBoolean_Union               = 0,
	Dataflow_MeshBoolean_Intersect           = 1,
	Dataflow_MeshBoolean_Difference          = 2,
	Dataflow_Max                             = 3,
};

// Enum GeometryCollectionNodes.EBoxLengthMeasurementMethod
// NumValues: 0x0007
enum class EBoxLengthMeasurementMethod : uint8
{
	XAxis                                    = 0,
	YAxis                                    = 1,
	ZAxis                                    = 2,
	ShortestAxis                             = 3,
	LongestAxis                              = 4,
	Diagonal                                 = 5,
	EBoxLengthMeasurementMethod_MAX          = 6,
};

// Enum GeometryCollectionNodes.ERotationOrderEnum
// NumValues: 0x0007
enum class ERotationOrderEnum : uint8
{
	Dataflow_RotationOrder_XYZ               = 0,
	Dataflow_RotationOrder_YZX               = 1,
	Dataflow_RotationOrder_ZXY               = 2,
	Dataflow_RotationOrder_XZY               = 3,
	Dataflow_RotationOrder_YXZ               = 4,
	Dataflow_RotationOrder_ZYX               = 5,
	Dataflow_Max                             = 6,
};

// Enum GeometryCollectionNodes.ECompareOperationEnum
// NumValues: 0x0006
enum class ECompareOperationEnum : uint8
{
	Dataflow_Compare_Equal                   = 0,
	Dataflow_Compare_Smaller                 = 1,
	Dataflow_Compare_SmallerOrEqual          = 2,
	Dataflow_Compare_Greater                 = 3,
	Dataflow_Compare_GreaterOrEqual          = 4,
	Dataflow_Max                             = 5,
};

// Enum GeometryCollectionNodes.EAnchorStateEnum
// NumValues: 0x0003
enum class EAnchorStateEnum : uint8
{
	Dataflow_AnchorState_Anchored            = 0,
	Dataflow_AnchorState_NotAnchored         = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EProximityMethodEnum
// NumValues: 0x0003
enum class EProximityMethodEnum : uint8
{
	Dataflow_ProximityMethod_Precise         = 0,
	Dataflow_ProximityMethod_ConvexHull      = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EProximityContactFilteringMethodEnum
// NumValues: 0x0004
enum class EProximityContactFilteringMethodEnum : uint8
{
	Dataflow_ProximityContactFilteringMethod_ProjectedBoundsOverlap = 0,
	Dataflow_ProximityContactFilteringMethod_ConvexHullSharp = 1,
	Dataflow_ProximityContactFilteringMethod_ConvexHullArea = 2,
	Dataflow_Max                             = 3,
};

// Enum GeometryCollectionNodes.EConnectionContactAreaMethodEnum
// NumValues: 0x0003
enum class EConnectionContactAreaMethodEnum : uint8
{
	Dataflow_ConnectionContactAreaMethod_None = 0,
	Dataflow_ProximityContactFilteringMethod_ConvexHullArea = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.EStandardGroupNameEnum
// NumValues: 0x0008
enum class EStandardGroupNameEnum : uint8
{
	Dataflow_EStandardGroupNameEnum_Transform = 0,
	Dataflow_EStandardGroupNameEnum_Geometry = 1,
	Dataflow_EStandardGroupNameEnum_Faces    = 2,
	Dataflow_EStandardGroupNameEnum_Vertices = 3,
	Dataflow_EStandardGroupNameEnum_Material = 4,
	Dataflow_EStandardGroupNameEnum_Breaking = 5,
	Dataflow_EStandardGroupNameEnum_Custom   = 6,
	Dataflow_Max                             = 7,
};

// Enum GeometryCollectionNodes.ECustomAttributeTypeEnum
// NumValues: 0x0019
enum class ECustomAttributeTypeEnum : uint8
{
	Dataflow_CustomAttributeType_UInt8       = 0,
	Dataflow_CustomAttributeType_Int32       = 1,
	Dataflow_CustomAttributeType_Float       = 2,
	Dataflow_CustomAttributeType_Double      = 3,
	Dataflow_CustomAttributeType_Bool        = 4,
	Dataflow_CustomAttributeType_String      = 5,
	Dataflow_CustomAttributeType_Vector2f    = 6,
	Dataflow_CustomAttributeType_Vector3f    = 7,
	Dataflow_CustomAttributeType_Vector3d    = 8,
	Dataflow_CustomAttributeType_Vector4f    = 9,
	Dataflow_CustomAttributeType_LinearColor = 10,
	Dataflow_CustomAttributeType_Transform   = 11,
	Dataflow_CustomAttributeType_Quat4f      = 12,
	Dataflow_CustomAttributeType_Box         = 13,
	Dataflow_CustomAttributeType_Guid        = 14,
	Dataflow_CustomAttributeType_Int32Set    = 15,
	Dataflow_CustomAttributeType_Int32Array  = 16,
	Dataflow_CustomAttributeType_IntVector   = 17,
	Dataflow_CustomAttributeType_IntVector2  = 18,
	Dataflow_CustomAttributeType_IntVector4  = 19,
	Dataflow_CustomAttributeType_IntVector2Array = 20,
	Dataflow_CustomAttributeType_FloatArray  = 21,
	Dataflow_CustomAttributeType_Vector2fArray = 22,
	Dataflow_CustomAttributeType_FVector3fArray = 23,
	Dataflow_Max                             = 24,
};

// Enum GeometryCollectionNodes.ESetOperationEnum
// NumValues: 0x0004
enum class ESetOperationEnum : uint8
{
	Dataflow_SetOperation_AND                = 0,
	Dataflow_SetOperation_OR                 = 1,
	Dataflow_SetOperation_XOR                = 2,
	Dataflow_Max                             = 3,
};

// Enum GeometryCollectionNodes.ERangeSettingEnum
// NumValues: 0x0003
enum class ERangeSettingEnum : uint8
{
	Dataflow_RangeSetting_InsideRange        = 0,
	Dataflow_RangeSetting_OutsideRange       = 1,
	Dataflow_Max                             = 2,
};

// Enum GeometryCollectionNodes.ESelectSubjectTypeEnum
// NumValues: 0x0004
enum class ESelectSubjectTypeEnum : uint8
{
	Dataflow_SelectSubjectType_Vertices      = 0,
	Dataflow_SelectSubjectType_BoundingBox   = 1,
	Dataflow_SelectSubjectType_Centroid      = 2,
	Dataflow_Max                             = 3,
};

// ScriptStruct GeometryCollectionNodes.ArcCosDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FArcCosDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcCosDataflowNode) == 0x000008, "Wrong alignment on FArcCosDataflowNode");
static_assert(sizeof(FArcCosDataflowNode) == 0x0000F0, "Wrong size on FArcCosDataflowNode");
static_assert(offsetof(FArcCosDataflowNode, Float) == 0x0000E8, "Member 'FArcCosDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FArcCosDataflowNode, ReturnValue) == 0x0000EC, "Member 'FArcCosDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetFloatArrayElementDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FGetFloatArrayElementDataflowNode final : public FDataflowNode
{
public:
	int32                                         Index;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD5[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FloatArray;                                        // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD6[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetFloatArrayElementDataflowNode) == 0x000008, "Wrong alignment on FGetFloatArrayElementDataflowNode");
static_assert(sizeof(FGetFloatArrayElementDataflowNode) == 0x000108, "Wrong size on FGetFloatArrayElementDataflowNode");
static_assert(offsetof(FGetFloatArrayElementDataflowNode, Index) == 0x0000E8, "Member 'FGetFloatArrayElementDataflowNode::Index' has a wrong offset!");
static_assert(offsetof(FGetFloatArrayElementDataflowNode, FloatArray) == 0x0000F0, "Member 'FGetFloatArrayElementDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FGetFloatArrayElementDataflowNode, FloatValue) == 0x000100, "Member 'FGetFloatArrayElementDataflowNode::FloatValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayToIntArrayDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FFloatArrayToIntArrayDataflowNode final : public FDataflowNode
{
public:
	EFloatArrayToIntArrayFunctionEnum             Function;                                          // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD7[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FloatArray;                                        // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntArray;                                          // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayToIntArrayDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayToIntArrayDataflowNode");
static_assert(sizeof(FFloatArrayToIntArrayDataflowNode) == 0x000110, "Wrong size on FFloatArrayToIntArrayDataflowNode");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, Function) == 0x0000E8, "Member 'FFloatArrayToIntArrayDataflowNode::Function' has a wrong offset!");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, FloatArray) == 0x0000F0, "Member 'FFloatArrayToIntArrayDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayToIntArrayDataflowNode, IntArray) == 0x000100, "Member 'FFloatArrayToIntArrayDataflowNode::IntArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DistanceDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FDistanceDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                PointA;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointB;                                            // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD8[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDistanceDataflowNode) == 0x000008, "Wrong alignment on FDistanceDataflowNode");
static_assert(sizeof(FDistanceDataflowNode) == 0x000120, "Wrong size on FDistanceDataflowNode");
static_assert(offsetof(FDistanceDataflowNode, PointA) == 0x0000E8, "Member 'FDistanceDataflowNode::PointA' has a wrong offset!");
static_assert(offsetof(FDistanceDataflowNode, PointB) == 0x000100, "Member 'FDistanceDataflowNode::PointB' has a wrong offset!");
static_assert(offsetof(FDistanceDataflowNode, ReturnValue) == 0x000118, "Member 'FDistanceDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetArrayElementDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FGetArrayElementDataflowNode final : public FDataflowNode
{
public:
	int32                                         Index;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BD9[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        Points;                                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0100(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetArrayElementDataflowNode) == 0x000008, "Wrong alignment on FGetArrayElementDataflowNode");
static_assert(sizeof(FGetArrayElementDataflowNode) == 0x000118, "Wrong size on FGetArrayElementDataflowNode");
static_assert(offsetof(FGetArrayElementDataflowNode, Index) == 0x0000E8, "Member 'FGetArrayElementDataflowNode::Index' has a wrong offset!");
static_assert(offsetof(FGetArrayElementDataflowNode, Points) == 0x0000F0, "Member 'FGetArrayElementDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FGetArrayElementDataflowNode, Point) == 0x000100, "Member 'FGetArrayElementDataflowNode::Point' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetNumArrayElementsDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FGetNumArrayElementsDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FloatArray;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 IntArray;                                          // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fArray;                                     // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumElements;                                       // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDA[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetNumArrayElementsDataflowNode) == 0x000008, "Wrong alignment on FGetNumArrayElementsDataflowNode");
static_assert(sizeof(FGetNumArrayElementsDataflowNode) == 0x000130, "Wrong size on FGetNumArrayElementsDataflowNode");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, FloatArray) == 0x0000E8, "Member 'FGetNumArrayElementsDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, IntArray) == 0x0000F8, "Member 'FGetNumArrayElementsDataflowNode::IntArray' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, Points) == 0x000108, "Member 'FGetNumArrayElementsDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, Vector3fArray) == 0x000118, "Member 'FGetNumArrayElementsDataflowNode::Vector3fArray' has a wrong offset!");
static_assert(offsetof(FGetNumArrayElementsDataflowNode, NumElements) == 0x000128, "Member 'FGetNumArrayElementsDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.NormalizeToRangeDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FNormalizeToRangeDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMin;                                          // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMax;                                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNormalizeToRangeDataflowNode) == 0x000008, "Wrong alignment on FNormalizeToRangeDataflowNode");
static_assert(sizeof(FNormalizeToRangeDataflowNode) == 0x0000F8, "Wrong size on FNormalizeToRangeDataflowNode");
static_assert(offsetof(FNormalizeToRangeDataflowNode, Float) == 0x0000E8, "Member 'FNormalizeToRangeDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FNormalizeToRangeDataflowNode, RangeMin) == 0x0000EC, "Member 'FNormalizeToRangeDataflowNode::RangeMin' has a wrong offset!");
static_assert(offsetof(FNormalizeToRangeDataflowNode, RangeMax) == 0x0000F0, "Member 'FNormalizeToRangeDataflowNode::RangeMax' has a wrong offset!");
static_assert(offsetof(FNormalizeToRangeDataflowNode, ReturnValue) == 0x0000F4, "Member 'FNormalizeToRangeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolArrayToFaceSelectionDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FBoolArrayToFaceSelectionDataflowNode final : public FDataflowNode
{
public:
	TArray<bool>                                  BoolAttributeData;                                 // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolArrayToFaceSelectionDataflowNode) == 0x000008, "Wrong alignment on FBoolArrayToFaceSelectionDataflowNode");
static_assert(sizeof(FBoolArrayToFaceSelectionDataflowNode) == 0x000118, "Wrong size on FBoolArrayToFaceSelectionDataflowNode");
static_assert(offsetof(FBoolArrayToFaceSelectionDataflowNode, BoolAttributeData) == 0x0000E8, "Member 'FBoolArrayToFaceSelectionDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FBoolArrayToFaceSelectionDataflowNode, FaceSelection) == 0x0000F8, "Member 'FBoolArrayToFaceSelectionDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayToVertexSelectionDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FFloatArrayToVertexSelectionDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FloatArray;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	ECompareOperation1Enum                        Operation;                                         // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDB[0x3];                                     // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Threshold;                                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x0100(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayToVertexSelectionDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayToVertexSelectionDataflowNode");
static_assert(sizeof(FFloatArrayToVertexSelectionDataflowNode) == 0x000120, "Wrong size on FFloatArrayToVertexSelectionDataflowNode");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, FloatArray) == 0x0000E8, "Member 'FFloatArrayToVertexSelectionDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, Operation) == 0x0000F8, "Member 'FFloatArrayToVertexSelectionDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, Threshold) == 0x0000FC, "Member 'FFloatArrayToVertexSelectionDataflowNode::Threshold' has a wrong offset!");
static_assert(offsetof(FFloatArrayToVertexSelectionDataflowNode, VertexSelection) == 0x000100, "Member 'FFloatArrayToVertexSelectionDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ArcSinDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FArcSinDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcSinDataflowNode) == 0x000008, "Wrong alignment on FArcSinDataflowNode");
static_assert(sizeof(FArcSinDataflowNode) == 0x0000F0, "Wrong size on FArcSinDataflowNode");
static_assert(offsetof(FArcSinDataflowNode, Float) == 0x0000E8, "Member 'FArcSinDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FArcSinDataflowNode, ReturnValue) == 0x0000EC, "Member 'FArcSinDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayNormalizeDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FFloatArrayNormalizeDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 InFloatArray;                                      // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               Selection;                                         // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 OutFloatArray;                                     // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayNormalizeDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayNormalizeDataflowNode");
static_assert(sizeof(FFloatArrayNormalizeDataflowNode) == 0x000130, "Wrong size on FFloatArrayNormalizeDataflowNode");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, InFloatArray) == 0x0000E8, "Member 'FFloatArrayNormalizeDataflowNode::InFloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, Selection) == 0x0000F8, "Member 'FFloatArrayNormalizeDataflowNode::Selection' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, MinRange) == 0x000118, "Member 'FFloatArrayNormalizeDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, MaxRange) == 0x00011C, "Member 'FFloatArrayNormalizeDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FFloatArrayNormalizeDataflowNode, OutFloatArray) == 0x000120, "Member 'FFloatArrayNormalizeDataflowNode::OutFloatArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VectorArrayNormalizeDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FVectorArrayNormalizeDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        InVectorArray;                                     // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               Selection;                                         // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDC[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        OutVectorArray;                                    // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorArrayNormalizeDataflowNode) == 0x000008, "Wrong alignment on FVectorArrayNormalizeDataflowNode");
static_assert(sizeof(FVectorArrayNormalizeDataflowNode) == 0x000130, "Wrong size on FVectorArrayNormalizeDataflowNode");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, InVectorArray) == 0x0000E8, "Member 'FVectorArrayNormalizeDataflowNode::InVectorArray' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, Selection) == 0x0000F8, "Member 'FVectorArrayNormalizeDataflowNode::Selection' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, Magnitude) == 0x000118, "Member 'FVectorArrayNormalizeDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FVectorArrayNormalizeDataflowNode, OutVectorArray) == 0x000120, "Member 'FVectorArrayNormalizeDataflowNode::OutVectorArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UnionIntArraysDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FUnionIntArraysDataflowNode final : public FDataflowNode
{
public:
	TArray<int32>                                 InArray1;                                          // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 InArray2;                                          // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OutArray;                                          // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUnionIntArraysDataflowNode) == 0x000008, "Wrong alignment on FUnionIntArraysDataflowNode");
static_assert(sizeof(FUnionIntArraysDataflowNode) == 0x000118, "Wrong size on FUnionIntArraysDataflowNode");
static_assert(offsetof(FUnionIntArraysDataflowNode, InArray1) == 0x0000E8, "Member 'FUnionIntArraysDataflowNode::InArray1' has a wrong offset!");
static_assert(offsetof(FUnionIntArraysDataflowNode, InArray2) == 0x0000F8, "Member 'FUnionIntArraysDataflowNode::InArray2' has a wrong offset!");
static_assert(offsetof(FUnionIntArraysDataflowNode, OutArray) == 0x000108, "Member 'FUnionIntArraysDataflowNode::OutArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RemoveFloatArrayElementDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FRemoveFloatArrayElementDataflowNode final : public FDataflowNode
{
public:
	int32                                         Index;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreserveOrder;                                    // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDD[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FloatArray;                                        // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRemoveFloatArrayElementDataflowNode) == 0x000008, "Wrong alignment on FRemoveFloatArrayElementDataflowNode");
static_assert(sizeof(FRemoveFloatArrayElementDataflowNode) == 0x000100, "Wrong size on FRemoveFloatArrayElementDataflowNode");
static_assert(offsetof(FRemoveFloatArrayElementDataflowNode, Index) == 0x0000E8, "Member 'FRemoveFloatArrayElementDataflowNode::Index' has a wrong offset!");
static_assert(offsetof(FRemoveFloatArrayElementDataflowNode, bPreserveOrder) == 0x0000EC, "Member 'FRemoveFloatArrayElementDataflowNode::bPreserveOrder' has a wrong offset!");
static_assert(offsetof(FRemoveFloatArrayElementDataflowNode, FloatArray) == 0x0000F0, "Member 'FRemoveFloatArrayElementDataflowNode::FloatArray' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MathConstantsDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FMathConstantsDataflowNode final : public FDataflowNode
{
public:
	EMathConstantsEnum                            Constant;                                          // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDE[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMathConstantsDataflowNode) == 0x000008, "Wrong alignment on FMathConstantsDataflowNode");
static_assert(sizeof(FMathConstantsDataflowNode) == 0x0000F0, "Wrong size on FMathConstantsDataflowNode");
static_assert(offsetof(FMathConstantsDataflowNode, Constant) == 0x0000E8, "Member 'FMathConstantsDataflowNode::Constant' has a wrong offset!");
static_assert(offsetof(FMathConstantsDataflowNode, ReturnValue) == 0x0000EC, "Member 'FMathConstantsDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatArrayComputeStatisticsDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FFloatArrayComputeStatisticsDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FloatArray;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	EStatisticsOperationEnum                      OperationName;                                     // 0x0118(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BDF[0x3];                                     // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x011C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Indices;                                           // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatArrayComputeStatisticsDataflowNode) == 0x000008, "Wrong alignment on FFloatArrayComputeStatisticsDataflowNode");
static_assert(sizeof(FFloatArrayComputeStatisticsDataflowNode) == 0x000130, "Wrong size on FFloatArrayComputeStatisticsDataflowNode");
static_assert(offsetof(FFloatArrayComputeStatisticsDataflowNode, FloatArray) == 0x0000E8, "Member 'FFloatArrayComputeStatisticsDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FFloatArrayComputeStatisticsDataflowNode, TransformSelection) == 0x0000F8, "Member 'FFloatArrayComputeStatisticsDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FFloatArrayComputeStatisticsDataflowNode, OperationName) == 0x000118, "Member 'FFloatArrayComputeStatisticsDataflowNode::OperationName' has a wrong offset!");
static_assert(offsetof(FFloatArrayComputeStatisticsDataflowNode, Value) == 0x00011C, "Member 'FFloatArrayComputeStatisticsDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FFloatArrayComputeStatisticsDataflowNode, Indices) == 0x000120, "Member 'FFloatArrayComputeStatisticsDataflowNode::Indices' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GeometryCollectionTerminalDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FGeometryCollectionTerminalDataflowNode final : public FDataflowTerminalNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x0198(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionAutoInstanceMesh> InstancedMeshes;                                   // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeometryCollectionTerminalDataflowNode) == 0x000008, "Wrong alignment on FGeometryCollectionTerminalDataflowNode");
static_assert(sizeof(FGeometryCollectionTerminalDataflowNode) == 0x0001B8, "Wrong size on FGeometryCollectionTerminalDataflowNode");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, Collection) == 0x0000E8, "Member 'FGeometryCollectionTerminalDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, Materials) == 0x000198, "Member 'FGeometryCollectionTerminalDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FGeometryCollectionTerminalDataflowNode, InstancedMeshes) == 0x0001A8, "Member 'FGeometryCollectionTerminalDataflowNode::InstancedMeshes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetGeometryCollectionAssetDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FGetGeometryCollectionAssetDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    Asset;                                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetGeometryCollectionAssetDataflowNode) == 0x000008, "Wrong alignment on FGetGeometryCollectionAssetDataflowNode");
static_assert(sizeof(FGetGeometryCollectionAssetDataflowNode) == 0x0000F0, "Wrong size on FGetGeometryCollectionAssetDataflowNode");
static_assert(offsetof(FGetGeometryCollectionAssetDataflowNode, Asset) == 0x0000E8, "Member 'FGetGeometryCollectionAssetDataflowNode::Asset' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetGeometryCollectionSourcesDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FGetGeometryCollectionSourcesDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    Asset;                                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionSource>      Sources;                                           // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetGeometryCollectionSourcesDataflowNode) == 0x000008, "Wrong alignment on FGetGeometryCollectionSourcesDataflowNode");
static_assert(sizeof(FGetGeometryCollectionSourcesDataflowNode) == 0x000100, "Wrong size on FGetGeometryCollectionSourcesDataflowNode");
static_assert(offsetof(FGetGeometryCollectionSourcesDataflowNode, Asset) == 0x0000E8, "Member 'FGetGeometryCollectionSourcesDataflowNode::Asset' has a wrong offset!");
static_assert(offsetof(FGetGeometryCollectionSourcesDataflowNode, Sources) == 0x0000F0, "Member 'FGetGeometryCollectionSourcesDataflowNode::Sources' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateGeometryCollectionFromSourcesDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCreateGeometryCollectionFromSourcesDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FGeometryCollectionSource>      Sources;                                           // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01A8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FGeometryCollectionAutoInstanceMesh> InstancedMeshes;                                   // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateGeometryCollectionFromSourcesDataflowNode) == 0x000008, "Wrong alignment on FCreateGeometryCollectionFromSourcesDataflowNode");
static_assert(sizeof(FCreateGeometryCollectionFromSourcesDataflowNode) == 0x0001C8, "Wrong size on FCreateGeometryCollectionFromSourcesDataflowNode");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Sources) == 0x0000E8, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Sources' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Collection) == 0x0000F8, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, Materials) == 0x0001A8, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FCreateGeometryCollectionFromSourcesDataflowNode, InstancedMeshes) == 0x0001B8, "Member 'FCreateGeometryCollectionFromSourcesDataflowNode::InstancedMeshes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialFalloffFieldDataflowNode
// 0x00C8 (0x01B0 - 0x00E8)
struct FRadialFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x0118(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0160(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE0[0x7];                                     // 0x0161(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0168(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0178(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x0188(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE1[0x4];                                     // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialFalloffFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialFalloffFieldDataflowNode");
static_assert(sizeof(FRadialFalloffFieldDataflowNode) == 0x0001B0, "Wrong size on FRadialFalloffFieldDataflowNode");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FRadialFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FRadialFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Sphere) == 0x000118, "Member 'FRadialFalloffFieldDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Translation) == 0x000138, "Member 'FRadialFalloffFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Magnitude) == 0x000150, "Member 'FRadialFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, MinRange) == 0x000154, "Member 'FRadialFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, MaxRange) == 0x000158, "Member 'FRadialFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, Default) == 0x00015C, "Member 'FRadialFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FalloffType) == 0x000160, "Member 'FRadialFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldFloatResult) == 0x000168, "Member 'FRadialFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldRemap) == 0x000178, "Member 'FRadialFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, FieldSelectionMask) == 0x000188, "Member 'FRadialFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FRadialFalloffFieldDataflowNode, NumSamplePositions) == 0x0001A8, "Member 'FRadialFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadiansToDegreesDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FRadiansToDegreesDataflowNode final : public FDataflowNode
{
public:
	float                                         Radians;                                           // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Degrees;                                           // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadiansToDegreesDataflowNode) == 0x000008, "Wrong alignment on FRadiansToDegreesDataflowNode");
static_assert(sizeof(FRadiansToDegreesDataflowNode) == 0x0000F0, "Wrong size on FRadiansToDegreesDataflowNode");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Radians) == 0x0000E8, "Member 'FRadiansToDegreesDataflowNode::Radians' has a wrong offset!");
static_assert(offsetof(FRadiansToDegreesDataflowNode, Degrees) == 0x0000EC, "Member 'FRadiansToDegreesDataflowNode::Degrees' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoxFalloffFieldDataflowNode
// 0x0128 (0x0210 - 0x00E8)
struct FBoxFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0118(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0150(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE2[0x7];                                     // 0x01C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x01C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x01E8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0208(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE3[0x4];                                     // 0x020C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxFalloffFieldDataflowNode) == 0x000010, "Wrong alignment on FBoxFalloffFieldDataflowNode");
static_assert(sizeof(FBoxFalloffFieldDataflowNode) == 0x000210, "Wrong size on FBoxFalloffFieldDataflowNode");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FBoxFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FBoxFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Box) == 0x000118, "Member 'FBoxFalloffFieldDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Transform) == 0x000150, "Member 'FBoxFalloffFieldDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Magnitude) == 0x0001B0, "Member 'FBoxFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, MinRange) == 0x0001B4, "Member 'FBoxFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, MaxRange) == 0x0001B8, "Member 'FBoxFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, Default) == 0x0001BC, "Member 'FBoxFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FalloffType) == 0x0001C0, "Member 'FBoxFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldFloatResult) == 0x0001C8, "Member 'FBoxFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldRemap) == 0x0001D8, "Member 'FBoxFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, FieldSelectionMask) == 0x0001E8, "Member 'FBoxFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FBoxFalloffFieldDataflowNode, NumSamplePositions) == 0x000208, "Member 'FBoxFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PlaneFalloffFieldDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FPlaneFalloffFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0118(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0130(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE4[0x4];                                     // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Translation;                                       // 0x0150(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE5[0x7];                                     // 0x0179(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               FieldSelectionMask;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE6[0x4];                                     // 0x01C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaneFalloffFieldDataflowNode) == 0x000008, "Wrong alignment on FPlaneFalloffFieldDataflowNode");
static_assert(sizeof(FPlaneFalloffFieldDataflowNode) == 0x0001C8, "Wrong size on FPlaneFalloffFieldDataflowNode");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FPlaneFalloffFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FPlaneFalloffFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Position) == 0x000118, "Member 'FPlaneFalloffFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Normal) == 0x000130, "Member 'FPlaneFalloffFieldDataflowNode::Normal' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Distance) == 0x000148, "Member 'FPlaneFalloffFieldDataflowNode::Distance' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Translation) == 0x000150, "Member 'FPlaneFalloffFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Magnitude) == 0x000168, "Member 'FPlaneFalloffFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, MinRange) == 0x00016C, "Member 'FPlaneFalloffFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, MaxRange) == 0x000170, "Member 'FPlaneFalloffFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, Default) == 0x000174, "Member 'FPlaneFalloffFieldDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FalloffType) == 0x000178, "Member 'FPlaneFalloffFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldFloatResult) == 0x000180, "Member 'FPlaneFalloffFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldRemap) == 0x000190, "Member 'FPlaneFalloffFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, FieldSelectionMask) == 0x0001A0, "Member 'FPlaneFalloffFieldDataflowNode::FieldSelectionMask' has a wrong offset!");
static_assert(offsetof(FPlaneFalloffFieldDataflowNode, NumSamplePositions) == 0x0001C0, "Member 'FPlaneFalloffFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshBooleanDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FMeshBooleanDataflowNode final : public FDataflowNode
{
public:
	EMeshBooleanOperationEnum                     Operation;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE7[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh1;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh2;                                             // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshBooleanDataflowNode) == 0x000008, "Wrong alignment on FMeshBooleanDataflowNode");
static_assert(sizeof(FMeshBooleanDataflowNode) == 0x000108, "Wrong size on FMeshBooleanDataflowNode");
static_assert(offsetof(FMeshBooleanDataflowNode, Operation) == 0x0000E8, "Member 'FMeshBooleanDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh1) == 0x0000F0, "Member 'FMeshBooleanDataflowNode::Mesh1' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh2) == 0x0000F8, "Member 'FMeshBooleanDataflowNode::Mesh2' has a wrong offset!");
static_assert(offsetof(FMeshBooleanDataflowNode, Mesh) == 0x000100, "Member 'FMeshBooleanDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialIntMaskFieldDataflowNode
// 0x00A0 (0x0188 - 0x00E8)
struct FRadialIntMaskFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x0118(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InteriorValue;                                     // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ExteriorValue;                                     // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowSetMaskConditionType                 SetMaskConditionType;                              // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE8[0x7];                                     // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FieldIntResult;                                    // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BE9[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialIntMaskFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialIntMaskFieldDataflowNode");
static_assert(sizeof(FRadialIntMaskFieldDataflowNode) == 0x000188, "Wrong size on FRadialIntMaskFieldDataflowNode");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FRadialIntMaskFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FRadialIntMaskFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, Sphere) == 0x000118, "Member 'FRadialIntMaskFieldDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, Translation) == 0x000138, "Member 'FRadialIntMaskFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, InteriorValue) == 0x000150, "Member 'FRadialIntMaskFieldDataflowNode::InteriorValue' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, ExteriorValue) == 0x000154, "Member 'FRadialIntMaskFieldDataflowNode::ExteriorValue' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, SetMaskConditionType) == 0x000158, "Member 'FRadialIntMaskFieldDataflowNode::SetMaskConditionType' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, FieldIntResult) == 0x000160, "Member 'FRadialIntMaskFieldDataflowNode::FieldIntResult' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, FieldRemap) == 0x000170, "Member 'FRadialIntMaskFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialIntMaskFieldDataflowNode, NumSamplePositions) == 0x000180, "Member 'FRadialIntMaskFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformScalarFieldDataflowNode
// 0x0060 (0x0148 - 0x00E8)
struct FUniformScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEA[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEB[0x4];                                     // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformScalarFieldDataflowNode");
static_assert(sizeof(FUniformScalarFieldDataflowNode) == 0x000148, "Wrong size on FUniformScalarFieldDataflowNode");
static_assert(offsetof(FUniformScalarFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FUniformScalarFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FUniformScalarFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, Magnitude) == 0x000118, "Member 'FUniformScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, FieldFloatResult) == 0x000120, "Member 'FUniformScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, FieldRemap) == 0x000130, "Member 'FUniformScalarFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformScalarFieldDataflowNode, NumSamplePositions) == 0x000140, "Member 'FUniformScalarFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoxToMeshDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FBoxToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FBox                                   Box;                                               // 0x00E8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x0120(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0128(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEC[0x4];                                     // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoxToMeshDataflowNode) == 0x000008, "Wrong alignment on FBoxToMeshDataflowNode");
static_assert(sizeof(FBoxToMeshDataflowNode) == 0x000130, "Wrong size on FBoxToMeshDataflowNode");
static_assert(offsetof(FBoxToMeshDataflowNode, Box) == 0x0000E8, "Member 'FBoxToMeshDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FBoxToMeshDataflowNode, Mesh) == 0x000120, "Member 'FBoxToMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FBoxToMeshDataflowNode, TriangleCount) == 0x000128, "Member 'FBoxToMeshDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformVectorFieldDataflowNode
// 0x0078 (0x0160 - 0x00E8)
struct FUniformVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BED[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Direction;                                         // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEE[0x4];                                     // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformVectorFieldDataflowNode");
static_assert(sizeof(FUniformVectorFieldDataflowNode) == 0x000160, "Wrong size on FUniformVectorFieldDataflowNode");
static_assert(offsetof(FUniformVectorFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FUniformVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FUniformVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, Magnitude) == 0x000118, "Member 'FUniformVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, Direction) == 0x000120, "Member 'FUniformVectorFieldDataflowNode::Direction' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, FieldVectorResult) == 0x000138, "Member 'FUniformVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, FieldRemap) == 0x000148, "Member 'FUniformVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformVectorFieldDataflowNode, NumSamplePositions) == 0x000158, "Member 'FUniformVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialVectorFieldDataflowNode
// 0x0078 (0x0160 - 0x00E8)
struct FRadialVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BEF[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF0[0x4];                                     // 0x015C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FRadialVectorFieldDataflowNode");
static_assert(sizeof(FRadialVectorFieldDataflowNode) == 0x000160, "Wrong size on FRadialVectorFieldDataflowNode");
static_assert(offsetof(FRadialVectorFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FRadialVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FRadialVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, Magnitude) == 0x000118, "Member 'FRadialVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, Position) == 0x000120, "Member 'FRadialVectorFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, FieldVectorResult) == 0x000138, "Member 'FRadialVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, FieldRemap) == 0x000148, "Member 'FRadialVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRadialVectorFieldDataflowNode, NumSamplePositions) == 0x000158, "Member 'FRadialVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FRandomUnitVectorDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF1[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x00F0(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorDataflowNode");
static_assert(sizeof(FRandomUnitVectorDataflowNode) == 0x000108, "Wrong size on FRandomUnitVectorDataflowNode");
static_assert(offsetof(FRandomUnitVectorDataflowNode, bDeterministic) == 0x0000E8, "Member 'FRandomUnitVectorDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, RandomSeed) == 0x0000EC, "Member 'FRandomUnitVectorDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorDataflowNode, ReturnValue) == 0x0000F0, "Member 'FRandomUnitVectorDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomVectorFieldDataflowNode
// 0x0060 (0x0148 - 0x00E8)
struct FRandomVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF2[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF3[0x4];                                     // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FRandomVectorFieldDataflowNode");
static_assert(sizeof(FRandomVectorFieldDataflowNode) == 0x000148, "Wrong size on FRandomVectorFieldDataflowNode");
static_assert(offsetof(FRandomVectorFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FRandomVectorFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FRandomVectorFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, Magnitude) == 0x000118, "Member 'FRandomVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, FieldVectorResult) == 0x000120, "Member 'FRandomVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, FieldRemap) == 0x000130, "Member 'FRandomVectorFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FRandomVectorFieldDataflowNode, NumSamplePositions) == 0x000140, "Member 'FRandomVectorFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.NoiseFieldDataflowNode
// 0x00C8 (0x01B0 - 0x00E8)
struct FNoiseFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         MinRange;                                          // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0120(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatResult;                                  // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0190(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x01A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF4[0xC];                                     // 0x01A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNoiseFieldDataflowNode) == 0x000010, "Wrong alignment on FNoiseFieldDataflowNode");
static_assert(sizeof(FNoiseFieldDataflowNode) == 0x0001B0, "Wrong size on FNoiseFieldDataflowNode");
static_assert(offsetof(FNoiseFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FNoiseFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FNoiseFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, MinRange) == 0x000118, "Member 'FNoiseFieldDataflowNode::MinRange' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, MaxRange) == 0x00011C, "Member 'FNoiseFieldDataflowNode::MaxRange' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, Transform) == 0x000120, "Member 'FNoiseFieldDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, FieldFloatResult) == 0x000180, "Member 'FNoiseFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, FieldRemap) == 0x000190, "Member 'FNoiseFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FNoiseFieldDataflowNode, NumSamplePositions) == 0x0001A0, "Member 'FNoiseFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.StaticMeshToMeshDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FStaticMeshToMeshDataflowNode final : public FDataflowNode
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHiRes;                                         // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF5[0x3];                                     // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODLevel;                                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStaticMeshToMeshDataflowNode) == 0x000008, "Wrong alignment on FStaticMeshToMeshDataflowNode");
static_assert(sizeof(FStaticMeshToMeshDataflowNode) == 0x000100, "Wrong size on FStaticMeshToMeshDataflowNode");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, StaticMesh) == 0x0000E8, "Member 'FStaticMeshToMeshDataflowNode::StaticMesh' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, bUseHiRes) == 0x0000F0, "Member 'FStaticMeshToMeshDataflowNode::bUseHiRes' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, LODLevel) == 0x0000F4, "Member 'FStaticMeshToMeshDataflowNode::LODLevel' has a wrong offset!");
static_assert(offsetof(FStaticMeshToMeshDataflowNode, Mesh) == 0x0000F8, "Member 'FStaticMeshToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformIntegerFieldDataflowNode
// 0x0060 (0x0148 - 0x00E8)
struct FUniformIntegerFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF6[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 FieldIntResult;                                    // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF7[0x4];                                     // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniformIntegerFieldDataflowNode) == 0x000008, "Wrong alignment on FUniformIntegerFieldDataflowNode");
static_assert(sizeof(FUniformIntegerFieldDataflowNode) == 0x000148, "Wrong size on FUniformIntegerFieldDataflowNode");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FUniformIntegerFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FUniformIntegerFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, Magnitude) == 0x000118, "Member 'FUniformIntegerFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, FieldIntResult) == 0x000120, "Member 'FUniformIntegerFieldDataflowNode::FieldIntResult' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, FieldRemap) == 0x000130, "Member 'FUniformIntegerFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FUniformIntegerFieldDataflowNode, NumSamplePositions) == 0x000140, "Member 'FUniformIntegerFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.WaveScalarFieldDataflowNode
// 0x00A0 (0x0188 - 0x00E8)
struct FWaveScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector3f>                      SamplePositions;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               SampleIndices;                                     // 0x00F8(0x0020)(NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF8[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Position;                                          // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translation;                                       // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wavelength;                                        // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Period;                                            // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowWaveFunctionType                     FunctionType;                                      // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFieldFalloffType                     FalloffType;                                       // 0x0159(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BF9[0x6];                                     // 0x015A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFA[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaveScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FWaveScalarFieldDataflowNode");
static_assert(sizeof(FWaveScalarFieldDataflowNode) == 0x000188, "Wrong size on FWaveScalarFieldDataflowNode");
static_assert(offsetof(FWaveScalarFieldDataflowNode, SamplePositions) == 0x0000E8, "Member 'FWaveScalarFieldDataflowNode::SamplePositions' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, SampleIndices) == 0x0000F8, "Member 'FWaveScalarFieldDataflowNode::SampleIndices' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Magnitude) == 0x000118, "Member 'FWaveScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Position) == 0x000120, "Member 'FWaveScalarFieldDataflowNode::Position' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Translation) == 0x000138, "Member 'FWaveScalarFieldDataflowNode::Translation' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Wavelength) == 0x000150, "Member 'FWaveScalarFieldDataflowNode::Wavelength' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, Period) == 0x000154, "Member 'FWaveScalarFieldDataflowNode::Period' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FunctionType) == 0x000158, "Member 'FWaveScalarFieldDataflowNode::FunctionType' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FalloffType) == 0x000159, "Member 'FWaveScalarFieldDataflowNode::FalloffType' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FieldFloatResult) == 0x000160, "Member 'FWaveScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, FieldRemap) == 0x000170, "Member 'FWaveScalarFieldDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FWaveScalarFieldDataflowNode, NumSamplePositions) == 0x000180, "Member 'FWaveScalarFieldDataflowNode::NumSamplePositions' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetBoxLengthsDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FGetBoxLengthsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FBox>                           Boxes;                                             // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Lengths;                                           // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	EBoxLengthMeasurementMethod                   MeasurementMethod;                                 // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFB[0x7];                                     // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetBoxLengthsDataflowNode) == 0x000008, "Wrong alignment on FGetBoxLengthsDataflowNode");
static_assert(sizeof(FGetBoxLengthsDataflowNode) == 0x000110, "Wrong size on FGetBoxLengthsDataflowNode");
static_assert(offsetof(FGetBoxLengthsDataflowNode, Boxes) == 0x0000E8, "Member 'FGetBoxLengthsDataflowNode::Boxes' has a wrong offset!");
static_assert(offsetof(FGetBoxLengthsDataflowNode, Lengths) == 0x0000F8, "Member 'FGetBoxLengthsDataflowNode::Lengths' has a wrong offset!");
static_assert(offsetof(FGetBoxLengthsDataflowNode, MeasurementMethod) == 0x000108, "Member 'FGetBoxLengthsDataflowNode::MeasurementMethod' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SumScalarFieldDataflowNode
// 0x0068 (0x0150 - 0x00E8)
struct FSumScalarFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloatLeft;                                    // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapLeft;                                    // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatRight;                                   // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapRight;                                   // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowFloatFieldOperationType              Operation;                                         // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapInputs;                                       // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFC[0x2];                                     // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 FieldFloatResult;                                  // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0140(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSumScalarFieldDataflowNode) == 0x000008, "Wrong alignment on FSumScalarFieldDataflowNode");
static_assert(sizeof(FSumScalarFieldDataflowNode) == 0x000150, "Wrong size on FSumScalarFieldDataflowNode");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatLeft) == 0x0000E8, "Member 'FSumScalarFieldDataflowNode::FieldFloatLeft' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemapLeft) == 0x0000F8, "Member 'FSumScalarFieldDataflowNode::FieldRemapLeft' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatRight) == 0x000108, "Member 'FSumScalarFieldDataflowNode::FieldFloatRight' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemapRight) == 0x000118, "Member 'FSumScalarFieldDataflowNode::FieldRemapRight' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, Magnitude) == 0x000128, "Member 'FSumScalarFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, Operation) == 0x00012C, "Member 'FSumScalarFieldDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, bSwapInputs) == 0x00012D, "Member 'FSumScalarFieldDataflowNode::bSwapInputs' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldFloatResult) == 0x000130, "Member 'FSumScalarFieldDataflowNode::FieldFloatResult' has a wrong offset!");
static_assert(offsetof(FSumScalarFieldDataflowNode, FieldRemap) == 0x000140, "Member 'FSumScalarFieldDataflowNode::FieldRemap' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SumVectorFieldDataflowNode
// 0x0088 (0x0170 - 0x00E8)
struct FSumVectorFieldDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloat;                                        // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldFloatRemap;                                   // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorLeft;                                   // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapLeft;                                    // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        FieldVectorRight;                                  // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemapRight;                                   // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Magnitude;                                         // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDataflowVectorFieldOperationType             Operation;                                         // 0x014C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapVectorInputs;                                 // 0x014D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFD[0x2];                                     // 0x014E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        FieldVectorResult;                                 // 0x0150(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSumVectorFieldDataflowNode) == 0x000008, "Wrong alignment on FSumVectorFieldDataflowNode");
static_assert(sizeof(FSumVectorFieldDataflowNode) == 0x000170, "Wrong size on FSumVectorFieldDataflowNode");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldFloat) == 0x0000E8, "Member 'FSumVectorFieldDataflowNode::FieldFloat' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldFloatRemap) == 0x0000F8, "Member 'FSumVectorFieldDataflowNode::FieldFloatRemap' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorLeft) == 0x000108, "Member 'FSumVectorFieldDataflowNode::FieldVectorLeft' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemapLeft) == 0x000118, "Member 'FSumVectorFieldDataflowNode::FieldRemapLeft' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorRight) == 0x000128, "Member 'FSumVectorFieldDataflowNode::FieldVectorRight' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemapRight) == 0x000138, "Member 'FSumVectorFieldDataflowNode::FieldRemapRight' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, Magnitude) == 0x000148, "Member 'FSumVectorFieldDataflowNode::Magnitude' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, Operation) == 0x00014C, "Member 'FSumVectorFieldDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, bSwapVectorInputs) == 0x00014D, "Member 'FSumVectorFieldDataflowNode::bSwapVectorInputs' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldVectorResult) == 0x000150, "Member 'FSumVectorFieldDataflowNode::FieldVectorResult' has a wrong offset!");
static_assert(offsetof(FSumVectorFieldDataflowNode, FieldRemap) == 0x000160, "Member 'FSumVectorFieldDataflowNode::FieldRemap' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetMeshDataDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FGetMeshDataDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexCount;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EdgeCount;                                         // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFE[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetMeshDataDataflowNode) == 0x000008, "Wrong alignment on FGetMeshDataDataflowNode");
static_assert(sizeof(FGetMeshDataDataflowNode) == 0x000100, "Wrong size on FGetMeshDataDataflowNode");
static_assert(offsetof(FGetMeshDataDataflowNode, Mesh) == 0x0000E8, "Member 'FGetMeshDataDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, VertexCount) == 0x0000F0, "Member 'FGetMeshDataDataflowNode::VertexCount' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, EdgeCount) == 0x0000F4, "Member 'FGetMeshDataDataflowNode::EdgeCount' has a wrong offset!");
static_assert(offsetof(FGetMeshDataDataflowNode, TriangleCount) == 0x0000F8, "Member 'FGetMeshDataDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FieldMakeDenseFloatArrayDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FFieldMakeDenseFloatArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 FieldFloatInput;                                   // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FieldRemap;                                        // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         NumSamplePositions;                                // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Default;                                           // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 FieldFloatResult;                                  // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldMakeDenseFloatArrayDataflowNode) == 0x000008, "Wrong alignment on FFieldMakeDenseFloatArrayDataflowNode");
static_assert(sizeof(FFieldMakeDenseFloatArrayDataflowNode) == 0x000120, "Wrong size on FFieldMakeDenseFloatArrayDataflowNode");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldFloatInput) == 0x0000E8, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldFloatInput' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldRemap) == 0x0000F8, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldRemap' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, NumSamplePositions) == 0x000108, "Member 'FFieldMakeDenseFloatArrayDataflowNode::NumSamplePositions' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, Default) == 0x00010C, "Member 'FFieldMakeDenseFloatArrayDataflowNode::Default' has a wrong offset!");
static_assert(offsetof(FFieldMakeDenseFloatArrayDataflowNode, FieldFloatResult) == 0x000110, "Member 'FFieldMakeDenseFloatArrayDataflowNode::FieldFloatResult' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AddMaterialToCollectionDataflowNode
// 0x00F8 (0x01E0 - 0x00E8)
struct FAddMaterialToCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01B8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              OutsideMaterial;                                   // 0x01C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              InsideMaterial;                                    // 0x01D0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignOutsideMaterial;                            // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignInsideMaterial;                             // 0x01D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BFF[0x6];                                     // 0x01DA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddMaterialToCollectionDataflowNode) == 0x000008, "Wrong alignment on FAddMaterialToCollectionDataflowNode");
static_assert(sizeof(FAddMaterialToCollectionDataflowNode) == 0x0001E0, "Wrong size on FAddMaterialToCollectionDataflowNode");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FAddMaterialToCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, FaceSelection) == 0x000198, "Member 'FAddMaterialToCollectionDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, Materials) == 0x0001B8, "Member 'FAddMaterialToCollectionDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, OutsideMaterial) == 0x0001C8, "Member 'FAddMaterialToCollectionDataflowNode::OutsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, InsideMaterial) == 0x0001D0, "Member 'FAddMaterialToCollectionDataflowNode::InsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, bAssignOutsideMaterial) == 0x0001D8, "Member 'FAddMaterialToCollectionDataflowNode::bAssignOutsideMaterial' has a wrong offset!");
static_assert(offsetof(FAddMaterialToCollectionDataflowNode, bAssignInsideMaterial) == 0x0001D9, "Member 'FAddMaterialToCollectionDataflowNode::bAssignInsideMaterial' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshToCollectionDataflowNode
// 0x00B8 (0x01A0 - 0x00E8)
struct FMeshToCollectionDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshToCollectionDataflowNode) == 0x000008, "Wrong alignment on FMeshToCollectionDataflowNode");
static_assert(sizeof(FMeshToCollectionDataflowNode) == 0x0001A0, "Wrong size on FMeshToCollectionDataflowNode");
static_assert(offsetof(FMeshToCollectionDataflowNode, Mesh) == 0x0000E8, "Member 'FMeshToCollectionDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshToCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FMeshToCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ReAssignMaterialInCollectionDataflowNode
// 0x00F0 (0x01D8 - 0x00E8)
struct FReAssignMaterialInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	TArray<class UMaterial*>                      Materials;                                         // 0x01B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         OutsideMaterialIdx;                                // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InsideMaterialIdx;                                 // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignOutsideMaterial;                            // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAssignInsideMaterial;                             // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C00[0x6];                                     // 0x01D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReAssignMaterialInCollectionDataflowNode) == 0x000008, "Wrong alignment on FReAssignMaterialInCollectionDataflowNode");
static_assert(sizeof(FReAssignMaterialInCollectionDataflowNode) == 0x0001D8, "Wrong size on FReAssignMaterialInCollectionDataflowNode");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FReAssignMaterialInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, FaceSelection) == 0x000198, "Member 'FReAssignMaterialInCollectionDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, Materials) == 0x0001B8, "Member 'FReAssignMaterialInCollectionDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, OutsideMaterialIdx) == 0x0001C8, "Member 'FReAssignMaterialInCollectionDataflowNode::OutsideMaterialIdx' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, InsideMaterialIdx) == 0x0001CC, "Member 'FReAssignMaterialInCollectionDataflowNode::InsideMaterialIdx' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, bAssignOutsideMaterial) == 0x0001D0, "Member 'FReAssignMaterialInCollectionDataflowNode::bAssignOutsideMaterial' has a wrong offset!");
static_assert(offsetof(FReAssignMaterialInCollectionDataflowNode, bAssignInsideMaterial) == 0x0001D1, "Member 'FReAssignMaterialInCollectionDataflowNode::bAssignInsideMaterial' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MaterialsInfoDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FMaterialsInfoDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialsInfoDataflowNode) == 0x000008, "Wrong alignment on FMaterialsInfoDataflowNode");
static_assert(sizeof(FMaterialsInfoDataflowNode) == 0x000108, "Wrong size on FMaterialsInfoDataflowNode");
static_assert(offsetof(FMaterialsInfoDataflowNode, Materials) == 0x0000E8, "Member 'FMaterialsInfoDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FMaterialsInfoDataflowNode, String) == 0x0000F8, "Member 'FMaterialsInfoDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LogStringDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FLogStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          bPrintToLog;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C01[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogStringDataflowNode) == 0x000008, "Wrong alignment on FLogStringDataflowNode");
static_assert(sizeof(FLogStringDataflowNode) == 0x000100, "Wrong size on FLogStringDataflowNode");
static_assert(offsetof(FLogStringDataflowNode, bPrintToLog) == 0x0000E8, "Member 'FLogStringDataflowNode::bPrintToLog' has a wrong offset!");
static_assert(offsetof(FLogStringDataflowNode, String) == 0x0000F0, "Member 'FLogStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetMaterialFromMaterialsArrayDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FGetMaterialFromMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIdx;                                       // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C02[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetMaterialFromMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FGetMaterialFromMaterialsArrayDataflowNode");
static_assert(sizeof(FGetMaterialFromMaterialsArrayDataflowNode) == 0x000108, "Wrong size on FGetMaterialFromMaterialsArrayDataflowNode");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, Materials) == 0x0000E8, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, Material) == 0x0000F8, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::Material' has a wrong offset!");
static_assert(offsetof(FGetMaterialFromMaterialsArrayDataflowNode, MaterialIdx) == 0x000100, "Member 'FGetMaterialFromMaterialsArrayDataflowNode::MaterialIdx' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetMaterialInMaterialsArrayDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FSetMaterialInMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x00F8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESetMaterialOperationTypeEnum                 Operation;                                         // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C03[0x3];                                     // 0x0101(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaterialIdx;                                       // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetMaterialInMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FSetMaterialInMaterialsArrayDataflowNode");
static_assert(sizeof(FSetMaterialInMaterialsArrayDataflowNode) == 0x000108, "Wrong size on FSetMaterialInMaterialsArrayDataflowNode");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Materials) == 0x0000E8, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Materials' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Material) == 0x0000F8, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Material' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, Operation) == 0x000100, "Member 'FSetMaterialInMaterialsArrayDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FSetMaterialInMaterialsArrayDataflowNode, MaterialIdx) == 0x000104, "Member 'FSetMaterialInMaterialsArrayDataflowNode::MaterialIdx' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCentroidsFromCollectionDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FGetCentroidsFromCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Centroids;                                         // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCentroidsFromCollectionDataflowNode) == 0x000008, "Wrong alignment on FGetCentroidsFromCollectionDataflowNode");
static_assert(sizeof(FGetCentroidsFromCollectionDataflowNode) == 0x0001C8, "Wrong size on FGetCentroidsFromCollectionDataflowNode");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FGetCentroidsFromCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, TransformSelection) == 0x000198, "Member 'FGetCentroidsFromCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FGetCentroidsFromCollectionDataflowNode, Centroids) == 0x0001B8, "Member 'FGetCentroidsFromCollectionDataflowNode::Centroids' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeMaterialDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMakeMaterialDataflowNode final : public FDataflowNode
{
public:
	class UMaterial*                              InMaterial;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeMaterialDataflowNode) == 0x000008, "Wrong alignment on FMakeMaterialDataflowNode");
static_assert(sizeof(FMakeMaterialDataflowNode) == 0x0000F8, "Wrong size on FMakeMaterialDataflowNode");
static_assert(offsetof(FMakeMaterialDataflowNode, InMaterial) == 0x0000E8, "Member 'FMakeMaterialDataflowNode::InMaterial' has a wrong offset!");
static_assert(offsetof(FMakeMaterialDataflowNode, Material) == 0x0000F0, "Member 'FMakeMaterialDataflowNode::Material' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeMaterialsArrayDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMakeMaterialsArrayDataflowNode final : public FDataflowNode
{
public:
	TArray<class UMaterial*>                      Materials;                                         // 0x00E8(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeMaterialsArrayDataflowNode) == 0x000008, "Wrong alignment on FMakeMaterialsArrayDataflowNode");
static_assert(sizeof(FMakeMaterialsArrayDataflowNode) == 0x0000F8, "Wrong size on FMakeMaterialsArrayDataflowNode");
static_assert(offsetof(FMakeMaterialsArrayDataflowNode, Materials) == 0x0000E8, "Member 'FMakeMaterialsArrayDataflowNode::Materials' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandVectorDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FExpandVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C04[0x4];                                     // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandVectorDataflowNode) == 0x000008, "Wrong alignment on FExpandVectorDataflowNode");
static_assert(sizeof(FExpandVectorDataflowNode) == 0x000110, "Wrong size on FExpandVectorDataflowNode");
static_assert(offsetof(FExpandVectorDataflowNode, Vector) == 0x0000E8, "Member 'FExpandVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, X) == 0x000100, "Member 'FExpandVectorDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Y) == 0x000104, "Member 'FExpandVectorDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FExpandVectorDataflowNode, Z) == 0x000108, "Member 'FExpandVectorDataflowNode::Z' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CloseGeometryOnCollectionDataflowNode
// 0x00B0 (0x0198 - 0x00E8)
struct FCloseGeometryOnCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloseGeometryOnCollectionDataflowNode) == 0x000008, "Wrong alignment on FCloseGeometryOnCollectionDataflowNode");
static_assert(sizeof(FCloseGeometryOnCollectionDataflowNode) == 0x000198, "Wrong size on FCloseGeometryOnCollectionDataflowNode");
static_assert(offsetof(FCloseGeometryOnCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FCloseGeometryOnCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SkeletonToCollectionDataflowNode
// 0x00B8 (0x01A0 - 0x00E8)
struct FSkeletonToCollectionDataflowNode final : public FDataflowNode
{
public:
	class USkeleton*                              Skeleton;                                          // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkeletonToCollectionDataflowNode) == 0x000008, "Wrong alignment on FSkeletonToCollectionDataflowNode");
static_assert(sizeof(FSkeletonToCollectionDataflowNode) == 0x0001A0, "Wrong size on FSkeletonToCollectionDataflowNode");
static_assert(offsetof(FSkeletonToCollectionDataflowNode, Skeleton) == 0x0000E8, "Member 'FSkeletonToCollectionDataflowNode::Skeleton' has a wrong offset!");
static_assert(offsetof(FSkeletonToCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FSkeletonToCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AppendCollectionAssetsDataflowNode
// 0x0180 (0x0268 - 0x00E8)
struct FAppendCollectionAssetsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection1;                                       // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection2;                                       // 0x0198(0x00B0)(NativeAccessSpecifierPublic)
	TArray<class FString>                         GeometryGroupGuidsOut1;                            // 0x0248(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         GeometryGroupGuidsOut2;                            // 0x0258(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAppendCollectionAssetsDataflowNode) == 0x000008, "Wrong alignment on FAppendCollectionAssetsDataflowNode");
static_assert(sizeof(FAppendCollectionAssetsDataflowNode) == 0x000268, "Wrong size on FAppendCollectionAssetsDataflowNode");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, Collection1) == 0x0000E8, "Member 'FAppendCollectionAssetsDataflowNode::Collection1' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, Collection2) == 0x000198, "Member 'FAppendCollectionAssetsDataflowNode::Collection2' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, GeometryGroupGuidsOut1) == 0x000248, "Member 'FAppendCollectionAssetsDataflowNode::GeometryGroupGuidsOut1' has a wrong offset!");
static_assert(offsetof(FAppendCollectionAssetsDataflowNode, GeometryGroupGuidsOut2) == 0x000258, "Member 'FAppendCollectionAssetsDataflowNode::GeometryGroupGuidsOut2' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DataflowConvexDecompositionSettings
// 0x0018 (0x0018 - 0x0000)
struct FDataflowConvexDecompositionSettings final
{
public:
	float                                         MinSizeToDecompose;                                // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeoToHullVolumeRatioToDecompose;                // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHullsPerGeometry;                               // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThicknessTolerance;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAdditionalSplits;                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDataflowConvexDecompositionSettings) == 0x000004, "Wrong alignment on FDataflowConvexDecompositionSettings");
static_assert(sizeof(FDataflowConvexDecompositionSettings) == 0x000018, "Wrong size on FDataflowConvexDecompositionSettings");
static_assert(offsetof(FDataflowConvexDecompositionSettings, MinSizeToDecompose) == 0x000000, "Member 'FDataflowConvexDecompositionSettings::MinSizeToDecompose' has a wrong offset!");
static_assert(offsetof(FDataflowConvexDecompositionSettings, MaxGeoToHullVolumeRatioToDecompose) == 0x000004, "Member 'FDataflowConvexDecompositionSettings::MaxGeoToHullVolumeRatioToDecompose' has a wrong offset!");
static_assert(offsetof(FDataflowConvexDecompositionSettings, ErrorTolerance) == 0x000008, "Member 'FDataflowConvexDecompositionSettings::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(FDataflowConvexDecompositionSettings, MaxHullsPerGeometry) == 0x00000C, "Member 'FDataflowConvexDecompositionSettings::MaxHullsPerGeometry' has a wrong offset!");
static_assert(offsetof(FDataflowConvexDecompositionSettings, MinThicknessTolerance) == 0x000010, "Member 'FDataflowConvexDecompositionSettings::MinThicknessTolerance' has a wrong offset!");
static_assert(offsetof(FDataflowConvexDecompositionSettings, NumAdditionalSplits) == 0x000014, "Member 'FDataflowConvexDecompositionSettings::NumAdditionalSplits' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeDataflowConvexDecompositionSettingsNode
// 0x0030 (0x0118 - 0x00E8)
struct FMakeDataflowConvexDecompositionSettingsNode final : public FDataflowNode
{
public:
	float                                         MinSizeToDecompose;                                // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxGeoToHullVolumeRatioToDecompose;                // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHullsPerGeometry;                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinThicknessTolerance;                             // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAdditionalSplits;                               // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowConvexDecompositionSettings   DecompositionSettings;                             // 0x0100(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeDataflowConvexDecompositionSettingsNode) == 0x000008, "Wrong alignment on FMakeDataflowConvexDecompositionSettingsNode");
static_assert(sizeof(FMakeDataflowConvexDecompositionSettingsNode) == 0x000118, "Wrong size on FMakeDataflowConvexDecompositionSettingsNode");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, MinSizeToDecompose) == 0x0000E8, "Member 'FMakeDataflowConvexDecompositionSettingsNode::MinSizeToDecompose' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, MaxGeoToHullVolumeRatioToDecompose) == 0x0000EC, "Member 'FMakeDataflowConvexDecompositionSettingsNode::MaxGeoToHullVolumeRatioToDecompose' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, ErrorTolerance) == 0x0000F0, "Member 'FMakeDataflowConvexDecompositionSettingsNode::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, MaxHullsPerGeometry) == 0x0000F4, "Member 'FMakeDataflowConvexDecompositionSettingsNode::MaxHullsPerGeometry' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, MinThicknessTolerance) == 0x0000F8, "Member 'FMakeDataflowConvexDecompositionSettingsNode::MinThicknessTolerance' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, NumAdditionalSplits) == 0x0000FC, "Member 'FMakeDataflowConvexDecompositionSettingsNode::NumAdditionalSplits' has a wrong offset!");
static_assert(offsetof(FMakeDataflowConvexDecompositionSettingsNode, DecompositionSettings) == 0x000100, "Member 'FMakeDataflowConvexDecompositionSettingsNode::DecompositionSettings' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateLeafConvexHullsDataflowNode
// 0x00F8 (0x01E0 - 0x00E8)
struct FCreateLeafConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	EGenerateConvexMethod                         GenerateMethod;                                    // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C05[0x3];                                     // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntersectIfComputedIsSmallerByFactor;              // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinExternalVolumeToIntersect;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationDistanceThreshold;                   // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowConvexDecompositionSettings   ConvexDecompositionSettings;                       // 0x01C8(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateLeafConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FCreateLeafConvexHullsDataflowNode");
static_assert(sizeof(FCreateLeafConvexHullsDataflowNode) == 0x0001E0, "Wrong size on FCreateLeafConvexHullsDataflowNode");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, Collection) == 0x0000E8, "Member 'FCreateLeafConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, OptionalSelectionFilter) == 0x000198, "Member 'FCreateLeafConvexHullsDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, GenerateMethod) == 0x0001B8, "Member 'FCreateLeafConvexHullsDataflowNode::GenerateMethod' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, IntersectIfComputedIsSmallerByFactor) == 0x0001BC, "Member 'FCreateLeafConvexHullsDataflowNode::IntersectIfComputedIsSmallerByFactor' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, MinExternalVolumeToIntersect) == 0x0001C0, "Member 'FCreateLeafConvexHullsDataflowNode::MinExternalVolumeToIntersect' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, SimplificationDistanceThreshold) == 0x0001C4, "Member 'FCreateLeafConvexHullsDataflowNode::SimplificationDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FCreateLeafConvexHullsDataflowNode, ConvexDecompositionSettings) == 0x0001C8, "Member 'FCreateLeafConvexHullsDataflowNode::ConvexDecompositionSettings' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SimplifyConvexHullsDataflowNode
// 0x00E8 (0x01D0 - 0x00E8)
struct FSimplifyConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	EConvexHullSimplifyMethod                     SimplifyMethod;                                    // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationAngleThreshold;                      // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationDistanceThreshold;                   // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinTargetTriangleCount;                            // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExistingVertices;                              // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C06[0x7];                                     // 0x01C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSimplifyConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FSimplifyConvexHullsDataflowNode");
static_assert(sizeof(FSimplifyConvexHullsDataflowNode) == 0x0001D0, "Wrong size on FSimplifyConvexHullsDataflowNode");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, Collection) == 0x0000E8, "Member 'FSimplifyConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, OptionalSelectionFilter) == 0x000198, "Member 'FSimplifyConvexHullsDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, SimplifyMethod) == 0x0001B8, "Member 'FSimplifyConvexHullsDataflowNode::SimplifyMethod' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, SimplificationAngleThreshold) == 0x0001BC, "Member 'FSimplifyConvexHullsDataflowNode::SimplificationAngleThreshold' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, SimplificationDistanceThreshold) == 0x0001C0, "Member 'FSimplifyConvexHullsDataflowNode::SimplificationDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, MinTargetTriangleCount) == 0x0001C4, "Member 'FSimplifyConvexHullsDataflowNode::MinTargetTriangleCount' has a wrong offset!");
static_assert(offsetof(FSimplifyConvexHullsDataflowNode, bUseExistingVertices) == 0x0001C8, "Member 'FSimplifyConvexHullsDataflowNode::bUseExistingVertices' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetSchemaDataflowNode
// 0x00C0 (0x01A8 - 0x00E8)
struct FGetSchemaDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0198(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetSchemaDataflowNode) == 0x000008, "Wrong alignment on FGetSchemaDataflowNode");
static_assert(sizeof(FGetSchemaDataflowNode) == 0x0001A8, "Wrong size on FGetSchemaDataflowNode");
static_assert(offsetof(FGetSchemaDataflowNode, Collection) == 0x0000E8, "Member 'FGetSchemaDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetSchemaDataflowNode, String) == 0x000198, "Member 'FGetSchemaDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CreateNonOverlappingConvexHullsDataflowNode
// 0x00C8 (0x01B0 - 0x00E8)
struct FCreateNonOverlappingConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	float                                         CanExceedFraction;                                 // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimplificationDistanceThreshold;                   // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConvexOverlapRemovalMethodEnum               OverlapRemovalMethod;                              // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C07[0x3];                                     // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverlapRemovalShrinkPercent;                       // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanRemoveFraction;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C08[0x4];                                     // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(sizeof(FCreateNonOverlappingConvexHullsDataflowNode) == 0x0001B0, "Wrong size on FCreateNonOverlappingConvexHullsDataflowNode");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, Collection) == 0x0000E8, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanExceedFraction) == 0x000198, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanExceedFraction' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, SimplificationDistanceThreshold) == 0x00019C, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::SimplificationDistanceThreshold' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, OverlapRemovalMethod) == 0x0001A0, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::OverlapRemovalMethod' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, OverlapRemovalShrinkPercent) == 0x0001A4, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::OverlapRemovalShrinkPercent' has a wrong offset!");
static_assert(offsetof(FCreateNonOverlappingConvexHullsDataflowNode, CanRemoveFraction) == 0x0001A8, "Member 'FCreateNonOverlappingConvexHullsDataflowNode::CanRemoveFraction' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DataflowSphereCovering
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FDataflowSphereCovering final
{
public:
	uint8                                         Pad_2C09[0x20];                                    // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDataflowSphereCovering) == 0x000008, "Wrong alignment on FDataflowSphereCovering");
static_assert(sizeof(FDataflowSphereCovering) == 0x000020, "Wrong size on FDataflowSphereCovering");

// ScriptStruct GeometryCollectionNodes.GenerateClusterConvexHullsFromLeafHullsDataflowNode
// 0x0128 (0x0210 - 0x00E8)
struct FGenerateClusterConvexHullsFromLeafHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowSphereCovering                SphereCovering;                                    // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	int32                                         ConvexCount;                                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0A[0x4];                                     // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ErrorTolerance;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferExternalCollisionShapes;                    // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAllowConvexMergeMethod                       AllowMerges;                                       // 0x01C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0B[0x6];                                     // 0x01CA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bProtectNegativeSpace;                             // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0C[0x3];                                     // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetNumSamples;                                  // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinSampleSpacing;                                  // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NegativeSpaceTolerance;                            // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinRadius;                                         // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode) == 0x000008, "Wrong alignment on FGenerateClusterConvexHullsFromLeafHullsDataflowNode");
static_assert(sizeof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode) == 0x000210, "Wrong size on FGenerateClusterConvexHullsFromLeafHullsDataflowNode");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, Collection) == 0x0000E8, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, SphereCovering) == 0x000198, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::SphereCovering' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, ConvexCount) == 0x0001B8, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::ConvexCount' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, ErrorTolerance) == 0x0001C0, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, bPreferExternalCollisionShapes) == 0x0001C8, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::bPreferExternalCollisionShapes' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, AllowMerges) == 0x0001C9, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::AllowMerges' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, OptionalSelectionFilter) == 0x0001D0, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, bProtectNegativeSpace) == 0x0001F0, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::bProtectNegativeSpace' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, TargetNumSamples) == 0x0001F4, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::TargetNumSamples' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, MinSampleSpacing) == 0x0001F8, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::MinSampleSpacing' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, NegativeSpaceTolerance) == 0x000200, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::NegativeSpaceTolerance' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromLeafHullsDataflowNode, MinRadius) == 0x000208, "Member 'FGenerateClusterConvexHullsFromLeafHullsDataflowNode::MinRadius' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GenerateClusterConvexHullsFromChildrenHullsDataflowNode
// 0x0128 (0x0210 - 0x00E8)
struct FGenerateClusterConvexHullsFromChildrenHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowSphereCovering                SphereCovering;                                    // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	int32                                         ConvexCount;                                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0D[0x4];                                     // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ErrorTolerance;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreferExternalCollisionShapes;                    // 0x01C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0E[0x7];                                     // 0x01C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bProtectNegativeSpace;                             // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0F[0x3];                                     // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetNumSamples;                                  // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinSampleSpacing;                                  // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NegativeSpaceTolerance;                            // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinRadius;                                         // 0x0208(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode) == 0x000008, "Wrong alignment on FGenerateClusterConvexHullsFromChildrenHullsDataflowNode");
static_assert(sizeof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode) == 0x000210, "Wrong size on FGenerateClusterConvexHullsFromChildrenHullsDataflowNode");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, Collection) == 0x0000E8, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, SphereCovering) == 0x000198, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::SphereCovering' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, ConvexCount) == 0x0001B8, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::ConvexCount' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, ErrorTolerance) == 0x0001C0, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, bPreferExternalCollisionShapes) == 0x0001C8, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::bPreferExternalCollisionShapes' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, OptionalSelectionFilter) == 0x0001D0, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, bProtectNegativeSpace) == 0x0001F0, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::bProtectNegativeSpace' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, TargetNumSamples) == 0x0001F4, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::TargetNumSamples' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, MinSampleSpacing) == 0x0001F8, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::MinSampleSpacing' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, NegativeSpaceTolerance) == 0x000200, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::NegativeSpaceTolerance' has a wrong offset!");
static_assert(offsetof(FGenerateClusterConvexHullsFromChildrenHullsDataflowNode, MinRadius) == 0x000208, "Member 'FGenerateClusterConvexHullsFromChildrenHullsDataflowNode::MinRadius' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MergeConvexHullsDataflowNode
// 0x0120 (0x0208 - 0x00E8)
struct FMergeConvexHullsDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowSphereCovering                SphereCovering;                                    // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	int32                                         MaxConvexCount;                                    // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C10[0x4];                                     // 0x01BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        ErrorTolerance;                                    // 0x01C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x01C8(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bProtectNegativeSpace;                             // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C11[0x3];                                     // 0x01E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetNumSamples;                                  // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinSampleSpacing;                                  // 0x01F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        NegativeSpaceTolerance;                            // 0x01F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MinRadius;                                         // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMergeConvexHullsDataflowNode) == 0x000008, "Wrong alignment on FMergeConvexHullsDataflowNode");
static_assert(sizeof(FMergeConvexHullsDataflowNode) == 0x000208, "Wrong size on FMergeConvexHullsDataflowNode");
static_assert(offsetof(FMergeConvexHullsDataflowNode, Collection) == 0x0000E8, "Member 'FMergeConvexHullsDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, SphereCovering) == 0x000198, "Member 'FMergeConvexHullsDataflowNode::SphereCovering' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, MaxConvexCount) == 0x0001B8, "Member 'FMergeConvexHullsDataflowNode::MaxConvexCount' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, ErrorTolerance) == 0x0001C0, "Member 'FMergeConvexHullsDataflowNode::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, OptionalSelectionFilter) == 0x0001C8, "Member 'FMergeConvexHullsDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, bProtectNegativeSpace) == 0x0001E8, "Member 'FMergeConvexHullsDataflowNode::bProtectNegativeSpace' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, TargetNumSamples) == 0x0001EC, "Member 'FMergeConvexHullsDataflowNode::TargetNumSamples' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, MinSampleSpacing) == 0x0001F0, "Member 'FMergeConvexHullsDataflowNode::MinSampleSpacing' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, NegativeSpaceTolerance) == 0x0001F8, "Member 'FMergeConvexHullsDataflowNode::NegativeSpaceTolerance' has a wrong offset!");
static_assert(offsetof(FMergeConvexHullsDataflowNode, MinRadius) == 0x000200, "Member 'FMergeConvexHullsDataflowNode::MinRadius' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UpdateVolumeAttributesDataflowNode
// 0x00B0 (0x0198 - 0x00E8)
struct FUpdateVolumeAttributesDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdateVolumeAttributesDataflowNode) == 0x000008, "Wrong alignment on FUpdateVolumeAttributesDataflowNode");
static_assert(sizeof(FUpdateVolumeAttributesDataflowNode) == 0x000198, "Wrong size on FUpdateVolumeAttributesDataflowNode");
static_assert(offsetof(FUpdateVolumeAttributesDataflowNode, Collection) == 0x0000E8, "Member 'FUpdateVolumeAttributesDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BranchDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FBranchDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           MeshA;                                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           MeshB;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCondition;                                        // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C12[0x7];                                     // 0x00F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x0100(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchDataflowNode) == 0x000008, "Wrong alignment on FBranchDataflowNode");
static_assert(sizeof(FBranchDataflowNode) == 0x000108, "Wrong size on FBranchDataflowNode");
static_assert(offsetof(FBranchDataflowNode, MeshA) == 0x0000E8, "Member 'FBranchDataflowNode::MeshA' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, MeshB) == 0x0000F0, "Member 'FBranchDataflowNode::MeshB' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, bCondition) == 0x0000F8, "Member 'FBranchDataflowNode::bCondition' has a wrong offset!");
static_assert(offsetof(FBranchDataflowNode, Mesh) == 0x000100, "Member 'FBranchDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetConvexHullVolumeDataflowNode
// 0x00D8 (0x01C0 - 0x00E8)
struct FGetConvexHullVolumeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x01B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSumChildrenForClustersWithoutHulls;               // 0x01BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVolumeOfUnion;                                    // 0x01BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C13[0x2];                                     // 0x01BE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetConvexHullVolumeDataflowNode) == 0x000008, "Wrong alignment on FGetConvexHullVolumeDataflowNode");
static_assert(sizeof(FGetConvexHullVolumeDataflowNode) == 0x0001C0, "Wrong size on FGetConvexHullVolumeDataflowNode");
static_assert(offsetof(FGetConvexHullVolumeDataflowNode, Collection) == 0x0000E8, "Member 'FGetConvexHullVolumeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetConvexHullVolumeDataflowNode, TransformSelection) == 0x000198, "Member 'FGetConvexHullVolumeDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FGetConvexHullVolumeDataflowNode, Volume) == 0x0001B8, "Member 'FGetConvexHullVolumeDataflowNode::Volume' has a wrong offset!");
static_assert(offsetof(FGetConvexHullVolumeDataflowNode, bSumChildrenForClustersWithoutHulls) == 0x0001BC, "Member 'FGetConvexHullVolumeDataflowNode::bSumChildrenForClustersWithoutHulls' has a wrong offset!");
static_assert(offsetof(FGetConvexHullVolumeDataflowNode, bVolumeOfUnion) == 0x0001BD, "Member 'FGetConvexHullVolumeDataflowNode::bVolumeOfUnion' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AutoClusterDataflowNode
// 0x00F8 (0x01E0 - 0x00E8)
struct FAutoClusterDataflowNode final : public FDataflowNode
{
public:
	EClusterSizeMethodEnum                        ClusterSizeMethod;                                 // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C14[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClusterSites;                                      // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClusterFraction;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SiteSize;                                          // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClusterGridWidth;                                  // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClusterGridDepth;                                  // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClusterGridHeight;                                 // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DriftIterations;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumSize;                                       // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoCluster;                                       // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnforceSiteParameters;                             // 0x010D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AvoidIsolated;                                     // 0x010E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C15[0x1];                                     // 0x010F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x0110(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01C0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FAutoClusterDataflowNode) == 0x000008, "Wrong alignment on FAutoClusterDataflowNode");
static_assert(sizeof(FAutoClusterDataflowNode) == 0x0001E0, "Wrong size on FAutoClusterDataflowNode");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterSizeMethod) == 0x0000E8, "Member 'FAutoClusterDataflowNode::ClusterSizeMethod' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterSites) == 0x0000EC, "Member 'FAutoClusterDataflowNode::ClusterSites' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterFraction) == 0x0000F0, "Member 'FAutoClusterDataflowNode::ClusterFraction' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, SiteSize) == 0x0000F4, "Member 'FAutoClusterDataflowNode::SiteSize' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterGridWidth) == 0x0000F8, "Member 'FAutoClusterDataflowNode::ClusterGridWidth' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterGridDepth) == 0x0000FC, "Member 'FAutoClusterDataflowNode::ClusterGridDepth' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, ClusterGridHeight) == 0x000100, "Member 'FAutoClusterDataflowNode::ClusterGridHeight' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, DriftIterations) == 0x000104, "Member 'FAutoClusterDataflowNode::DriftIterations' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, MinimumSize) == 0x000108, "Member 'FAutoClusterDataflowNode::MinimumSize' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, AutoCluster) == 0x00010C, "Member 'FAutoClusterDataflowNode::AutoCluster' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, EnforceSiteParameters) == 0x00010D, "Member 'FAutoClusterDataflowNode::EnforceSiteParameters' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, AvoidIsolated) == 0x00010E, "Member 'FAutoClusterDataflowNode::AvoidIsolated' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, Collection) == 0x000110, "Member 'FAutoClusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAutoClusterDataflowNode, TransformSelection) == 0x0001C0, "Member 'FAutoClusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetCollectionAttributeDataTypedDataflowNode
// 0x0148 (0x0230 - 0x00E8)
struct FSetCollectionAttributeDataTypedDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C16[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  BoolAttributeData;                                 // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatAttributeData;                                // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleAttributeData;                               // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Int32AttributeData;                                // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringAttributeData;                               // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fAttributeData;                             // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3d>                      Vector3dAttributeData;                             // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetCollectionAttributeDataTypedDataflowNode) == 0x000008, "Wrong alignment on FSetCollectionAttributeDataTypedDataflowNode");
static_assert(sizeof(FSetCollectionAttributeDataTypedDataflowNode) == 0x000230, "Wrong size on FSetCollectionAttributeDataTypedDataflowNode");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Collection) == 0x0000E8, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, GroupName) == 0x000198, "Member 'FSetCollectionAttributeDataTypedDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, CustomGroupName) == 0x0001A0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, AttrName) == 0x0001B0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, BoolAttributeData) == 0x0001C0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, FloatAttributeData) == 0x0001D0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::FloatAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, DoubleAttributeData) == 0x0001E0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::DoubleAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Int32AttributeData) == 0x0001F0, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Int32AttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, StringAttributeData) == 0x000200, "Member 'FSetCollectionAttributeDataTypedDataflowNode::StringAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Vector3fAttributeData) == 0x000210, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Vector3fAttributeData' has a wrong offset!");
static_assert(offsetof(FSetCollectionAttributeDataTypedDataflowNode, Vector3dAttributeData) == 0x000220, "Member 'FSetCollectionAttributeDataTypedDataflowNode::Vector3dAttributeData' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClusterFlattenDataflowNode
// 0x00B0 (0x0198 - 0x00E8)
struct FClusterFlattenDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterFlattenDataflowNode) == 0x000008, "Wrong alignment on FClusterFlattenDataflowNode");
static_assert(sizeof(FClusterFlattenDataflowNode) == 0x000198, "Wrong size on FClusterFlattenDataflowNode");
static_assert(offsetof(FClusterFlattenDataflowNode, Collection) == 0x0000E8, "Member 'FClusterFlattenDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClusterUnclusterDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FClusterUnclusterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterUnclusterDataflowNode) == 0x000008, "Wrong alignment on FClusterUnclusterDataflowNode");
static_assert(sizeof(FClusterUnclusterDataflowNode) == 0x0001B8, "Wrong size on FClusterUnclusterDataflowNode");
static_assert(offsetof(FClusterUnclusterDataflowNode, Collection) == 0x0000E8, "Member 'FClusterUnclusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FClusterUnclusterDataflowNode, TransformSelection) == 0x000198, "Member 'FClusterUnclusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetAnchorStateDataflowNode
// 0x00D8 (0x01C0 - 0x00E8)
struct FSetAnchorStateDataflowNode final : public FDataflowNode
{
public:
	EAnchorStateEnum                              AnchorState;                                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetNotSelectedBonesToOppositeState;               // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C17[0x6];                                     // 0x00EA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetAnchorStateDataflowNode) == 0x000008, "Wrong alignment on FSetAnchorStateDataflowNode");
static_assert(sizeof(FSetAnchorStateDataflowNode) == 0x0001C0, "Wrong size on FSetAnchorStateDataflowNode");
static_assert(offsetof(FSetAnchorStateDataflowNode, AnchorState) == 0x0000E8, "Member 'FSetAnchorStateDataflowNode::AnchorState' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, bSetNotSelectedBonesToOppositeState) == 0x0000E9, "Member 'FSetAnchorStateDataflowNode::bSetNotSelectedBonesToOppositeState' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, Collection) == 0x0000F0, "Member 'FSetAnchorStateDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetAnchorStateDataflowNode, TransformSelection) == 0x0001A0, "Member 'FSetAnchorStateDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClusterDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FClusterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterDataflowNode) == 0x000008, "Wrong alignment on FClusterDataflowNode");
static_assert(sizeof(FClusterDataflowNode) == 0x0001B8, "Wrong size on FClusterDataflowNode");
static_assert(offsetof(FClusterDataflowNode, Collection) == 0x0000E8, "Member 'FClusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FClusterDataflowNode, TransformSelection) == 0x000198, "Member 'FClusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClusterMergeDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FClusterMergeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FClusterMergeDataflowNode) == 0x000008, "Wrong alignment on FClusterMergeDataflowNode");
static_assert(sizeof(FClusterMergeDataflowNode) == 0x0001B8, "Wrong size on FClusterMergeDataflowNode");
static_assert(offsetof(FClusterMergeDataflowNode, Collection) == 0x0000E8, "Member 'FClusterMergeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FClusterMergeDataflowNode, TransformSelection) == 0x000198, "Member 'FClusterMergeDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CompareIntDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FCompareIntDataflowNode final : public FDataflowNode
{
public:
	ECompareOperationEnum                         Operation;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C18[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntA;                                              // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntB;                                              // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x00F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C19[0x3];                                     // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompareIntDataflowNode) == 0x000008, "Wrong alignment on FCompareIntDataflowNode");
static_assert(sizeof(FCompareIntDataflowNode) == 0x0000F8, "Wrong size on FCompareIntDataflowNode");
static_assert(offsetof(FCompareIntDataflowNode, Operation) == 0x0000E8, "Member 'FCompareIntDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, IntA) == 0x0000EC, "Member 'FCompareIntDataflowNode::IntA' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, IntB) == 0x0000F0, "Member 'FCompareIntDataflowNode::IntB' has a wrong offset!");
static_assert(offsetof(FCompareIntDataflowNode, Result) == 0x0000F4, "Member 'FCompareIntDataflowNode::Result' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VectorToStringDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FVectorToStringDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0100(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorToStringDataflowNode) == 0x000008, "Wrong alignment on FVectorToStringDataflowNode");
static_assert(sizeof(FVectorToStringDataflowNode) == 0x000110, "Wrong size on FVectorToStringDataflowNode");
static_assert(offsetof(FVectorToStringDataflowNode, Vector) == 0x0000E8, "Member 'FVectorToStringDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FVectorToStringDataflowNode, String) == 0x000100, "Member 'FVectorToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToStringDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FFloatToStringDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1A[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatToStringDataflowNode) == 0x000008, "Wrong alignment on FFloatToStringDataflowNode");
static_assert(sizeof(FFloatToStringDataflowNode) == 0x000100, "Wrong size on FFloatToStringDataflowNode");
static_assert(offsetof(FFloatToStringDataflowNode, Float) == 0x0000E8, "Member 'FFloatToStringDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToStringDataflowNode, String) == 0x0000F0, "Member 'FFloatToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetNumElementsInCollectionGroupDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FGetNumElementsInCollectionGroupDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1B[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumElements;                                       // 0x01B0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1C[0x4];                                     // 0x01B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetNumElementsInCollectionGroupDataflowNode) == 0x000008, "Wrong alignment on FGetNumElementsInCollectionGroupDataflowNode");
static_assert(sizeof(FGetNumElementsInCollectionGroupDataflowNode) == 0x0001B8, "Wrong size on FGetNumElementsInCollectionGroupDataflowNode");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, Collection) == 0x0000E8, "Member 'FGetNumElementsInCollectionGroupDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, GroupName) == 0x000198, "Member 'FGetNumElementsInCollectionGroupDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, CustomGroupName) == 0x0001A0, "Member 'FGetNumElementsInCollectionGroupDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FGetNumElementsInCollectionGroupDataflowNode, NumElements) == 0x0001B0, "Member 'FGetNumElementsInCollectionGroupDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToStringDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FIntToStringDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1D[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToStringDataflowNode) == 0x000008, "Wrong alignment on FIntToStringDataflowNode");
static_assert(sizeof(FIntToStringDataflowNode) == 0x000100, "Wrong size on FIntToStringDataflowNode");
static_assert(offsetof(FIntToStringDataflowNode, Int) == 0x0000E8, "Member 'FIntToStringDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToStringDataflowNode, String) == 0x0000F0, "Member 'FIntToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolToStringDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FBoolToStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          Bool;                                              // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1E[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolToStringDataflowNode) == 0x000008, "Wrong alignment on FBoolToStringDataflowNode");
static_assert(sizeof(FBoolToStringDataflowNode) == 0x000100, "Wrong size on FBoolToStringDataflowNode");
static_assert(offsetof(FBoolToStringDataflowNode, Bool) == 0x0000E8, "Member 'FBoolToStringDataflowNode::Bool' has a wrong offset!");
static_assert(offsetof(FBoolToStringDataflowNode, String) == 0x0000F0, "Member 'FBoolToStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetBoolOverrideFromAssetDataflowNode
// 0x0008 (0x0110 - 0x0108)
struct FGetBoolOverrideFromAssetDataflowNode final : public FDataflowOverrideNode
{
public:
	bool                                          Bool;                                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BoolDefault;                                       // 0x0109(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1F[0x6];                                     // 0x010A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetBoolOverrideFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetBoolOverrideFromAssetDataflowNode");
static_assert(sizeof(FGetBoolOverrideFromAssetDataflowNode) == 0x000110, "Wrong size on FGetBoolOverrideFromAssetDataflowNode");
static_assert(offsetof(FGetBoolOverrideFromAssetDataflowNode, Bool) == 0x000108, "Member 'FGetBoolOverrideFromAssetDataflowNode::Bool' has a wrong offset!");
static_assert(offsetof(FGetBoolOverrideFromAssetDataflowNode, BoolDefault) == 0x000109, "Member 'FGetBoolOverrideFromAssetDataflowNode::BoolDefault' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToFloatDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FIntToFloatDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToFloatDataflowNode) == 0x000008, "Wrong alignment on FIntToFloatDataflowNode");
static_assert(sizeof(FIntToFloatDataflowNode) == 0x0000F0, "Wrong size on FIntToFloatDataflowNode");
static_assert(offsetof(FIntToFloatDataflowNode, Int) == 0x0000E8, "Member 'FIntToFloatDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToFloatDataflowNode, Float) == 0x0000EC, "Member 'FIntToFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToDoubleDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FIntToDoubleDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C20[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Double;                                            // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntToDoubleDataflowNode) == 0x000008, "Wrong alignment on FIntToDoubleDataflowNode");
static_assert(sizeof(FIntToDoubleDataflowNode) == 0x0000F8, "Wrong size on FIntToDoubleDataflowNode");
static_assert(offsetof(FIntToDoubleDataflowNode, Int) == 0x0000E8, "Member 'FIntToDoubleDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToDoubleDataflowNode, Double) == 0x0000F0, "Member 'FIntToDoubleDataflowNode::Double' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SelectionToVertexListDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FSelectionToVertexListDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	TArray<int32>                                 VertexList;                                        // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectionToVertexListDataflowNode) == 0x000008, "Wrong alignment on FSelectionToVertexListDataflowNode");
static_assert(sizeof(FSelectionToVertexListDataflowNode) == 0x000118, "Wrong size on FSelectionToVertexListDataflowNode");
static_assert(offsetof(FSelectionToVertexListDataflowNode, VertexSelection) == 0x0000E8, "Member 'FSelectionToVertexListDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FSelectionToVertexListDataflowNode, VertexList) == 0x000108, "Member 'FSelectionToVertexListDataflowNode::VertexList' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToDoubleDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FFloatToDoubleDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C21[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        Double;                                            // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloatToDoubleDataflowNode) == 0x000008, "Wrong alignment on FFloatToDoubleDataflowNode");
static_assert(sizeof(FFloatToDoubleDataflowNode) == 0x0000F8, "Wrong size on FFloatToDoubleDataflowNode");
static_assert(offsetof(FFloatToDoubleDataflowNode, Float) == 0x0000E8, "Member 'FFloatToDoubleDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToDoubleDataflowNode, Double) == 0x0000F0, "Member 'FFloatToDoubleDataflowNode::Double' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloatToIntDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FFloatToIntDataflowNode final : public FDataflowNode
{
public:
	EFloatToIntFunctionEnum                       Function;                                          // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C22[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Float;                                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C23[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatToIntDataflowNode) == 0x000008, "Wrong alignment on FFloatToIntDataflowNode");
static_assert(sizeof(FFloatToIntDataflowNode) == 0x0000F8, "Wrong size on FFloatToIntDataflowNode");
static_assert(offsetof(FFloatToIntDataflowNode, Function) == 0x0000E8, "Member 'FFloatToIntDataflowNode::Function' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Float) == 0x0000EC, "Member 'FFloatToIntDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloatToIntDataflowNode, Int) == 0x0000F0, "Member 'FFloatToIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionSetPivotDataflowNode
// 0x0118 (0x0200 - 0x00E8)
struct FCollectionSetPivotDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2C24[0x8];                                     // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x01A0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionSetPivotDataflowNode) == 0x000010, "Wrong alignment on FCollectionSetPivotDataflowNode");
static_assert(sizeof(FCollectionSetPivotDataflowNode) == 0x000200, "Wrong size on FCollectionSetPivotDataflowNode");
static_assert(offsetof(FCollectionSetPivotDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionSetPivotDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionSetPivotDataflowNode, Transform) == 0x0001A0, "Member 'FCollectionSetPivotDataflowNode::Transform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IntToBoolDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FIntToBoolDataflowNode final : public FDataflowNode
{
public:
	int32                                         Int;                                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bool;                                              // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C25[0x3];                                     // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntToBoolDataflowNode) == 0x000008, "Wrong alignment on FIntToBoolDataflowNode");
static_assert(sizeof(FIntToBoolDataflowNode) == 0x0000F0, "Wrong size on FIntToBoolDataflowNode");
static_assert(offsetof(FIntToBoolDataflowNode, Int) == 0x0000E8, "Member 'FIntToBoolDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FIntToBoolDataflowNode, Bool) == 0x0000EC, "Member 'FIntToBoolDataflowNode::Bool' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoolToIntDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FBoolToIntDataflowNode final : public FDataflowNode
{
public:
	bool                                          Bool;                                              // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C26[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Int;                                               // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoolToIntDataflowNode) == 0x000008, "Wrong alignment on FBoolToIntDataflowNode");
static_assert(sizeof(FBoolToIntDataflowNode) == 0x0000F0, "Wrong size on FBoolToIntDataflowNode");
static_assert(offsetof(FBoolToIntDataflowNode, Bool) == 0x0000E8, "Member 'FBoolToIntDataflowNode::Bool' has a wrong offset!");
static_assert(offsetof(FBoolToIntDataflowNode, Int) == 0x0000EC, "Member 'FBoolToIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetFloatOverrideFromAssetDataflowNode
// 0x0008 (0x0110 - 0x0108)
struct FGetFloatOverrideFromAssetDataflowNode final : public FDataflowOverrideNode
{
public:
	float                                         Float;                                             // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatDefault;                                      // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetFloatOverrideFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetFloatOverrideFromAssetDataflowNode");
static_assert(sizeof(FGetFloatOverrideFromAssetDataflowNode) == 0x000110, "Wrong size on FGetFloatOverrideFromAssetDataflowNode");
static_assert(offsetof(FGetFloatOverrideFromAssetDataflowNode, Float) == 0x000108, "Member 'FGetFloatOverrideFromAssetDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FGetFloatOverrideFromAssetDataflowNode, FloatDefault) == 0x00010C, "Member 'FGetFloatOverrideFromAssetDataflowNode::FloatDefault' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ConvexHullToMeshDataflowNode
// 0x00D8 (0x01C0 - 0x00E8)
struct FConvexHullToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            OptionalSelectionFilter;                           // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConvexHullToMeshDataflowNode) == 0x000008, "Wrong alignment on FConvexHullToMeshDataflowNode");
static_assert(sizeof(FConvexHullToMeshDataflowNode) == 0x0001C0, "Wrong size on FConvexHullToMeshDataflowNode");
static_assert(offsetof(FConvexHullToMeshDataflowNode, Collection) == 0x0000E8, "Member 'FConvexHullToMeshDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FConvexHullToMeshDataflowNode, OptionalSelectionFilter) == 0x000198, "Member 'FConvexHullToMeshDataflowNode::OptionalSelectionFilter' has a wrong offset!");
static_assert(offsetof(FConvexHullToMeshDataflowNode, Mesh) == 0x0001B8, "Member 'FConvexHullToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SphereCoveringToMeshDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FSphereCoveringToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowSphereCovering                SphereCovering;                                    // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         VerticesAlongEachSide;                             // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C27[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x0110(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSphereCoveringToMeshDataflowNode) == 0x000008, "Wrong alignment on FSphereCoveringToMeshDataflowNode");
static_assert(sizeof(FSphereCoveringToMeshDataflowNode) == 0x000118, "Wrong size on FSphereCoveringToMeshDataflowNode");
static_assert(offsetof(FSphereCoveringToMeshDataflowNode, SphereCovering) == 0x0000E8, "Member 'FSphereCoveringToMeshDataflowNode::SphereCovering' has a wrong offset!");
static_assert(offsetof(FSphereCoveringToMeshDataflowNode, VerticesAlongEachSide) == 0x000108, "Member 'FSphereCoveringToMeshDataflowNode::VerticesAlongEachSide' has a wrong offset!");
static_assert(offsetof(FSphereCoveringToMeshDataflowNode, Mesh) == 0x000110, "Member 'FSphereCoveringToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionRootDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionRootDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionRootDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionRootDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionRootDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionRootDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionRootDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionRootDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRootDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionTransformSelectionRootDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshToOBJStringDebugDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FMeshToOBJStringDebugDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertFaces;                                      // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C28[0x7];                                     // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StringOBJ;                                         // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshToOBJStringDebugDataflowNode) == 0x000008, "Wrong alignment on FMeshToOBJStringDebugDataflowNode");
static_assert(sizeof(FMeshToOBJStringDebugDataflowNode) == 0x000108, "Wrong size on FMeshToOBJStringDebugDataflowNode");
static_assert(offsetof(FMeshToOBJStringDebugDataflowNode, Mesh) == 0x0000E8, "Member 'FMeshToOBJStringDebugDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshToOBJStringDebugDataflowNode, bInvertFaces) == 0x0000F0, "Member 'FMeshToOBJStringDebugDataflowNode::bInvertFaces' has a wrong offset!");
static_assert(offsetof(FMeshToOBJStringDebugDataflowNode, StringOBJ) == 0x0000F8, "Member 'FMeshToOBJStringDebugDataflowNode::StringOBJ' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.WriteStringToFile
// 0x0020 (0x0108 - 0x00E8)
struct FWriteStringToFile final : public FDataflowNode
{
public:
	class FString                                 FilePath;                                          // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FileContents;                                      // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWriteStringToFile) == 0x000008, "Wrong alignment on FWriteStringToFile");
static_assert(sizeof(FWriteStringToFile) == 0x000108, "Wrong size on FWriteStringToFile");
static_assert(offsetof(FWriteStringToFile, FilePath) == 0x0000E8, "Member 'FWriteStringToFile::FilePath' has a wrong offset!");
static_assert(offsetof(FWriteStringToFile, FileContents) == 0x0000F8, "Member 'FWriteStringToFile::FileContents' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionAllDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionAllDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionAllDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionAllDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionAllDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionAllDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionAllDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionAllDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionAllDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionTransformSelectionAllDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PruneInCollectionDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FPruneInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPruneInCollectionDataflowNode) == 0x000008, "Wrong alignment on FPruneInCollectionDataflowNode");
static_assert(sizeof(FPruneInCollectionDataflowNode) == 0x0001B8, "Wrong size on FPruneInCollectionDataflowNode");
static_assert(offsetof(FPruneInCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FPruneInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FPruneInCollectionDataflowNode, TransformSelection) == 0x000198, "Member 'FPruneInCollectionDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVisibilityInCollectionDataflowNode
// 0x00F8 (0x01E0 - 0x00E8)
struct FSetVisibilityInCollectionDataflowNode final : public FDataflowNode
{
public:
	EVisibiltyOptionsEnum                         Visibility;                                        // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C29[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01C0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetVisibilityInCollectionDataflowNode) == 0x000008, "Wrong alignment on FSetVisibilityInCollectionDataflowNode");
static_assert(sizeof(FSetVisibilityInCollectionDataflowNode) == 0x0001E0, "Wrong size on FSetVisibilityInCollectionDataflowNode");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, Visibility) == 0x0000E8, "Member 'FSetVisibilityInCollectionDataflowNode::Visibility' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, Collection) == 0x0000F0, "Member 'FSetVisibilityInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, TransformSelection) == 0x0001A0, "Member 'FSetVisibilityInCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FSetVisibilityInCollectionDataflowNode, FaceSelection) == 0x0001C0, "Member 'FSetVisibilityInCollectionDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MultiplyTransformDataflowNode
// 0x0128 (0x0210 - 0x00E8)
struct FMultiplyTransformDataflowNode final : public FDataflowNode
{
public:
	uint8                                         Pad_2C2A[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InLeftTransform;                                   // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             InRightTransform;                                  // 0x0150(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x01B0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiplyTransformDataflowNode) == 0x000010, "Wrong alignment on FMultiplyTransformDataflowNode");
static_assert(sizeof(FMultiplyTransformDataflowNode) == 0x000210, "Wrong size on FMultiplyTransformDataflowNode");
static_assert(offsetof(FMultiplyTransformDataflowNode, InLeftTransform) == 0x0000F0, "Member 'FMultiplyTransformDataflowNode::InLeftTransform' has a wrong offset!");
static_assert(offsetof(FMultiplyTransformDataflowNode, InRightTransform) == 0x000150, "Member 'FMultiplyTransformDataflowNode::InRightTransform' has a wrong offset!");
static_assert(offsetof(FMultiplyTransformDataflowNode, OutTransform) == 0x0001B0, "Member 'FMultiplyTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MergeInCollectionDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FMergeInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMergeInCollectionDataflowNode) == 0x000008, "Wrong alignment on FMergeInCollectionDataflowNode");
static_assert(sizeof(FMergeInCollectionDataflowNode) == 0x0001B8, "Wrong size on FMergeInCollectionDataflowNode");
static_assert(offsetof(FMergeInCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FMergeInCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FMergeInCollectionDataflowNode, TransformSelection) == 0x000198, "Member 'FMergeInCollectionDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.UniformScatterPointsDataflowNode
// 0x0058 (0x0140 - 0x00E8)
struct FUniformScatterPointsDataflowNode final : public FDataflowNode
{
public:
	int32                                         MinNumberOfPoints;                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxNumberOfPoints;                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2B[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBox                                   BoundingBox;                                       // 0x00F8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUniformScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FUniformScatterPointsDataflowNode");
static_assert(sizeof(FUniformScatterPointsDataflowNode) == 0x000140, "Wrong size on FUniformScatterPointsDataflowNode");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MinNumberOfPoints) == 0x0000E8, "Member 'FUniformScatterPointsDataflowNode::MinNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, MaxNumberOfPoints) == 0x0000EC, "Member 'FUniformScatterPointsDataflowNode::MaxNumberOfPoints' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, RandomSeed) == 0x0000F0, "Member 'FUniformScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, BoundingBox) == 0x0000F8, "Member 'FUniformScatterPointsDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FUniformScatterPointsDataflowNode, Points) == 0x000130, "Member 'FUniformScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.NormalizeDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FNormalizeDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                VectorA;                                           // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2C[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNormalizeDataflowNode) == 0x000008, "Wrong alignment on FNormalizeDataflowNode");
static_assert(sizeof(FNormalizeDataflowNode) == 0x000120, "Wrong size on FNormalizeDataflowNode");
static_assert(offsetof(FNormalizeDataflowNode, VectorA) == 0x0000E8, "Member 'FNormalizeDataflowNode::VectorA' has a wrong offset!");
static_assert(offsetof(FNormalizeDataflowNode, Tolerance) == 0x000100, "Member 'FNormalizeDataflowNode::Tolerance' has a wrong offset!");
static_assert(offsetof(FNormalizeDataflowNode, ReturnValue) == 0x000108, "Member 'FNormalizeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RadialScatterPointsDataflowNode
// 0x0058 (0x0140 - 0x00E8)
struct FRadialScatterPointsDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Center;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AngularSteps;                                      // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RadialSteps;                                       // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleOffset;                                       // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Variability;                                       // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRadialScatterPointsDataflowNode) == 0x000008, "Wrong alignment on FRadialScatterPointsDataflowNode");
static_assert(sizeof(FRadialScatterPointsDataflowNode) == 0x000140, "Wrong size on FRadialScatterPointsDataflowNode");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Center) == 0x0000E8, "Member 'FRadialScatterPointsDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Normal) == 0x000100, "Member 'FRadialScatterPointsDataflowNode::Normal' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Radius) == 0x000118, "Member 'FRadialScatterPointsDataflowNode::Radius' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngularSteps) == 0x00011C, "Member 'FRadialScatterPointsDataflowNode::AngularSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RadialSteps) == 0x000120, "Member 'FRadialScatterPointsDataflowNode::RadialSteps' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, AngleOffset) == 0x000124, "Member 'FRadialScatterPointsDataflowNode::AngleOffset' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Variability) == 0x000128, "Member 'FRadialScatterPointsDataflowNode::Variability' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, RandomSeed) == 0x00012C, "Member 'FRadialScatterPointsDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRadialScatterPointsDataflowNode, Points) == 0x000130, "Member 'FRadialScatterPointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.VoronoiFractureDataflowNode
// 0x0110 (0x01F8 - 0x00E8)
struct FVoronoiFractureDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToFracture;                                  // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GroupFracture;                                     // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2D[0x3];                                     // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Grout;                                             // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2E[0x3];                                     // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVoronoiFractureDataflowNode) == 0x000008, "Wrong alignment on FVoronoiFractureDataflowNode");
static_assert(sizeof(FVoronoiFractureDataflowNode) == 0x0001F8, "Wrong size on FVoronoiFractureDataflowNode");
static_assert(offsetof(FVoronoiFractureDataflowNode, Collection) == 0x0000E8, "Member 'FVoronoiFractureDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Points) == 0x000198, "Member 'FVoronoiFractureDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, TransformSelection) == 0x0001A8, "Member 'FVoronoiFractureDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, RandomSeed) == 0x0001C8, "Member 'FVoronoiFractureDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, ChanceToFracture) == 0x0001CC, "Member 'FVoronoiFractureDataflowNode::ChanceToFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, GroupFracture) == 0x0001D0, "Member 'FVoronoiFractureDataflowNode::GroupFracture' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Grout) == 0x0001D4, "Member 'FVoronoiFractureDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Amplitude) == 0x0001D8, "Member 'FVoronoiFractureDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Frequency) == 0x0001DC, "Member 'FVoronoiFractureDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Persistence) == 0x0001E0, "Member 'FVoronoiFractureDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, Lacunarity) == 0x0001E4, "Member 'FVoronoiFractureDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, OctaveNumber) == 0x0001E8, "Member 'FVoronoiFractureDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, PointSpacing) == 0x0001EC, "Member 'FVoronoiFractureDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, AddSamplesForCollision) == 0x0001F0, "Member 'FVoronoiFractureDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FVoronoiFractureDataflowNode, CollisionSampleSpacing) == 0x0001F4, "Member 'FVoronoiFractureDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionTargetLevelDataflowNode
// 0x00D8 (0x01C0 - 0x00E8)
struct FCollectionTransformSelectionTargetLevelDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	int32                                         TargetLevel;                                       // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipEmbedded;                                     // 0x019C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C2F[0x3];                                     // 0x019D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A0(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionTargetLevelDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionTargetLevelDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionTargetLevelDataflowNode) == 0x0001C0, "Wrong size on FCollectionTransformSelectionTargetLevelDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionTargetLevelDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionTargetLevelDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionTargetLevelDataflowNode, TargetLevel) == 0x000198, "Member 'FCollectionTransformSelectionTargetLevelDataflowNode::TargetLevel' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionTargetLevelDataflowNode, bSkipEmbedded) == 0x00019C, "Member 'FCollectionTransformSelectionTargetLevelDataflowNode::bSkipEmbedded' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionTargetLevelDataflowNode, TransformSelection) == 0x0001A0, "Member 'FCollectionTransformSelectionTargetLevelDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PlaneCutterDataflowNode
// 0x0138 (0x0220 - 0x00E8)
struct FPlaneCutterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x0198(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01D0(0x0020)(NativeAccessSpecifierPublic)
	int32                                         NumPlanes;                                         // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomSeed;                                        // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Grout;                                             // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frequency;                                         // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Persistence;                                       // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lacunarity;                                        // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OctaveNumber;                                      // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PointSpacing;                                      // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddSamplesForCollision;                            // 0x0214(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C30[0x3];                                     // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionSampleSpacing;                            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C31[0x4];                                     // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaneCutterDataflowNode) == 0x000008, "Wrong alignment on FPlaneCutterDataflowNode");
static_assert(sizeof(FPlaneCutterDataflowNode) == 0x000220, "Wrong size on FPlaneCutterDataflowNode");
static_assert(offsetof(FPlaneCutterDataflowNode, Collection) == 0x0000E8, "Member 'FPlaneCutterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, BoundingBox) == 0x000198, "Member 'FPlaneCutterDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, TransformSelection) == 0x0001D0, "Member 'FPlaneCutterDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, NumPlanes) == 0x0001F0, "Member 'FPlaneCutterDataflowNode::NumPlanes' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, RandomSeed) == 0x0001F4, "Member 'FPlaneCutterDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Grout) == 0x0001F8, "Member 'FPlaneCutterDataflowNode::Grout' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Amplitude) == 0x0001FC, "Member 'FPlaneCutterDataflowNode::Amplitude' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Frequency) == 0x000200, "Member 'FPlaneCutterDataflowNode::Frequency' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Persistence) == 0x000204, "Member 'FPlaneCutterDataflowNode::Persistence' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, Lacunarity) == 0x000208, "Member 'FPlaneCutterDataflowNode::Lacunarity' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, OctaveNumber) == 0x00020C, "Member 'FPlaneCutterDataflowNode::OctaveNumber' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, PointSpacing) == 0x000210, "Member 'FPlaneCutterDataflowNode::PointSpacing' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, AddSamplesForCollision) == 0x000214, "Member 'FPlaneCutterDataflowNode::AddSamplesForCollision' has a wrong offset!");
static_assert(offsetof(FPlaneCutterDataflowNode, CollisionSampleSpacing) == 0x000218, "Member 'FPlaneCutterDataflowNode::CollisionSampleSpacing' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExplodedViewDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FExplodedViewDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C32[0x4];                                     // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x01A0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExplodedViewDataflowNode) == 0x000008, "Wrong alignment on FExplodedViewDataflowNode");
static_assert(sizeof(FExplodedViewDataflowNode) == 0x0001B8, "Wrong size on FExplodedViewDataflowNode");
static_assert(offsetof(FExplodedViewDataflowNode, Collection) == 0x0000E8, "Member 'FExplodedViewDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, UniformScale) == 0x000198, "Member 'FExplodedViewDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FExplodedViewDataflowNode, Scale) == 0x0001A0, "Member 'FExplodedViewDataflowNode::Scale' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FRandomFloatDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C33[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C34[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatDataflowNode");
static_assert(sizeof(FRandomFloatDataflowNode) == 0x0000F8, "Wrong size on FRandomFloatDataflowNode");
static_assert(offsetof(FRandomFloatDataflowNode, bDeterministic) == 0x0000E8, "Member 'FRandomFloatDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, RandomSeed) == 0x0000EC, "Member 'FRandomFloatDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatDataflowNode, ReturnValue) == 0x0000F0, "Member 'FRandomFloatDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralStringDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FMakeLiteralStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 Value;                                             // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralStringDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralStringDataflowNode");
static_assert(sizeof(FMakeLiteralStringDataflowNode) == 0x000108, "Wrong size on FMakeLiteralStringDataflowNode");
static_assert(offsetof(FMakeLiteralStringDataflowNode, Value) == 0x0000E8, "Member 'FMakeLiteralStringDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralStringDataflowNode, String) == 0x0000F8, "Member 'FMakeLiteralStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakePointsDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FMakePointsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Point;                                             // 0x00E8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        Points;                                            // 0x00F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakePointsDataflowNode) == 0x000008, "Wrong alignment on FMakePointsDataflowNode");
static_assert(sizeof(FMakePointsDataflowNode) == 0x000108, "Wrong size on FMakePointsDataflowNode");
static_assert(offsetof(FMakePointsDataflowNode, Point) == 0x0000E8, "Member 'FMakePointsDataflowNode::Point' has a wrong offset!");
static_assert(offsetof(FMakePointsDataflowNode, Points) == 0x0000F8, "Member 'FMakePointsDataflowNode::Points' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DotProductDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FDotProductDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                VectorA;                                           // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorB;                                           // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C35[0x4];                                     // 0x011C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDotProductDataflowNode) == 0x000008, "Wrong alignment on FDotProductDataflowNode");
static_assert(sizeof(FDotProductDataflowNode) == 0x000120, "Wrong size on FDotProductDataflowNode");
static_assert(offsetof(FDotProductDataflowNode, VectorA) == 0x0000E8, "Member 'FDotProductDataflowNode::VectorA' has a wrong offset!");
static_assert(offsetof(FDotProductDataflowNode, VectorB) == 0x000100, "Member 'FDotProductDataflowNode::VectorB' has a wrong offset!");
static_assert(offsetof(FDotProductDataflowNode, ReturnValue) == 0x000118, "Member 'FDotProductDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeBoxDataflowNode
// 0x00A0 (0x0188 - 0x00E8)
struct FMakeBoxDataflowNode final : public FDataflowNode
{
public:
	EMakeBoxDataTypeEnum                          DataType;                                          // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C36[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Min;                                               // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0108(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0120(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Size;                                              // 0x0138(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0150(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeBoxDataflowNode) == 0x000008, "Wrong alignment on FMakeBoxDataflowNode");
static_assert(sizeof(FMakeBoxDataflowNode) == 0x000188, "Wrong size on FMakeBoxDataflowNode");
static_assert(offsetof(FMakeBoxDataflowNode, DataType) == 0x0000E8, "Member 'FMakeBoxDataflowNode::DataType' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Min) == 0x0000F0, "Member 'FMakeBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Max) == 0x000108, "Member 'FMakeBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Center) == 0x000120, "Member 'FMakeBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Size) == 0x000138, "Member 'FMakeBoxDataflowNode::Size' has a wrong offset!");
static_assert(offsetof(FMakeBoxDataflowNode, Box) == 0x000150, "Member 'FMakeBoxDataflowNode::Box' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeSphereDataflowNode
// 0x0040 (0x0128 - 0x00E8)
struct FMakeSphereDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Center;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C37[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSphere                                Sphere;                                            // 0x0108(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeSphereDataflowNode) == 0x000008, "Wrong alignment on FMakeSphereDataflowNode");
static_assert(sizeof(FMakeSphereDataflowNode) == 0x000128, "Wrong size on FMakeSphereDataflowNode");
static_assert(offsetof(FMakeSphereDataflowNode, Center) == 0x0000E8, "Member 'FMakeSphereDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FMakeSphereDataflowNode, Radius) == 0x000100, "Member 'FMakeSphereDataflowNode::Radius' has a wrong offset!");
static_assert(offsetof(FMakeSphereDataflowNode, Sphere) == 0x000108, "Member 'FMakeSphereDataflowNode::Sphere' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionSiblingsDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionSiblingsDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionSiblingsDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionSiblingsDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionSiblingsDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionSiblingsDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionSiblingsDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionSiblingsDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSiblingsDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionSiblingsDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralFloatDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FMakeLiteralFloatDataflowNode final : public FDataflowNode
{
public:
	float                                         Value;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Float;                                             // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralFloatDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralFloatDataflowNode");
static_assert(sizeof(FMakeLiteralFloatDataflowNode) == 0x0000F0, "Wrong size on FMakeLiteralFloatDataflowNode");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Value) == 0x0000E8, "Member 'FMakeLiteralFloatDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralFloatDataflowNode, Float) == 0x0000EC, "Member 'FMakeLiteralFloatDataflowNode::Float' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralIntDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FMakeLiteralIntDataflowNode final : public FDataflowNode
{
public:
	int32                                         Value;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Int;                                               // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralIntDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralIntDataflowNode");
static_assert(sizeof(FMakeLiteralIntDataflowNode) == 0x0000F0, "Wrong size on FMakeLiteralIntDataflowNode");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Value) == 0x0000E8, "Member 'FMakeLiteralIntDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralIntDataflowNode, Int) == 0x0000EC, "Member 'FMakeLiteralIntDataflowNode::Int' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInSphereDataflowNode
// 0x0168 (0x0250 - 0x00E8)
struct FCollectionTransformSelectionInSphereDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FSphere                                Sphere;                                            // 0x0198(0x0020)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C38[0x8];                                     // 0x01B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x01C0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectSubjectTypeEnum                        Type;                                              // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllVerticesMustContainedInSphere;                 // 0x0221(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C39[0x6];                                     // 0x0222(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0228(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3A[0x8];                                     // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionInSphereDataflowNode) == 0x000010, "Wrong alignment on FCollectionTransformSelectionInSphereDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInSphereDataflowNode) == 0x000250, "Wrong size on FCollectionTransformSelectionInSphereDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Sphere) == 0x000198, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Sphere' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Transform) == 0x0001C0, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, Type) == 0x000220, "Member 'FCollectionTransformSelectionInSphereDataflowNode::Type' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, bAllVerticesMustContainedInSphere) == 0x000221, "Member 'FCollectionTransformSelectionInSphereDataflowNode::bAllVerticesMustContainedInSphere' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInSphereDataflowNode, TransformSelection) == 0x000228, "Member 'FCollectionTransformSelectionInSphereDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralBoolDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FMakeLiteralBoolDataflowNode final : public FDataflowNode
{
public:
	bool                                          Value;                                             // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Bool;                                              // 0x00E9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3B[0x6];                                     // 0x00EA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMakeLiteralBoolDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralBoolDataflowNode");
static_assert(sizeof(FMakeLiteralBoolDataflowNode) == 0x0000F0, "Wrong size on FMakeLiteralBoolDataflowNode");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Value) == 0x0000E8, "Member 'FMakeLiteralBoolDataflowNode::Value' has a wrong offset!");
static_assert(offsetof(FMakeLiteralBoolDataflowNode, Bool) == 0x0000E9, "Member 'FMakeLiteralBoolDataflowNode::Bool' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeLiteralVectorDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FMakeLiteralVectorDataflowNode final : public FDataflowNode
{
public:
	float                                         X;                                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3C[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Vector;                                            // 0x00F8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeLiteralVectorDataflowNode) == 0x000008, "Wrong alignment on FMakeLiteralVectorDataflowNode");
static_assert(sizeof(FMakeLiteralVectorDataflowNode) == 0x000110, "Wrong size on FMakeLiteralVectorDataflowNode");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, X) == 0x0000E8, "Member 'FMakeLiteralVectorDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Y) == 0x0000EC, "Member 'FMakeLiteralVectorDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Z) == 0x0000F0, "Member 'FMakeLiteralVectorDataflowNode::Z' has a wrong offset!");
static_assert(offsetof(FMakeLiteralVectorDataflowNode, Vector) == 0x0000F8, "Member 'FMakeLiteralVectorDataflowNode::Vector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionLeafDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionLeafDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionLeafDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionLeafDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionLeafDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionLeafDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionLeafDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionLeafDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionLeafDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionTransformSelectionLeafDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeTransformDataflowNode
// 0x00A8 (0x0190 - 0x00E8)
struct FMakeTransformDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                InTranslation;                                     // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InRotation;                                        // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InScale;                                           // 0x0118(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0130(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeTransformDataflowNode) == 0x000010, "Wrong alignment on FMakeTransformDataflowNode");
static_assert(sizeof(FMakeTransformDataflowNode) == 0x000190, "Wrong size on FMakeTransformDataflowNode");
static_assert(offsetof(FMakeTransformDataflowNode, InTranslation) == 0x0000E8, "Member 'FMakeTransformDataflowNode::InTranslation' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, InRotation) == 0x000100, "Member 'FMakeTransformDataflowNode::InRotation' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, InScale) == 0x000118, "Member 'FMakeTransformDataflowNode::InScale' has a wrong offset!");
static_assert(offsetof(FMakeTransformDataflowNode, OutTransform) == 0x000130, "Member 'FMakeTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MakeQuaternionDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FMakeQuaternionDataflowNode final : public FDataflowNode
{
public:
	float                                         X;                                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         W;                                                 // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3D[0x8];                                     // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Quaternion;                                        // 0x0100(0x0020)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMakeQuaternionDataflowNode) == 0x000010, "Wrong alignment on FMakeQuaternionDataflowNode");
static_assert(sizeof(FMakeQuaternionDataflowNode) == 0x000120, "Wrong size on FMakeQuaternionDataflowNode");
static_assert(offsetof(FMakeQuaternionDataflowNode, X) == 0x0000E8, "Member 'FMakeQuaternionDataflowNode::X' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Y) == 0x0000EC, "Member 'FMakeQuaternionDataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Z) == 0x0000F0, "Member 'FMakeQuaternionDataflowNode::Z' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, W) == 0x0000F4, "Member 'FMakeQuaternionDataflowNode::W' has a wrong offset!");
static_assert(offsetof(FMakeQuaternionDataflowNode, Quaternion) == 0x000100, "Member 'FMakeQuaternionDataflowNode::Quaternion' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByPercentageDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FCollectionTransformSelectionByPercentageDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Percentage;                                        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeterministic;                                    // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3E[0x3];                                     // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C3F[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionByPercentageDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByPercentageDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByPercentageDataflowNode) == 0x000118, "Wrong size on FCollectionTransformSelectionByPercentageDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, Percentage) == 0x000108, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::Percentage' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, bDeterministic) == 0x00010C, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByPercentageDataflowNode, RandomSeed) == 0x000110, "Member 'FCollectionTransformSelectionByPercentageDataflowNode::RandomSeed' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AddDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FAddDataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C40[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAddDataflowNode) == 0x000008, "Wrong alignment on FAddDataflowNode");
static_assert(sizeof(FAddDataflowNode) == 0x0000F8, "Wrong size on FAddDataflowNode");
static_assert(offsetof(FAddDataflowNode, FloatA) == 0x0000E8, "Member 'FAddDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FAddDataflowNode, FloatB) == 0x0000EC, "Member 'FAddDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FAddDataflowNode, ReturnValue) == 0x0000F0, "Member 'FAddDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SubtractDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FSubtractDataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C41[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubtractDataflowNode) == 0x000008, "Wrong alignment on FSubtractDataflowNode");
static_assert(sizeof(FSubtractDataflowNode) == 0x0000F8, "Wrong size on FSubtractDataflowNode");
static_assert(offsetof(FSubtractDataflowNode, FloatA) == 0x0000E8, "Member 'FSubtractDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FSubtractDataflowNode, FloatB) == 0x0000EC, "Member 'FSubtractDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FSubtractDataflowNode, ReturnValue) == 0x0000F0, "Member 'FSubtractDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByVolumeDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionByVolumeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	float                                         VolumeMin;                                         // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMax;                                         // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C42[0x6];                                     // 0x01A2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByVolumeDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByVolumeDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByVolumeDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionByVolumeDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, VolumeMin) == 0x000198, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::VolumeMin' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, VolumeMax) == 0x00019C, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::VolumeMax' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, RangeSetting) == 0x0001A0, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, bInclusive) == 0x0001A1, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByVolumeDataflowNode, TransformSelection) == 0x0001A8, "Member 'FCollectionTransformSelectionByVolumeDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MultiplyDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMultiplyDataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C43[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMultiplyDataflowNode) == 0x000008, "Wrong alignment on FMultiplyDataflowNode");
static_assert(sizeof(FMultiplyDataflowNode) == 0x0000F8, "Wrong size on FMultiplyDataflowNode");
static_assert(offsetof(FMultiplyDataflowNode, FloatA) == 0x0000E8, "Member 'FMultiplyDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FMultiplyDataflowNode, FloatB) == 0x0000EC, "Member 'FMultiplyDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FMultiplyDataflowNode, ReturnValue) == 0x0000F0, "Member 'FMultiplyDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SafeDivideDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FSafeDivideDataflowNode : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C44[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSafeDivideDataflowNode) == 0x000008, "Wrong alignment on FSafeDivideDataflowNode");
static_assert(sizeof(FSafeDivideDataflowNode) == 0x0000F8, "Wrong size on FSafeDivideDataflowNode");
static_assert(offsetof(FSafeDivideDataflowNode, FloatA) == 0x0000E8, "Member 'FSafeDivideDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FSafeDivideDataflowNode, FloatB) == 0x0000EC, "Member 'FSafeDivideDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FSafeDivideDataflowNode, ReturnValue) == 0x0000F0, "Member 'FSafeDivideDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionSetOperationDataflowNode
// 0x0068 (0x0150 - 0x00E8)
struct FCollectionVertexSelectionSetOperationDataflowNode final : public FDataflowNode
{
public:
	ESetOperationEnum                             Operation;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C45[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowVertexSelection               VertexSelectionA;                                  // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelectionB;                                  // 0x0110(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x0130(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionVertexSelectionSetOperationDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionSetOperationDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionSetOperationDataflowNode) == 0x000150, "Wrong size on FCollectionVertexSelectionSetOperationDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, Operation) == 0x0000E8, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelectionA) == 0x0000F0, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelectionA' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelectionB) == 0x000110, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelectionB' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionSetOperationDataflowNode, VertexSelection) == 0x000130, "Member 'FCollectionVertexSelectionSetOperationDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DivideDataflowNode
// 0x0000 (0x00F8 - 0x00F8)
struct FDivideDataflowNode final : public FSafeDivideDataflowNode
{
};
static_assert(alignof(FDivideDataflowNode) == 0x000008, "Wrong alignment on FDivideDataflowNode");
static_assert(sizeof(FDivideDataflowNode) == 0x0000F8, "Wrong size on FDivideDataflowNode");

// ScriptStruct GeometryCollectionNodes.DivisionDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FDivisionDataflowNode final : public FDataflowNode
{
public:
	float                                         Dividend;                                          // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Divisor;                                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Remainder;                                         // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDivisionDataflowNode) == 0x000008, "Wrong alignment on FDivisionDataflowNode");
static_assert(sizeof(FDivisionDataflowNode) == 0x0000F8, "Wrong size on FDivisionDataflowNode");
static_assert(offsetof(FDivisionDataflowNode, Dividend) == 0x0000E8, "Member 'FDivisionDataflowNode::Dividend' has a wrong offset!");
static_assert(offsetof(FDivisionDataflowNode, Divisor) == 0x0000EC, "Member 'FDivisionDataflowNode::Divisor' has a wrong offset!");
static_assert(offsetof(FDivisionDataflowNode, Remainder) == 0x0000F0, "Member 'FDivisionDataflowNode::Remainder' has a wrong offset!");
static_assert(offsetof(FDivisionDataflowNode, ReturnValue) == 0x0000F4, "Member 'FDivisionDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByIntAttrDataflowNode
// 0x0100 (0x01E8 - 0x00E8)
struct FCollectionTransformSelectionByIntAttrDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x0198(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min;                                               // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C46[0x6];                                     // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01C8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByIntAttrDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByIntAttrDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByIntAttrDataflowNode) == 0x0001E8, "Wrong size on FCollectionTransformSelectionByIntAttrDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, GroupName) == 0x000198, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, AttrName) == 0x0001A8, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Min) == 0x0001B8, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, Max) == 0x0001BC, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, RangeSetting) == 0x0001C0, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, bInclusive) == 0x0001C1, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByIntAttrDataflowNode, TransformSelection) == 0x0001C8, "Member 'FCollectionTransformSelectionByIntAttrDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SafeReciprocalDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FSafeReciprocalDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSafeReciprocalDataflowNode) == 0x000008, "Wrong alignment on FSafeReciprocalDataflowNode");
static_assert(sizeof(FSafeReciprocalDataflowNode) == 0x0000F0, "Wrong size on FSafeReciprocalDataflowNode");
static_assert(offsetof(FSafeReciprocalDataflowNode, Float) == 0x0000E8, "Member 'FSafeReciprocalDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FSafeReciprocalDataflowNode, ReturnValue) == 0x0000EC, "Member 'FSafeReciprocalDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SquareDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FSquareDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSquareDataflowNode) == 0x000008, "Wrong alignment on FSquareDataflowNode");
static_assert(sizeof(FSquareDataflowNode) == 0x0000F0, "Wrong size on FSquareDataflowNode");
static_assert(offsetof(FSquareDataflowNode, Float) == 0x0000E8, "Member 'FSquareDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FSquareDataflowNode, ReturnValue) == 0x0000EC, "Member 'FSquareDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SelectFloatArrayIndicesInRangeDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FSelectFloatArrayIndicesInRangeDataflowNode final : public FDataflowNode
{
public:
	TArray<float>                                 Values;                                            // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C47[0x6];                                     // 0x0102(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Indices;                                           // 0x0108(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectFloatArrayIndicesInRangeDataflowNode) == 0x000008, "Wrong alignment on FSelectFloatArrayIndicesInRangeDataflowNode");
static_assert(sizeof(FSelectFloatArrayIndicesInRangeDataflowNode) == 0x000118, "Wrong size on FSelectFloatArrayIndicesInRangeDataflowNode");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, Values) == 0x0000E8, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::Values' has a wrong offset!");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, Min) == 0x0000F8, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, Max) == 0x0000FC, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, RangeSetting) == 0x000100, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, bInclusive) == 0x000101, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FSelectFloatArrayIndicesInRangeDataflowNode, Indices) == 0x000108, "Member 'FSelectFloatArrayIndicesInRangeDataflowNode::Indices' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SquareRootDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FSquareRootDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSquareRootDataflowNode) == 0x000008, "Wrong alignment on FSquareRootDataflowNode");
static_assert(sizeof(FSquareRootDataflowNode) == 0x0000F0, "Wrong size on FSquareRootDataflowNode");
static_assert(offsetof(FSquareRootDataflowNode, Float) == 0x0000E8, "Member 'FSquareRootDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FSquareRootDataflowNode, ReturnValue) == 0x0000EC, "Member 'FSquareRootDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.InverseSqrtDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FInverseSqrtDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInverseSqrtDataflowNode) == 0x000008, "Wrong alignment on FInverseSqrtDataflowNode");
static_assert(sizeof(FInverseSqrtDataflowNode) == 0x0000F0, "Wrong size on FInverseSqrtDataflowNode");
static_assert(offsetof(FInverseSqrtDataflowNode, Float) == 0x0000E8, "Member 'FInverseSqrtDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FInverseSqrtDataflowNode, ReturnValue) == 0x0000EC, "Member 'FInverseSqrtDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionFaceSelectionInvertDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FCollectionFaceSelectionInvertDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionFaceSelectionInvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionFaceSelectionInvertDataflowNode");
static_assert(sizeof(FCollectionFaceSelectionInvertDataflowNode) == 0x000108, "Wrong size on FCollectionFaceSelectionInvertDataflowNode");
static_assert(offsetof(FCollectionFaceSelectionInvertDataflowNode, FaceSelection) == 0x0000E8, "Member 'FCollectionFaceSelectionInvertDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CubeDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FCubeDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCubeDataflowNode) == 0x000008, "Wrong alignment on FCubeDataflowNode");
static_assert(sizeof(FCubeDataflowNode) == 0x0000F0, "Wrong size on FCubeDataflowNode");
static_assert(offsetof(FCubeDataflowNode, Float) == 0x0000E8, "Member 'FCubeDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FCubeDataflowNode, ReturnValue) == 0x0000EC, "Member 'FCubeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.NegateDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FNegateDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNegateDataflowNode) == 0x000008, "Wrong alignment on FNegateDataflowNode");
static_assert(sizeof(FNegateDataflowNode) == 0x0000F0, "Wrong size on FNegateDataflowNode");
static_assert(offsetof(FNegateDataflowNode, Float) == 0x0000E8, "Member 'FNegateDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FNegateDataflowNode, ReturnValue) == 0x0000EC, "Member 'FNegateDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AbsDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FAbsDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAbsDataflowNode) == 0x000008, "Wrong alignment on FAbsDataflowNode");
static_assert(sizeof(FAbsDataflowNode) == 0x0000F0, "Wrong size on FAbsDataflowNode");
static_assert(offsetof(FAbsDataflowNode, Float) == 0x0000E8, "Member 'FAbsDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FAbsDataflowNode, ReturnValue) == 0x0000EC, "Member 'FAbsDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FloorDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FFloorDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFloorDataflowNode) == 0x000008, "Wrong alignment on FFloorDataflowNode");
static_assert(sizeof(FFloorDataflowNode) == 0x0000F0, "Wrong size on FFloorDataflowNode");
static_assert(offsetof(FFloorDataflowNode, Float) == 0x0000E8, "Member 'FFloorDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFloorDataflowNode, ReturnValue) == 0x0000EC, "Member 'FFloorDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CeilDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FCeilDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCeilDataflowNode) == 0x000008, "Wrong alignment on FCeilDataflowNode");
static_assert(sizeof(FCeilDataflowNode) == 0x0000F0, "Wrong size on FCeilDataflowNode");
static_assert(offsetof(FCeilDataflowNode, Float) == 0x0000E8, "Member 'FCeilDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FCeilDataflowNode, ReturnValue) == 0x0000EC, "Member 'FCeilDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RoundDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FRoundDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoundDataflowNode) == 0x000008, "Wrong alignment on FRoundDataflowNode");
static_assert(sizeof(FRoundDataflowNode) == 0x0000F0, "Wrong size on FRoundDataflowNode");
static_assert(offsetof(FRoundDataflowNode, Float) == 0x0000E8, "Member 'FRoundDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FRoundDataflowNode, ReturnValue) == 0x0000EC, "Member 'FRoundDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionFaceSelectionCustomDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionFaceSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 FaceIndicies;                                      // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionFaceSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionFaceSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionFaceSelectionCustomDataflowNode) == 0x0001C8, "Wrong size on FCollectionFaceSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionFaceSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, FaceIndicies) == 0x000198, "Member 'FCollectionFaceSelectionCustomDataflowNode::FaceIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionFaceSelectionCustomDataflowNode, FaceSelection) == 0x0001A8, "Member 'FCollectionFaceSelectionCustomDataflowNode::FaceSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TruncDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FTruncDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTruncDataflowNode) == 0x000008, "Wrong alignment on FTruncDataflowNode");
static_assert(sizeof(FTruncDataflowNode) == 0x0000F0, "Wrong size on FTruncDataflowNode");
static_assert(offsetof(FTruncDataflowNode, Float) == 0x0000E8, "Member 'FTruncDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FTruncDataflowNode, ReturnValue) == 0x0000EC, "Member 'FTruncDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FracDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FFracDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFracDataflowNode) == 0x000008, "Wrong alignment on FFracDataflowNode");
static_assert(sizeof(FFracDataflowNode) == 0x0000F0, "Wrong size on FFracDataflowNode");
static_assert(offsetof(FFracDataflowNode, Float) == 0x0000E8, "Member 'FFracDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFracDataflowNode, ReturnValue) == 0x0000EC, "Member 'FFracDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MinDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMinDataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C48[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinDataflowNode) == 0x000008, "Wrong alignment on FMinDataflowNode");
static_assert(sizeof(FMinDataflowNode) == 0x0000F8, "Wrong size on FMinDataflowNode");
static_assert(offsetof(FMinDataflowNode, FloatA) == 0x0000E8, "Member 'FMinDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FMinDataflowNode, FloatB) == 0x0000EC, "Member 'FMinDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FMinDataflowNode, ReturnValue) == 0x0000F0, "Member 'FMinDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MaxDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMaxDataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C49[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaxDataflowNode) == 0x000008, "Wrong alignment on FMaxDataflowNode");
static_assert(sizeof(FMaxDataflowNode) == 0x0000F8, "Wrong size on FMaxDataflowNode");
static_assert(offsetof(FMaxDataflowNode, FloatA) == 0x0000E8, "Member 'FMaxDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FMaxDataflowNode, FloatB) == 0x0000EC, "Member 'FMaxDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FMaxDataflowNode, ReturnValue) == 0x0000F0, "Member 'FMaxDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.Min3DataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMin3DataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatC;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMin3DataflowNode) == 0x000008, "Wrong alignment on FMin3DataflowNode");
static_assert(sizeof(FMin3DataflowNode) == 0x0000F8, "Wrong size on FMin3DataflowNode");
static_assert(offsetof(FMin3DataflowNode, FloatA) == 0x0000E8, "Member 'FMin3DataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FMin3DataflowNode, FloatB) == 0x0000EC, "Member 'FMin3DataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FMin3DataflowNode, FloatC) == 0x0000F0, "Member 'FMin3DataflowNode::FloatC' has a wrong offset!");
static_assert(offsetof(FMin3DataflowNode, ReturnValue) == 0x0000F4, "Member 'FMin3DataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.Max3DataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FMax3DataflowNode final : public FDataflowNode
{
public:
	float                                         FloatA;                                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatC;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMax3DataflowNode) == 0x000008, "Wrong alignment on FMax3DataflowNode");
static_assert(sizeof(FMax3DataflowNode) == 0x0000F8, "Wrong size on FMax3DataflowNode");
static_assert(offsetof(FMax3DataflowNode, FloatA) == 0x0000E8, "Member 'FMax3DataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FMax3DataflowNode, FloatB) == 0x0000EC, "Member 'FMax3DataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FMax3DataflowNode, FloatC) == 0x0000F0, "Member 'FMax3DataflowNode::FloatC' has a wrong offset!");
static_assert(offsetof(FMax3DataflowNode, ReturnValue) == 0x0000F4, "Member 'FMax3DataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SignDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FSignDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSignDataflowNode) == 0x000008, "Wrong alignment on FSignDataflowNode");
static_assert(sizeof(FSignDataflowNode) == 0x0000F0, "Wrong size on FSignDataflowNode");
static_assert(offsetof(FSignDataflowNode, Float) == 0x0000E8, "Member 'FSignDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FSignDataflowNode, ReturnValue) == 0x0000EC, "Member 'FSignDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ClampDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FClampDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FClampDataflowNode) == 0x000008, "Wrong alignment on FClampDataflowNode");
static_assert(sizeof(FClampDataflowNode) == 0x0000F8, "Wrong size on FClampDataflowNode");
static_assert(offsetof(FClampDataflowNode, Float) == 0x0000E8, "Member 'FClampDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FClampDataflowNode, Min) == 0x0000EC, "Member 'FClampDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FClampDataflowNode, Max) == 0x0000F0, "Member 'FClampDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FClampDataflowNode, ReturnValue) == 0x0000F4, "Member 'FClampDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.FitDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FFitDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldMin;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldMax;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMin;                                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMax;                                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFitDataflowNode) == 0x000008, "Wrong alignment on FFitDataflowNode");
static_assert(sizeof(FFitDataflowNode) == 0x000100, "Wrong size on FFitDataflowNode");
static_assert(offsetof(FFitDataflowNode, Float) == 0x0000E8, "Member 'FFitDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FFitDataflowNode, OldMin) == 0x0000EC, "Member 'FFitDataflowNode::OldMin' has a wrong offset!");
static_assert(offsetof(FFitDataflowNode, OldMax) == 0x0000F0, "Member 'FFitDataflowNode::OldMax' has a wrong offset!");
static_assert(offsetof(FFitDataflowNode, NewMin) == 0x0000F4, "Member 'FFitDataflowNode::NewMin' has a wrong offset!");
static_assert(offsetof(FFitDataflowNode, NewMax) == 0x0000F8, "Member 'FFitDataflowNode::NewMax' has a wrong offset!");
static_assert(offsetof(FFitDataflowNode, ReturnValue) == 0x0000FC, "Member 'FFitDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.EFitDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FEFitDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldMin;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OldMax;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMin;                                            // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewMax;                                            // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00FC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEFitDataflowNode) == 0x000008, "Wrong alignment on FEFitDataflowNode");
static_assert(sizeof(FEFitDataflowNode) == 0x000100, "Wrong size on FEFitDataflowNode");
static_assert(offsetof(FEFitDataflowNode, Float) == 0x0000E8, "Member 'FEFitDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FEFitDataflowNode, OldMin) == 0x0000EC, "Member 'FEFitDataflowNode::OldMin' has a wrong offset!");
static_assert(offsetof(FEFitDataflowNode, OldMax) == 0x0000F0, "Member 'FEFitDataflowNode::OldMax' has a wrong offset!");
static_assert(offsetof(FEFitDataflowNode, NewMin) == 0x0000F4, "Member 'FEFitDataflowNode::NewMin' has a wrong offset!");
static_assert(offsetof(FEFitDataflowNode, NewMax) == 0x0000F8, "Member 'FEFitDataflowNode::NewMax' has a wrong offset!");
static_assert(offsetof(FEFitDataflowNode, ReturnValue) == 0x0000FC, "Member 'FEFitDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PowDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FPowDataflowNode final : public FDataflowNode
{
public:
	float                                         base;                                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exp;                                               // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4A[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPowDataflowNode) == 0x000008, "Wrong alignment on FPowDataflowNode");
static_assert(sizeof(FPowDataflowNode) == 0x0000F8, "Wrong size on FPowDataflowNode");
static_assert(offsetof(FPowDataflowNode, base) == 0x0000E8, "Member 'FPowDataflowNode::base' has a wrong offset!");
static_assert(offsetof(FPowDataflowNode, Exp) == 0x0000EC, "Member 'FPowDataflowNode::Exp' has a wrong offset!");
static_assert(offsetof(FPowDataflowNode, ReturnValue) == 0x0000F0, "Member 'FPowDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LogDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FLogDataflowNode final : public FDataflowNode
{
public:
	float                                         base;                                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4B[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLogDataflowNode) == 0x000008, "Wrong alignment on FLogDataflowNode");
static_assert(sizeof(FLogDataflowNode) == 0x0000F8, "Wrong size on FLogDataflowNode");
static_assert(offsetof(FLogDataflowNode, base) == 0x0000E8, "Member 'FLogDataflowNode::base' has a wrong offset!");
static_assert(offsetof(FLogDataflowNode, A) == 0x0000EC, "Member 'FLogDataflowNode::A' has a wrong offset!");
static_assert(offsetof(FLogDataflowNode, ReturnValue) == 0x0000F0, "Member 'FLogDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LogeDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FLogeDataflowNode final : public FDataflowNode
{
public:
	float                                         A;                                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLogeDataflowNode) == 0x000008, "Wrong alignment on FLogeDataflowNode");
static_assert(sizeof(FLogeDataflowNode) == 0x0000F0, "Wrong size on FLogeDataflowNode");
static_assert(offsetof(FLogeDataflowNode, A) == 0x0000E8, "Member 'FLogeDataflowNode::A' has a wrong offset!");
static_assert(offsetof(FLogeDataflowNode, ReturnValue) == 0x0000EC, "Member 'FLogeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LerpDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FLerpDataflowNode final : public FDataflowNode
{
public:
	float                                         A;                                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLerpDataflowNode) == 0x000008, "Wrong alignment on FLerpDataflowNode");
static_assert(sizeof(FLerpDataflowNode) == 0x0000F8, "Wrong size on FLerpDataflowNode");
static_assert(offsetof(FLerpDataflowNode, A) == 0x0000E8, "Member 'FLerpDataflowNode::A' has a wrong offset!");
static_assert(offsetof(FLerpDataflowNode, B) == 0x0000EC, "Member 'FLerpDataflowNode::B' has a wrong offset!");
static_assert(offsetof(FLerpDataflowNode, Alpha) == 0x0000F0, "Member 'FLerpDataflowNode::Alpha' has a wrong offset!");
static_assert(offsetof(FLerpDataflowNode, ReturnValue) == 0x0000F4, "Member 'FLerpDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.WrapDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FWrapDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWrapDataflowNode) == 0x000008, "Wrong alignment on FWrapDataflowNode");
static_assert(sizeof(FWrapDataflowNode) == 0x0000F8, "Wrong size on FWrapDataflowNode");
static_assert(offsetof(FWrapDataflowNode, Float) == 0x0000E8, "Member 'FWrapDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FWrapDataflowNode, Min) == 0x0000EC, "Member 'FWrapDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FWrapDataflowNode, Max) == 0x0000F0, "Member 'FWrapDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FWrapDataflowNode, ReturnValue) == 0x0000F4, "Member 'FWrapDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FExpDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExpDataflowNode) == 0x000008, "Wrong alignment on FExpDataflowNode");
static_assert(sizeof(FExpDataflowNode) == 0x0000F0, "Wrong size on FExpDataflowNode");
static_assert(offsetof(FExpDataflowNode, Float) == 0x0000E8, "Member 'FExpDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FExpDataflowNode, ReturnValue) == 0x0000EC, "Member 'FExpDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SinDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FSinDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSinDataflowNode) == 0x000008, "Wrong alignment on FSinDataflowNode");
static_assert(sizeof(FSinDataflowNode) == 0x0000F0, "Wrong size on FSinDataflowNode");
static_assert(offsetof(FSinDataflowNode, Float) == 0x0000E8, "Member 'FSinDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FSinDataflowNode, ReturnValue) == 0x0000EC, "Member 'FSinDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CosDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FCosDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCosDataflowNode) == 0x000008, "Wrong alignment on FCosDataflowNode");
static_assert(sizeof(FCosDataflowNode) == 0x0000F0, "Wrong size on FCosDataflowNode");
static_assert(offsetof(FCosDataflowNode, Float) == 0x0000E8, "Member 'FCosDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FCosDataflowNode, ReturnValue) == 0x0000EC, "Member 'FCosDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TanDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FTanDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTanDataflowNode) == 0x000008, "Wrong alignment on FTanDataflowNode");
static_assert(sizeof(FTanDataflowNode) == 0x0000F0, "Wrong size on FTanDataflowNode");
static_assert(offsetof(FTanDataflowNode, Float) == 0x0000E8, "Member 'FTanDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FTanDataflowNode, ReturnValue) == 0x0000EC, "Member 'FTanDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ArcTanDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FArcTanDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArcTanDataflowNode) == 0x000008, "Wrong alignment on FArcTanDataflowNode");
static_assert(sizeof(FArcTanDataflowNode) == 0x0000F0, "Wrong size on FArcTanDataflowNode");
static_assert(offsetof(FArcTanDataflowNode, Float) == 0x0000E8, "Member 'FArcTanDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FArcTanDataflowNode, ReturnValue) == 0x0000EC, "Member 'FArcTanDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ArcTan2DataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FArcTan2DataflowNode final : public FDataflowNode
{
public:
	float                                         Y;                                                 // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4C[0x4];                                     // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArcTan2DataflowNode) == 0x000008, "Wrong alignment on FArcTan2DataflowNode");
static_assert(sizeof(FArcTan2DataflowNode) == 0x0000F8, "Wrong size on FArcTan2DataflowNode");
static_assert(offsetof(FArcTan2DataflowNode, Y) == 0x0000E8, "Member 'FArcTan2DataflowNode::Y' has a wrong offset!");
static_assert(offsetof(FArcTan2DataflowNode, X) == 0x0000EC, "Member 'FArcTan2DataflowNode::X' has a wrong offset!");
static_assert(offsetof(FArcTan2DataflowNode, ReturnValue) == 0x0000F0, "Member 'FArcTan2DataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ScaleVectorDataflowNode
// 0x0038 (0x0120 - 0x00E8)
struct FScaleVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4D[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ScaledVector;                                      // 0x0108(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScaleVectorDataflowNode) == 0x000008, "Wrong alignment on FScaleVectorDataflowNode");
static_assert(sizeof(FScaleVectorDataflowNode) == 0x000120, "Wrong size on FScaleVectorDataflowNode");
static_assert(offsetof(FScaleVectorDataflowNode, Vector) == 0x0000E8, "Member 'FScaleVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FScaleVectorDataflowNode, Scale) == 0x000100, "Member 'FScaleVectorDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FScaleVectorDataflowNode, ScaledVector) == 0x000108, "Member 'FScaleVectorDataflowNode::ScaledVector' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CrossProductDataflowNode
// 0x0048 (0x0130 - 0x00E8)
struct FCrossProductDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                VectorA;                                           // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                VectorB;                                           // 0x0100(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0118(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrossProductDataflowNode) == 0x000008, "Wrong alignment on FCrossProductDataflowNode");
static_assert(sizeof(FCrossProductDataflowNode) == 0x000130, "Wrong size on FCrossProductDataflowNode");
static_assert(offsetof(FCrossProductDataflowNode, VectorA) == 0x0000E8, "Member 'FCrossProductDataflowNode::VectorA' has a wrong offset!");
static_assert(offsetof(FCrossProductDataflowNode, VectorB) == 0x000100, "Member 'FCrossProductDataflowNode::VectorB' has a wrong offset!");
static_assert(offsetof(FCrossProductDataflowNode, ReturnValue) == 0x000118, "Member 'FCrossProductDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.LengthDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FLengthDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4E[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLengthDataflowNode) == 0x000008, "Wrong alignment on FLengthDataflowNode");
static_assert(sizeof(FLengthDataflowNode) == 0x000108, "Wrong size on FLengthDataflowNode");
static_assert(offsetof(FLengthDataflowNode, Vector) == 0x0000E8, "Member 'FLengthDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FLengthDataflowNode, ReturnValue) == 0x000100, "Member 'FLengthDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.IsNearlyZeroDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FIsNearlyZeroDataflowNode final : public FDataflowNode
{
public:
	float                                         Float;                                             // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4F[0x3];                                     // 0x00ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIsNearlyZeroDataflowNode) == 0x000008, "Wrong alignment on FIsNearlyZeroDataflowNode");
static_assert(sizeof(FIsNearlyZeroDataflowNode) == 0x0000F0, "Wrong size on FIsNearlyZeroDataflowNode");
static_assert(offsetof(FIsNearlyZeroDataflowNode, Float) == 0x0000E8, "Member 'FIsNearlyZeroDataflowNode::Float' has a wrong offset!");
static_assert(offsetof(FIsNearlyZeroDataflowNode, ReturnValue) == 0x0000EC, "Member 'FIsNearlyZeroDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomFloatInRangeDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FRandomFloatInRangeDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C50[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C51[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomFloatInRangeDataflowNode) == 0x000008, "Wrong alignment on FRandomFloatInRangeDataflowNode");
static_assert(sizeof(FRandomFloatInRangeDataflowNode) == 0x000100, "Wrong size on FRandomFloatInRangeDataflowNode");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, bDeterministic) == 0x0000E8, "Member 'FRandomFloatInRangeDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, RandomSeed) == 0x0000EC, "Member 'FRandomFloatInRangeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Min) == 0x0000F0, "Member 'FRandomFloatInRangeDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, Max) == 0x0000F4, "Member 'FRandomFloatInRangeDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FRandomFloatInRangeDataflowNode, ReturnValue) == 0x0000F8, "Member 'FRandomFloatInRangeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RandomUnitVectorInConeDataflowNode
// 0x0040 (0x0128 - 0x00E8)
struct FRandomUnitVectorInConeDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C52[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConeDirection;                                     // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngle;                                     // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C53[0x4];                                     // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0110(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRandomUnitVectorInConeDataflowNode) == 0x000008, "Wrong alignment on FRandomUnitVectorInConeDataflowNode");
static_assert(sizeof(FRandomUnitVectorInConeDataflowNode) == 0x000128, "Wrong size on FRandomUnitVectorInConeDataflowNode");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, bDeterministic) == 0x0000E8, "Member 'FRandomUnitVectorInConeDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, RandomSeed) == 0x0000EC, "Member 'FRandomUnitVectorInConeDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeDirection) == 0x0000F0, "Member 'FRandomUnitVectorInConeDataflowNode::ConeDirection' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ConeHalfAngle) == 0x000108, "Member 'FRandomUnitVectorInConeDataflowNode::ConeHalfAngle' has a wrong offset!");
static_assert(offsetof(FRandomUnitVectorInConeDataflowNode, ReturnValue) == 0x000110, "Member 'FRandomUnitVectorInConeDataflowNode::ReturnValue' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.DegreesToRadiansDataflowNode
// 0x0008 (0x00F0 - 0x00E8)
struct FDegreesToRadiansDataflowNode final : public FDataflowNode
{
public:
	float                                         Degrees;                                           // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radians;                                           // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDegreesToRadiansDataflowNode) == 0x000008, "Wrong alignment on FDegreesToRadiansDataflowNode");
static_assert(sizeof(FDegreesToRadiansDataflowNode) == 0x0000F0, "Wrong size on FDegreesToRadiansDataflowNode");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Degrees) == 0x0000E8, "Member 'FDegreesToRadiansDataflowNode::Degrees' has a wrong offset!");
static_assert(offsetof(FDegreesToRadiansDataflowNode, Radians) == 0x0000EC, "Member 'FDegreesToRadiansDataflowNode::Radians' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PointsToMeshDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FPointsToMeshDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TriangleCount;                                     // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C54[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPointsToMeshDataflowNode) == 0x000008, "Wrong alignment on FPointsToMeshDataflowNode");
static_assert(sizeof(FPointsToMeshDataflowNode) == 0x000108, "Wrong size on FPointsToMeshDataflowNode");
static_assert(offsetof(FPointsToMeshDataflowNode, Points) == 0x0000E8, "Member 'FPointsToMeshDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FPointsToMeshDataflowNode, Mesh) == 0x0000F8, "Member 'FPointsToMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FPointsToMeshDataflowNode, TriangleCount) == 0x000100, "Member 'FPointsToMeshDataflowNode::TriangleCount' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshInfoDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FMeshInfoDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InfoString;                                        // 0x00F0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshInfoDataflowNode) == 0x000008, "Wrong alignment on FMeshInfoDataflowNode");
static_assert(sizeof(FMeshInfoDataflowNode) == 0x000100, "Wrong size on FMeshInfoDataflowNode");
static_assert(offsetof(FMeshInfoDataflowNode, Mesh) == 0x0000E8, "Member 'FMeshInfoDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FMeshInfoDataflowNode, InfoString) == 0x0000F0, "Member 'FMeshInfoDataflowNode::InfoString' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionToMeshDataflowNode
// 0x00C0 (0x01A8 - 0x00E8)
struct FCollectionToMeshDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	bool                                          bCenterPivot;                                      // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C55[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionToMeshDataflowNode) == 0x000008, "Wrong alignment on FCollectionToMeshDataflowNode");
static_assert(sizeof(FCollectionToMeshDataflowNode) == 0x0001A8, "Wrong size on FCollectionToMeshDataflowNode");
static_assert(offsetof(FCollectionToMeshDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionToMeshDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionToMeshDataflowNode, bCenterPivot) == 0x000198, "Member 'FCollectionToMeshDataflowNode::bCenterPivot' has a wrong offset!");
static_assert(offsetof(FCollectionToMeshDataflowNode, Mesh) == 0x0001A0, "Member 'FCollectionToMeshDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshAppendDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FMeshAppendDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh1;                                             // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh2;                                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           Mesh;                                              // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshAppendDataflowNode) == 0x000008, "Wrong alignment on FMeshAppendDataflowNode");
static_assert(sizeof(FMeshAppendDataflowNode) == 0x000100, "Wrong size on FMeshAppendDataflowNode");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh1) == 0x0000E8, "Member 'FMeshAppendDataflowNode::Mesh1' has a wrong offset!");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh2) == 0x0000F0, "Member 'FMeshAppendDataflowNode::Mesh2' has a wrong offset!");
static_assert(offsetof(FMeshAppendDataflowNode, Mesh) == 0x0000F8, "Member 'FMeshAppendDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.MeshCopyToPointsDataflowNode
// 0x0028 (0x0110 - 0x00E8)
struct FMeshCopyToPointsDataflowNode final : public FDataflowNode
{
public:
	TArray<struct FVector>                        Points;                                            // 0x00E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDynamicMesh*                           MeshToCopy;                                        // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C56[0x4];                                     // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicMesh*                           Mesh;                                              // 0x0108(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMeshCopyToPointsDataflowNode) == 0x000008, "Wrong alignment on FMeshCopyToPointsDataflowNode");
static_assert(sizeof(FMeshCopyToPointsDataflowNode) == 0x000110, "Wrong size on FMeshCopyToPointsDataflowNode");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Points) == 0x0000E8, "Member 'FMeshCopyToPointsDataflowNode::Points' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, MeshToCopy) == 0x0000F8, "Member 'FMeshCopyToPointsDataflowNode::MeshToCopy' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Scale) == 0x000100, "Member 'FMeshCopyToPointsDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FMeshCopyToPointsDataflowNode, Mesh) == 0x000108, "Member 'FMeshCopyToPointsDataflowNode::Mesh' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCollectionFromAssetDataflowNode
// 0x00B8 (0x01A0 - 0x00E8)
struct FGetCollectionFromAssetDataflowNode final : public FDataflowNode
{
public:
	class UGeometryCollection*                    CollectionAsset;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x00F0(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCollectionFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetCollectionFromAssetDataflowNode");
static_assert(sizeof(FGetCollectionFromAssetDataflowNode) == 0x0001A0, "Wrong size on FGetCollectionFromAssetDataflowNode");
static_assert(offsetof(FGetCollectionFromAssetDataflowNode, CollectionAsset) == 0x0000E8, "Member 'FGetCollectionFromAssetDataflowNode::CollectionAsset' has a wrong offset!");
static_assert(offsetof(FGetCollectionFromAssetDataflowNode, Collection) == 0x0000F0, "Member 'FGetCollectionFromAssetDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.PrintStringDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FPrintStringDataflowNode final : public FDataflowNode
{
public:
	bool                                          bPrintToScreen;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintToLog;                                       // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C57[0x2];                                     // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 Color;                                             // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C58[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 String;                                            // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPrintStringDataflowNode) == 0x000008, "Wrong alignment on FPrintStringDataflowNode");
static_assert(sizeof(FPrintStringDataflowNode) == 0x000108, "Wrong size on FPrintStringDataflowNode");
static_assert(offsetof(FPrintStringDataflowNode, bPrintToScreen) == 0x0000E8, "Member 'FPrintStringDataflowNode::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, bPrintToLog) == 0x0000E9, "Member 'FPrintStringDataflowNode::bPrintToLog' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Color) == 0x0000EC, "Member 'FPrintStringDataflowNode::Color' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, Duration) == 0x0000F0, "Member 'FPrintStringDataflowNode::Duration' has a wrong offset!");
static_assert(offsetof(FPrintStringDataflowNode, String) == 0x0000F8, "Member 'FPrintStringDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BoundingBoxDataflowNode
// 0x00E8 (0x01D0 - 0x00E8)
struct FBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   BoundingBox;                                       // 0x0198(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FBoundingBoxDataflowNode");
static_assert(sizeof(FBoundingBoxDataflowNode) == 0x0001D0, "Wrong size on FBoundingBoxDataflowNode");
static_assert(offsetof(FBoundingBoxDataflowNode, Collection) == 0x0000E8, "Member 'FBoundingBoxDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FBoundingBoxDataflowNode, BoundingBox) == 0x000198, "Member 'FBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ExpandBoundingBoxDataflowNode
// 0x00A0 (0x0188 - 0x00E8)
struct FExpandBoundingBoxDataflowNode final : public FDataflowNode
{
public:
	struct FBox                                   BoundingBox;                                       // 0x00E8(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x0120(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x0138(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0150(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfExtents;                                       // 0x0168(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C59[0x4];                                     // 0x0184(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExpandBoundingBoxDataflowNode) == 0x000008, "Wrong alignment on FExpandBoundingBoxDataflowNode");
static_assert(sizeof(FExpandBoundingBoxDataflowNode) == 0x000188, "Wrong size on FExpandBoundingBoxDataflowNode");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, BoundingBox) == 0x0000E8, "Member 'FExpandBoundingBoxDataflowNode::BoundingBox' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Min) == 0x000120, "Member 'FExpandBoundingBoxDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Max) == 0x000138, "Member 'FExpandBoundingBoxDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Center) == 0x000150, "Member 'FExpandBoundingBoxDataflowNode::Center' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, HalfExtents) == 0x000168, "Member 'FExpandBoundingBoxDataflowNode::HalfExtents' has a wrong offset!");
static_assert(offsetof(FExpandBoundingBoxDataflowNode, Volume) == 0x000180, "Member 'FExpandBoundingBoxDataflowNode::Volume' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.StringAppendDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FStringAppendDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String1;                                           // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String2;                                           // 0x00F8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStringAppendDataflowNode) == 0x000008, "Wrong alignment on FStringAppendDataflowNode");
static_assert(sizeof(FStringAppendDataflowNode) == 0x000118, "Wrong size on FStringAppendDataflowNode");
static_assert(offsetof(FStringAppendDataflowNode, String1) == 0x0000E8, "Member 'FStringAppendDataflowNode::String1' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String2) == 0x0000F8, "Member 'FStringAppendDataflowNode::String2' has a wrong offset!");
static_assert(offsetof(FStringAppendDataflowNode, String) == 0x000108, "Member 'FStringAppendDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashStringDataflowNode
// 0x0018 (0x0100 - 0x00E8)
struct FHashStringDataflowNode final : public FDataflowNode
{
public:
	class FString                                 String;                                            // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5A[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashStringDataflowNode) == 0x000008, "Wrong alignment on FHashStringDataflowNode");
static_assert(sizeof(FHashStringDataflowNode) == 0x000100, "Wrong size on FHashStringDataflowNode");
static_assert(offsetof(FHashStringDataflowNode, String) == 0x0000E8, "Member 'FHashStringDataflowNode::String' has a wrong offset!");
static_assert(offsetof(FHashStringDataflowNode, Hash) == 0x0000F8, "Member 'FHashStringDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.HashVectorDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FHashVectorDataflowNode final : public FDataflowNode
{
public:
	struct FVector                                Vector;                                            // 0x00E8(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hash;                                              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5B[0x4];                                     // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHashVectorDataflowNode) == 0x000008, "Wrong alignment on FHashVectorDataflowNode");
static_assert(sizeof(FHashVectorDataflowNode) == 0x000108, "Wrong size on FHashVectorDataflowNode");
static_assert(offsetof(FHashVectorDataflowNode, Vector) == 0x0000E8, "Member 'FHashVectorDataflowNode::Vector' has a wrong offset!");
static_assert(offsetof(FHashVectorDataflowNode, Hash) == 0x000100, "Member 'FHashVectorDataflowNode::Hash' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetBoundingBoxesFromCollectionDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FGetBoundingBoxesFromCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	TArray<struct FBox>                           BoundingBoxes;                                     // 0x01B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetBoundingBoxesFromCollectionDataflowNode) == 0x000008, "Wrong alignment on FGetBoundingBoxesFromCollectionDataflowNode");
static_assert(sizeof(FGetBoundingBoxesFromCollectionDataflowNode) == 0x0001C8, "Wrong size on FGetBoundingBoxesFromCollectionDataflowNode");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, TransformSelection) == 0x000198, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FGetBoundingBoxesFromCollectionDataflowNode, BoundingBoxes) == 0x0001B8, "Member 'FGetBoundingBoxesFromCollectionDataflowNode::BoundingBoxes' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetRootIndexFromCollectionDataflowNode
// 0x00B8 (0x01A0 - 0x00E8)
struct FGetRootIndexFromCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	int32                                         RootIndex;                                         // 0x0198(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5C[0x4];                                     // 0x019C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGetRootIndexFromCollectionDataflowNode) == 0x000008, "Wrong alignment on FGetRootIndexFromCollectionDataflowNode");
static_assert(sizeof(FGetRootIndexFromCollectionDataflowNode) == 0x0001A0, "Wrong size on FGetRootIndexFromCollectionDataflowNode");
static_assert(offsetof(FGetRootIndexFromCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FGetRootIndexFromCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetRootIndexFromCollectionDataflowNode, RootIndex) == 0x000198, "Member 'FGetRootIndexFromCollectionDataflowNode::RootIndex' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformCollectionDataflowNode
// 0x0140 (0x0228 - 0x00E8)
struct FTransformCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FVector                                Translate;                                         // 0x0198(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationOrderEnum                            RotationOrder;                                     // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5D[0x7];                                     // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Rotate;                                            // 0x01B8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x01D0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5E[0x4];                                     // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotatePivot;                                       // 0x01F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePivot;                                        // 0x0208(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTransformation;                             // 0x0220(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C5F[0x7];                                     // 0x0221(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransformCollectionDataflowNode) == 0x000008, "Wrong alignment on FTransformCollectionDataflowNode");
static_assert(sizeof(FTransformCollectionDataflowNode) == 0x000228, "Wrong size on FTransformCollectionDataflowNode");
static_assert(offsetof(FTransformCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FTransformCollectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Translate) == 0x000198, "Member 'FTransformCollectionDataflowNode::Translate' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, RotationOrder) == 0x0001B0, "Member 'FTransformCollectionDataflowNode::RotationOrder' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Rotate) == 0x0001B8, "Member 'FTransformCollectionDataflowNode::Rotate' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, Scale) == 0x0001D0, "Member 'FTransformCollectionDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, UniformScale) == 0x0001E8, "Member 'FTransformCollectionDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, RotatePivot) == 0x0001F0, "Member 'FTransformCollectionDataflowNode::RotatePivot' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, ScalePivot) == 0x000208, "Member 'FTransformCollectionDataflowNode::ScalePivot' has a wrong offset!");
static_assert(offsetof(FTransformCollectionDataflowNode, bInvertTransformation) == 0x000220, "Member 'FTransformCollectionDataflowNode::bInvertTransformation' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BakeTransformsInCollectionDataflowNode
// 0x00B0 (0x0198 - 0x00E8)
struct FBakeTransformsInCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBakeTransformsInCollectionDataflowNode) == 0x000008, "Wrong alignment on FBakeTransformsInCollectionDataflowNode");
static_assert(sizeof(FBakeTransformsInCollectionDataflowNode) == 0x000198, "Wrong size on FBakeTransformsInCollectionDataflowNode");
static_assert(offsetof(FBakeTransformsInCollectionDataflowNode, Collection) == 0x0000E8, "Member 'FBakeTransformsInCollectionDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformMeshDataflowNode
// 0x0098 (0x0180 - 0x00E8)
struct FTransformMeshDataflowNode final : public FDataflowNode
{
public:
	class UDynamicMesh*                           Mesh;                                              // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Translate;                                         // 0x00F0(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERotationOrderEnum                            RotationOrder;                                     // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C60[0x7];                                     // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Rotate;                                            // 0x0110(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0128(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UniformScale;                                      // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C61[0x4];                                     // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RotatePivot;                                       // 0x0148(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScalePivot;                                        // 0x0160(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvertTransformation;                             // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C62[0x7];                                     // 0x0179(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTransformMeshDataflowNode) == 0x000008, "Wrong alignment on FTransformMeshDataflowNode");
static_assert(sizeof(FTransformMeshDataflowNode) == 0x000180, "Wrong size on FTransformMeshDataflowNode");
static_assert(offsetof(FTransformMeshDataflowNode, Mesh) == 0x0000E8, "Member 'FTransformMeshDataflowNode::Mesh' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Translate) == 0x0000F0, "Member 'FTransformMeshDataflowNode::Translate' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, RotationOrder) == 0x000108, "Member 'FTransformMeshDataflowNode::RotationOrder' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Rotate) == 0x000110, "Member 'FTransformMeshDataflowNode::Rotate' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, Scale) == 0x000128, "Member 'FTransformMeshDataflowNode::Scale' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, UniformScale) == 0x000140, "Member 'FTransformMeshDataflowNode::UniformScale' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, RotatePivot) == 0x000148, "Member 'FTransformMeshDataflowNode::RotatePivot' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, ScalePivot) == 0x000160, "Member 'FTransformMeshDataflowNode::ScalePivot' has a wrong offset!");
static_assert(offsetof(FTransformMeshDataflowNode, bInvertTransformation) == 0x000178, "Member 'FTransformMeshDataflowNode::bInvertTransformation' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CompareFloatDataflowNode
// 0x0010 (0x00F8 - 0x00E8)
struct FCompareFloatDataflowNode final : public FDataflowNode
{
public:
	ECompareOperationEnum                         Operation;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C63[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FloatA;                                            // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatB;                                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Result;                                            // 0x00F4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C64[0x3];                                     // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCompareFloatDataflowNode) == 0x000008, "Wrong alignment on FCompareFloatDataflowNode");
static_assert(sizeof(FCompareFloatDataflowNode) == 0x0000F8, "Wrong size on FCompareFloatDataflowNode");
static_assert(offsetof(FCompareFloatDataflowNode, Operation) == 0x0000E8, "Member 'FCompareFloatDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCompareFloatDataflowNode, FloatA) == 0x0000EC, "Member 'FCompareFloatDataflowNode::FloatA' has a wrong offset!");
static_assert(offsetof(FCompareFloatDataflowNode, FloatB) == 0x0000F0, "Member 'FCompareFloatDataflowNode::FloatB' has a wrong offset!");
static_assert(offsetof(FCompareFloatDataflowNode, Result) == 0x0000F4, "Member 'FCompareFloatDataflowNode::Result' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.BranchCollectionDataflowNode
// 0x0218 (0x0300 - 0x00E8)
struct FBranchCollectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                TrueCollection;                                    // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                FalseCollection;                                   // 0x0198(0x00B0)(NativeAccessSpecifierPublic)
	bool                                          bCondition;                                        // 0x0248(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C65[0x7];                                     // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                ChosenCollection;                                  // 0x0250(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBranchCollectionDataflowNode) == 0x000008, "Wrong alignment on FBranchCollectionDataflowNode");
static_assert(sizeof(FBranchCollectionDataflowNode) == 0x000300, "Wrong size on FBranchCollectionDataflowNode");
static_assert(offsetof(FBranchCollectionDataflowNode, TrueCollection) == 0x0000E8, "Member 'FBranchCollectionDataflowNode::TrueCollection' has a wrong offset!");
static_assert(offsetof(FBranchCollectionDataflowNode, FalseCollection) == 0x000198, "Member 'FBranchCollectionDataflowNode::FalseCollection' has a wrong offset!");
static_assert(offsetof(FBranchCollectionDataflowNode, bCondition) == 0x000248, "Member 'FBranchCollectionDataflowNode::bCondition' has a wrong offset!");
static_assert(offsetof(FBranchCollectionDataflowNode, ChosenCollection) == 0x000250, "Member 'FBranchCollectionDataflowNode::ChosenCollection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.RemoveOnBreakDataflowNode
// 0x00E8 (0x01D0 - 0x00E8)
struct FRemoveOnBreakDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bEnabledRemoval;                                   // 0x01B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C66[0x3];                                     // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2f                              PostBreakTimer;                                    // 0x01BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2f                              RemovalTimer;                                      // 0x01C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClusterCrumbling;                                 // 0x01CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C67[0x3];                                     // 0x01CD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRemoveOnBreakDataflowNode) == 0x000008, "Wrong alignment on FRemoveOnBreakDataflowNode");
static_assert(sizeof(FRemoveOnBreakDataflowNode) == 0x0001D0, "Wrong size on FRemoveOnBreakDataflowNode");
static_assert(offsetof(FRemoveOnBreakDataflowNode, Collection) == 0x0000E8, "Member 'FRemoveOnBreakDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, TransformSelection) == 0x000198, "Member 'FRemoveOnBreakDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, bEnabledRemoval) == 0x0001B8, "Member 'FRemoveOnBreakDataflowNode::bEnabledRemoval' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, PostBreakTimer) == 0x0001BC, "Member 'FRemoveOnBreakDataflowNode::PostBreakTimer' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, RemovalTimer) == 0x0001C4, "Member 'FRemoveOnBreakDataflowNode::RemovalTimer' has a wrong offset!");
static_assert(offsetof(FRemoveOnBreakDataflowNode, bClusterCrumbling) == 0x0001CC, "Member 'FRemoveOnBreakDataflowNode::bClusterCrumbling' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.ProximityDataflowNode
// 0x00C0 (0x01A8 - 0x00E8)
struct FProximityDataflowNode final : public FDataflowNode
{
public:
	EProximityMethodEnum                          ProximityMethod;                                   // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C68[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceThreshold;                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContactThreshold;                                  // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProximityContactFilteringMethodEnum          FilterContactMethod;                               // 0x00F4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAsConnectionGraph;                             // 0x00F5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EConnectionContactAreaMethodEnum              ContactAreaMethod;                                 // 0x00F6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C69[0x1];                                     // 0x00F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FProximityDataflowNode) == 0x000008, "Wrong alignment on FProximityDataflowNode");
static_assert(sizeof(FProximityDataflowNode) == 0x0001A8, "Wrong size on FProximityDataflowNode");
static_assert(offsetof(FProximityDataflowNode, ProximityMethod) == 0x0000E8, "Member 'FProximityDataflowNode::ProximityMethod' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, DistanceThreshold) == 0x0000EC, "Member 'FProximityDataflowNode::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, ContactThreshold) == 0x0000F0, "Member 'FProximityDataflowNode::ContactThreshold' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, FilterContactMethod) == 0x0000F4, "Member 'FProximityDataflowNode::FilterContactMethod' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, bUseAsConnectionGraph) == 0x0000F5, "Member 'FProximityDataflowNode::bUseAsConnectionGraph' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, ContactAreaMethod) == 0x0000F6, "Member 'FProximityDataflowNode::ContactAreaMethod' has a wrong offset!");
static_assert(offsetof(FProximityDataflowNode, Collection) == 0x0000F8, "Member 'FProximityDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.AddCustomCollectionAttributeDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FAddCustomCollectionAttributeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6A[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomAttributeTypeEnum                      CustomAttributeType;                               // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6B[0x3];                                     // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumElements;                                       // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddCustomCollectionAttributeDataflowNode) == 0x000008, "Wrong alignment on FAddCustomCollectionAttributeDataflowNode");
static_assert(sizeof(FAddCustomCollectionAttributeDataflowNode) == 0x0001C8, "Wrong size on FAddCustomCollectionAttributeDataflowNode");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, Collection) == 0x0000E8, "Member 'FAddCustomCollectionAttributeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, GroupName) == 0x000198, "Member 'FAddCustomCollectionAttributeDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, CustomGroupName) == 0x0001A0, "Member 'FAddCustomCollectionAttributeDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, AttrName) == 0x0001B0, "Member 'FAddCustomCollectionAttributeDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, CustomAttributeType) == 0x0001C0, "Member 'FAddCustomCollectionAttributeDataflowNode::CustomAttributeType' has a wrong offset!");
static_assert(offsetof(FAddCustomCollectionAttributeDataflowNode, NumElements) == 0x0001C4, "Member 'FAddCustomCollectionAttributeDataflowNode::NumElements' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetCollectionAttributeDataTypedDataflowNode
// 0x0148 (0x0230 - 0x00E8)
struct FGetCollectionAttributeDataTypedDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	EStandardGroupNameEnum                        GroupName;                                         // 0x0198(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6C[0x7];                                     // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CustomGroupName;                                   // 0x01A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<bool>                                  BoolAttributeData;                                 // 0x01C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 FloatAttributeData;                                // 0x01D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<double>                                DoubleAttributeData;                               // 0x01E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Int32AttributeData;                                // 0x01F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringAttributeData;                               // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3f>                      Vector3fAttributeData;                             // 0x0210(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector3d>                      Vector3dAttributeData;                             // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetCollectionAttributeDataTypedDataflowNode) == 0x000008, "Wrong alignment on FGetCollectionAttributeDataTypedDataflowNode");
static_assert(sizeof(FGetCollectionAttributeDataTypedDataflowNode) == 0x000230, "Wrong size on FGetCollectionAttributeDataTypedDataflowNode");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Collection) == 0x0000E8, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, GroupName) == 0x000198, "Member 'FGetCollectionAttributeDataTypedDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, CustomGroupName) == 0x0001A0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::CustomGroupName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, AttrName) == 0x0001B0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, BoolAttributeData) == 0x0001C0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::BoolAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, FloatAttributeData) == 0x0001D0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::FloatAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, DoubleAttributeData) == 0x0001E0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::DoubleAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Int32AttributeData) == 0x0001F0, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Int32AttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, StringAttributeData) == 0x000200, "Member 'FGetCollectionAttributeDataTypedDataflowNode::StringAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Vector3fAttributeData) == 0x000210, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Vector3fAttributeData' has a wrong offset!");
static_assert(offsetof(FGetCollectionAttributeDataTypedDataflowNode, Vector3dAttributeData) == 0x000220, "Member 'FGetCollectionAttributeDataTypedDataflowNode::Vector3dAttributeData' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVertexColorInCollectionFromVertexSelectionDataflowNode
// 0x00F0 (0x01D8 - 0x00E8)
struct FSetVertexColorInCollectionFromVertexSelectionDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	struct FLinearColor                           SelectedColor;                                     // 0x01B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           NonSelectedColor;                                  // 0x01C8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode) == 0x000008, "Wrong alignment on FSetVertexColorInCollectionFromVertexSelectionDataflowNode");
static_assert(sizeof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode) == 0x0001D8, "Wrong size on FSetVertexColorInCollectionFromVertexSelectionDataflowNode");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, Collection) == 0x0000E8, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, VertexSelection) == 0x000198, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, SelectedColor) == 0x0001B8, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::SelectedColor' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromVertexSelectionDataflowNode, NonSelectedColor) == 0x0001C8, "Member 'FSetVertexColorInCollectionFromVertexSelectionDataflowNode::NonSelectedColor' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.SetVertexColorInCollectionFromFloatArrayDataflowNode
// 0x00C8 (0x01B0 - 0x00E8)
struct FSetVertexColorInCollectionFromFloatArrayDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	TArray<float>                                 FloatArray;                                        // 0x0198(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6D[0x4];                                     // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSetVertexColorInCollectionFromFloatArrayDataflowNode) == 0x000008, "Wrong alignment on FSetVertexColorInCollectionFromFloatArrayDataflowNode");
static_assert(sizeof(FSetVertexColorInCollectionFromFloatArrayDataflowNode) == 0x0001B0, "Wrong size on FSetVertexColorInCollectionFromFloatArrayDataflowNode");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, Collection) == 0x0000E8, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, FloatArray) == 0x000198, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::FloatArray' has a wrong offset!");
static_assert(offsetof(FSetVertexColorInCollectionFromFloatArrayDataflowNode, Scale) == 0x0001A8, "Member 'FSetVertexColorInCollectionFromFloatArrayDataflowNode::Scale' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.InvertTransformDataflowNode
// 0x00C8 (0x01B0 - 0x00E8)
struct FInvertTransformDataflowNode final : public FDataflowNode
{
public:
	uint8                                         Pad_2C6E[0x8];                                     // 0x00E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InTransform;                                       // 0x00F0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             OutTransform;                                      // 0x0150(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvertTransformDataflowNode) == 0x000010, "Wrong alignment on FInvertTransformDataflowNode");
static_assert(sizeof(FInvertTransformDataflowNode) == 0x0001B0, "Wrong size on FInvertTransformDataflowNode");
static_assert(offsetof(FInvertTransformDataflowNode, InTransform) == 0x0000F0, "Member 'FInvertTransformDataflowNode::InTransform' has a wrong offset!");
static_assert(offsetof(FInvertTransformDataflowNode, OutTransform) == 0x000150, "Member 'FInvertTransformDataflowNode::OutTransform' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetIntOverrideFromAssetDataflowNode
// 0x0008 (0x0110 - 0x0108)
struct FGetIntOverrideFromAssetDataflowNode final : public FDataflowOverrideNode
{
public:
	int32                                         Int;                                               // 0x0108(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntDefault;                                        // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetIntOverrideFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetIntOverrideFromAssetDataflowNode");
static_assert(sizeof(FGetIntOverrideFromAssetDataflowNode) == 0x000110, "Wrong size on FGetIntOverrideFromAssetDataflowNode");
static_assert(offsetof(FGetIntOverrideFromAssetDataflowNode, Int) == 0x000108, "Member 'FGetIntOverrideFromAssetDataflowNode::Int' has a wrong offset!");
static_assert(offsetof(FGetIntOverrideFromAssetDataflowNode, IntDefault) == 0x00010C, "Member 'FGetIntOverrideFromAssetDataflowNode::IntDefault' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.GetStringOverrideFromAssetDataflowNode
// 0x0020 (0x0128 - 0x0108)
struct FGetStringOverrideFromAssetDataflowNode final : public FDataflowOverrideNode
{
public:
	class FString                                 String;                                            // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringDefault;                                     // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetStringOverrideFromAssetDataflowNode) == 0x000008, "Wrong alignment on FGetStringOverrideFromAssetDataflowNode");
static_assert(sizeof(FGetStringOverrideFromAssetDataflowNode) == 0x000128, "Wrong size on FGetStringOverrideFromAssetDataflowNode");
static_assert(offsetof(FGetStringOverrideFromAssetDataflowNode, String) == 0x000108, "Member 'FGetStringOverrideFromAssetDataflowNode::String' has a wrong offset!");
static_assert(offsetof(FGetStringOverrideFromAssetDataflowNode, StringDefault) == 0x000118, "Member 'FGetStringOverrideFromAssetDataflowNode::StringDefault' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionSetOperationDataflowNode
// 0x0068 (0x0150 - 0x00E8)
struct FCollectionTransformSelectionSetOperationDataflowNode final : public FDataflowNode
{
public:
	ESetOperationEnum                             Operation;                                         // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C6F[0x7];                                     // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelectionA;                               // 0x00F0(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelectionB;                               // 0x0110(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0130(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionSetOperationDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionSetOperationDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionSetOperationDataflowNode) == 0x000150, "Wrong size on FCollectionTransformSelectionSetOperationDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, Operation) == 0x0000E8, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::Operation' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelectionA) == 0x0000F0, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelectionA' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelectionB) == 0x000110, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelectionB' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionSetOperationDataflowNode, TransformSelection) == 0x000130, "Member 'FCollectionTransformSelectionSetOperationDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInfoDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionInfoDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 String;                                            // 0x01B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionInfoDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionInfoDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInfoDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionInfoDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionInfoDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionInfoDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInfoDataflowNode, String) == 0x0001B8, "Member 'FCollectionTransformSelectionInfoDataflowNode::String' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionNoneDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionNoneDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionNoneDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionNoneDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionNoneDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionNoneDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionNoneDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionNoneDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionNoneDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionTransformSelectionNoneDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInvertDataflowNode
// 0x0020 (0x0108 - 0x00E8)
struct FCollectionTransformSelectionInvertDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionInvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionInvertDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInvertDataflowNode) == 0x000108, "Wrong size on FCollectionTransformSelectionInvertDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInvertDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionInvertDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionRandomDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionRandomDataflowNode final : public FDataflowNode
{
public:
	bool                                          bDeterministic;                                    // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C70[0x3];                                     // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomThreshold;                                   // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C71[0x4];                                     // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FManagedArrayCollection                Collection;                                        // 0x00F8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionRandomDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionRandomDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionRandomDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionRandomDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, bDeterministic) == 0x0000E8, "Member 'FCollectionTransformSelectionRandomDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, RandomSeed) == 0x0000EC, "Member 'FCollectionTransformSelectionRandomDataflowNode::RandomSeed' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, RandomThreshold) == 0x0000F0, "Member 'FCollectionTransformSelectionRandomDataflowNode::RandomThreshold' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, Collection) == 0x0000F8, "Member 'FCollectionTransformSelectionRandomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionRandomDataflowNode, TransformSelection) == 0x0001A8, "Member 'FCollectionTransformSelectionRandomDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionCustomDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 BoneIndicies;                                      // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionCustomDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, BoneIndicies) == 0x000198, "Member 'FCollectionTransformSelectionCustomDataflowNode::BoneIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionCustomDataflowNode, TransformSelection) == 0x0001A8, "Member 'FCollectionTransformSelectionCustomDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionFromIndexArrayDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionFromIndexArrayDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	TArray<int32>                                 BoneIndices;                                       // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionFromIndexArrayDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionFromIndexArrayDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionFromIndexArrayDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionFromIndexArrayDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionFromIndexArrayDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionFromIndexArrayDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionFromIndexArrayDataflowNode, BoneIndices) == 0x000198, "Member 'FCollectionTransformSelectionFromIndexArrayDataflowNode::BoneIndices' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionFromIndexArrayDataflowNode, TransformSelection) == 0x0001A8, "Member 'FCollectionTransformSelectionFromIndexArrayDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionParentDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionParentDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionParentDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionParentDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionParentDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionParentDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionParentDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionParentDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionParentDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionParentDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionChildrenDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionChildrenDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionChildrenDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionChildrenDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionChildrenDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionChildrenDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionChildrenDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionChildrenDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionChildrenDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionChildrenDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionLevelDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionLevelDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionLevelDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionLevelDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionLevelDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionLevelDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionLevelDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionLevelDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionLevelDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionLevelDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionContactDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionContactDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowTransformSelection            TransformSelection;                                // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	struct FManagedArrayCollection                Collection;                                        // 0x0108(0x00B0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionContactDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionContactDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionContactDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionContactDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionContactDataflowNode, TransformSelection) == 0x0000E8, "Member 'FCollectionTransformSelectionContactDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionContactDataflowNode, Collection) == 0x000108, "Member 'FCollectionTransformSelectionContactDataflowNode::Collection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionClusterDataflowNode
// 0x00D0 (0x01B8 - 0x00E8)
struct FCollectionTransformSelectionClusterDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionClusterDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionClusterDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionClusterDataflowNode) == 0x0001B8, "Wrong size on FCollectionTransformSelectionClusterDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionClusterDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionClusterDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionClusterDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionTransformSelectionClusterDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionBySizeDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionTransformSelectionBySizeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	float                                         SizeMin;                                           // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SizeMax;                                           // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRelativeSize;                                  // 0x01A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C72[0x5];                                     // 0x01A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionBySizeDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionBySizeDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionBySizeDataflowNode) == 0x0001C8, "Wrong size on FCollectionTransformSelectionBySizeDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionBySizeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, SizeMin) == 0x000198, "Member 'FCollectionTransformSelectionBySizeDataflowNode::SizeMin' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, SizeMax) == 0x00019C, "Member 'FCollectionTransformSelectionBySizeDataflowNode::SizeMax' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, RangeSetting) == 0x0001A0, "Member 'FCollectionTransformSelectionBySizeDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, bInclusive) == 0x0001A1, "Member 'FCollectionTransformSelectionBySizeDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, bUseRelativeSize) == 0x0001A2, "Member 'FCollectionTransformSelectionBySizeDataflowNode::bUseRelativeSize' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionBySizeDataflowNode, TransformSelection) == 0x0001A8, "Member 'FCollectionTransformSelectionBySizeDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionInBoxDataflowNode
// 0x0178 (0x0260 - 0x00E8)
struct FCollectionTransformSelectionInBoxDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FBox                                   Box;                                               // 0x0198(0x0038)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x01D0(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectSubjectTypeEnum                        Type;                                              // 0x0230(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllVerticesMustContainedInBox;                    // 0x0231(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C73[0x6];                                     // 0x0232(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0238(0x0020)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2C74[0x8];                                     // 0x0258(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionTransformSelectionInBoxDataflowNode) == 0x000010, "Wrong alignment on FCollectionTransformSelectionInBoxDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionInBoxDataflowNode) == 0x000260, "Wrong size on FCollectionTransformSelectionInBoxDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Box) == 0x000198, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Box' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Transform) == 0x0001D0, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Transform' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, Type) == 0x000230, "Member 'FCollectionTransformSelectionInBoxDataflowNode::Type' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, bAllVerticesMustContainedInBox) == 0x000231, "Member 'FCollectionTransformSelectionInBoxDataflowNode::bAllVerticesMustContainedInBox' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionInBoxDataflowNode, TransformSelection) == 0x000238, "Member 'FCollectionTransformSelectionInBoxDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionTransformSelectionByFloatAttrDataflowNode
// 0x0100 (0x01E8 - 0x00E8)
struct FCollectionTransformSelectionByFloatAttrDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x0198(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttrName;                                          // 0x01A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min;                                               // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERangeSettingEnum                             RangeSetting;                                      // 0x01C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInclusive;                                        // 0x01C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C75[0x6];                                     // 0x01C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDataflowTransformSelection            TransformSelection;                                // 0x01C8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionTransformSelectionByFloatAttrDataflowNode) == 0x000008, "Wrong alignment on FCollectionTransformSelectionByFloatAttrDataflowNode");
static_assert(sizeof(FCollectionTransformSelectionByFloatAttrDataflowNode) == 0x0001E8, "Wrong size on FCollectionTransformSelectionByFloatAttrDataflowNode");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, GroupName) == 0x000198, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, AttrName) == 0x0001A8, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::AttrName' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Min) == 0x0001B8, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Min' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, Max) == 0x0001BC, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::Max' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, RangeSetting) == 0x0001C0, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::RangeSetting' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, bInclusive) == 0x0001C1, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::bInclusive' has a wrong offset!");
static_assert(offsetof(FCollectionTransformSelectionByFloatAttrDataflowNode, TransformSelection) == 0x0001C8, "Member 'FCollectionTransformSelectionByFloatAttrDataflowNode::TransformSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionCustomDataflowNode
// 0x00E0 (0x01C8 - 0x00E8)
struct FCollectionVertexSelectionCustomDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	class FString                                 VertexIndicies;                                    // 0x0198(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x01A8(0x0020)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionVertexSelectionCustomDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionCustomDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionCustomDataflowNode) == 0x0001C8, "Wrong size on FCollectionVertexSelectionCustomDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionVertexSelectionCustomDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, VertexIndicies) == 0x000198, "Member 'FCollectionVertexSelectionCustomDataflowNode::VertexIndicies' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionCustomDataflowNode, VertexSelection) == 0x0001A8, "Member 'FCollectionVertexSelectionCustomDataflowNode::VertexSelection' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionSelectionConvertDataflowNode
// 0x0118 (0x0200 - 0x00E8)
struct FCollectionSelectionConvertDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	struct FDataflowTransformSelection            TransformSelection;                                // 0x0198(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowFaceSelection                 FaceSelection;                                     // 0x01B8(0x0020)(NativeAccessSpecifierPublic)
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x01D8(0x0020)(NativeAccessSpecifierPublic)
	bool                                          bAllElementsMustBeSelected;                        // 0x01F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C76[0x7];                                     // 0x01F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionSelectionConvertDataflowNode) == 0x000008, "Wrong alignment on FCollectionSelectionConvertDataflowNode");
static_assert(sizeof(FCollectionSelectionConvertDataflowNode) == 0x000200, "Wrong size on FCollectionSelectionConvertDataflowNode");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, Collection) == 0x0000E8, "Member 'FCollectionSelectionConvertDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, TransformSelection) == 0x000198, "Member 'FCollectionSelectionConvertDataflowNode::TransformSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, FaceSelection) == 0x0001B8, "Member 'FCollectionSelectionConvertDataflowNode::FaceSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, VertexSelection) == 0x0001D8, "Member 'FCollectionSelectionConvertDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FCollectionSelectionConvertDataflowNode, bAllElementsMustBeSelected) == 0x0001F8, "Member 'FCollectionSelectionConvertDataflowNode::bAllElementsMustBeSelected' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.CollectionVertexSelectionByPercentageDataflowNode
// 0x0030 (0x0118 - 0x00E8)
struct FCollectionVertexSelectionByPercentageDataflowNode final : public FDataflowNode
{
public:
	struct FDataflowVertexSelection               VertexSelection;                                   // 0x00E8(0x0020)(NativeAccessSpecifierPublic)
	int32                                         Percentage;                                        // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeterministic;                                    // 0x010C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C77[0x3];                                     // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomSeed;                                        // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C78[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionVertexSelectionByPercentageDataflowNode) == 0x000008, "Wrong alignment on FCollectionVertexSelectionByPercentageDataflowNode");
static_assert(sizeof(FCollectionVertexSelectionByPercentageDataflowNode) == 0x000118, "Wrong size on FCollectionVertexSelectionByPercentageDataflowNode");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, VertexSelection) == 0x0000E8, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::VertexSelection' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, Percentage) == 0x000108, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::Percentage' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, bDeterministic) == 0x00010C, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::bDeterministic' has a wrong offset!");
static_assert(offsetof(FCollectionVertexSelectionByPercentageDataflowNode, RandomSeed) == 0x000110, "Member 'FCollectionVertexSelectionByPercentageDataflowNode::RandomSeed' has a wrong offset!");

// ScriptStruct GeometryCollectionNodes.TransformCollectionAttributeDataflowNode
// 0x0198 (0x0280 - 0x00E8)
struct FTransformCollectionAttributeDataflowNode final : public FDataflowNode
{
public:
	struct FManagedArrayCollection                Collection;                                        // 0x00E8(0x00B0)(NativeAccessSpecifierPublic)
	uint8                                         Pad_2C79[0x8];                                     // 0x0198(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TransformIn;                                       // 0x01A0(0x0060)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             LocalTransform;                                    // 0x0200(0x0060)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x0260(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AttributeName;                                     // 0x0270(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformCollectionAttributeDataflowNode) == 0x000010, "Wrong alignment on FTransformCollectionAttributeDataflowNode");
static_assert(sizeof(FTransformCollectionAttributeDataflowNode) == 0x000280, "Wrong size on FTransformCollectionAttributeDataflowNode");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, Collection) == 0x0000E8, "Member 'FTransformCollectionAttributeDataflowNode::Collection' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, TransformIn) == 0x0001A0, "Member 'FTransformCollectionAttributeDataflowNode::TransformIn' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, LocalTransform) == 0x000200, "Member 'FTransformCollectionAttributeDataflowNode::LocalTransform' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, GroupName) == 0x000260, "Member 'FTransformCollectionAttributeDataflowNode::GroupName' has a wrong offset!");
static_assert(offsetof(FTransformCollectionAttributeDataflowNode, AttributeName) == 0x000270, "Member 'FTransformCollectionAttributeDataflowNode::AttributeName' has a wrong offset!");

}


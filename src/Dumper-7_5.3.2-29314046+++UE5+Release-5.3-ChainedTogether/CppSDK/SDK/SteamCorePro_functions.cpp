#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SteamCorePro

#include "Basic.hpp"

#include "SteamCorePro_classes.hpp"
#include "SteamCorePro_parameters.hpp"


namespace SDK
{

// Function SteamCorePro.SteamCoreProAppsAsyncActionGetFileDetails.GetFileDetailsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProAppsAsyncActionGetFileDetails*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProAppsAsyncActionGetFileDetails* USteamCoreProAppsAsyncActionGetFileDetails::GetFileDetailsAsync(class UObject* WorldContextObject, const class FString& Filename, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProAppsAsyncActionGetFileDetails", "GetFileDetailsAsync");

	Params::SteamCoreProAppsAsyncActionGetFileDetails_GetFileDetailsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Filename = std::move(Filename);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProAppsAsyncActionGetFileDetails.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFileDetailsResult               Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProAppsAsyncActionGetFileDetails::HandleCallback(const struct FFileDetailsResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProAppsAsyncActionGetFileDetails", "HandleCallback");

	Params::SteamCoreProAppsAsyncActionGetFileDetails_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Dialog                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlay(const class FString& Dialog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlay");

	Params::SteamProFriends_ActivateGameOverlay Parms{};

	Parms.Dialog = std::move(Dialog);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlayInvitedialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlayInvitedialog(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlayInvitedialog");

	Params::SteamProFriends_ActivateGameOverlayInvitedialog Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlayInviteDialogConnectString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ConnectString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlayInviteDialogConnectString(const class FString& ConnectString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlayInviteDialogConnectString");

	Params::SteamProFriends_ActivateGameOverlayInviteDialogConnectString Parms{};

	Parms.ConnectString = std::move(ConnectString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlayToStore
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamOverlayToStoreFlag                Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlayToStore(int32 AppID, ESteamOverlayToStoreFlag Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlayToStore");

	Params::SteamProFriends_ActivateGameOverlayToStore Parms{};

	Parms.AppID = AppID;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlayToUser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Dialog                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlayToUser(const class FString& Dialog, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlayToUser");

	Params::SteamProFriends_ActivateGameOverlayToUser Parms{};

	Parms.Dialog = std::move(Dialog);
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.ActivateGameOverlayToWebPage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           URL                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamActivateGameOverlayToWebPageMode  Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::ActivateGameOverlayToWebPage(const class FString& URL, ESteamActivateGameOverlayToWebPageMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ActivateGameOverlayToWebPage");

	Params::SteamProFriends_ActivateGameOverlayToWebPage Parms{};

	Parms.URL = std::move(URL);
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.BHasEquippedProfileItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCommunityProfileItemType          ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::BHasEquippedProfileItem(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "BHasEquippedProfileItem");

	Params::SteamProFriends_BHasEquippedProfileItem Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.ItemType = ItemType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.ClearRichPresence
// (Final, Native, Static, Public, BlueprintCallable)

void USteamProFriends::ClearRichPresence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ClearRichPresence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.CloseClanChatWindowInSteam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::CloseClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "CloseClanChatWindowInSteam");

	Params::SteamProFriends_CloseClanChatWindowInSteam Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetChatMemberByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   User                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetChatMemberByIndex(const struct FSteamID& SteamIDClan, int32 User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetChatMemberByIndex");

	Params::SteamProFriends_GetChatMemberByIndex Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanActivityCounts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Online                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InGame                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Chatting                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::GetClanActivityCounts(const struct FSteamID& SteamIDClan, int32* Online, int32* InGame, int32* Chatting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanActivityCounts");

	Params::SteamProFriends_GetClanActivityCounts Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = Parms.Online;

	if (InGame != nullptr)
		*InGame = Parms.InGame;

	if (Chatting != nullptr)
		*Chatting = Parms.Chatting;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Clan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetClanByIndex(int32 Clan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanByIndex");

	Params::SteamProFriends_GetClanByIndex Parms{};

	Parms.Clan = Clan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanChatMemberCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetClanChatMemberCount(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanChatMemberCount");

	Params::SteamProFriends_GetClanChatMemberCount Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanChatMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MessageID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamChatEntryType                     ChatEntryType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDChatter                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetClanChatMessage(const struct FSteamID& SteamIDClanChat, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType, struct FSteamID* SteamIDChatter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanChatMessage");

	Params::SteamProFriends_GetClanChatMessage Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);
	Parms.MessageID = MessageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (ChatEntryType != nullptr)
		*ChatEntryType = Parms.ChatEntryType;

	if (SteamIDChatter != nullptr)
		*SteamIDChatter = std::move(Parms.SteamIDChatter);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetClanCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanCount");

	Params::SteamProFriends_GetClanCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetClanName(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanName");

	Params::SteamProFriends_GetClanName Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanOfficerByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Officer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetClanOfficerByIndex(const struct FSteamID& SteamIDClan, int32 Officer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanOfficerByIndex");

	Params::SteamProFriends_GetClanOfficerByIndex Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);
	Parms.Officer = Officer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanOfficerCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetClanOfficerCount(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanOfficerCount");

	Params::SteamProFriends_GetClanOfficerCount Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetClanOwner(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanOwner");

	Params::SteamProFriends_GetClanOwner Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetClanTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetClanTag(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetClanTag");

	Params::SteamProFriends_GetClanTag Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetCoplayFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   CoplayFriend                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetCoplayFriend(int32 CoplayFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetCoplayFriend");

	Params::SteamProFriends_GetCoplayFriend Parms{};

	Parms.CoplayFriend = CoplayFriend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetCoplayFriendCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetCoplayFriendCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetCoplayFriendCount");

	Params::SteamProFriends_GetCoplayFriendCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Ifriend                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ESteamFriendFlags>               Param_Flags                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetFriendByIndex(int32 Ifriend, const TArray<ESteamFriendFlags>& Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendByIndex");

	Params::SteamProFriends_GetFriendByIndex Parms{};

	Parms.Ifriend = Ifriend;
	Parms.Param_Flags = std::move(Param_Flags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendCoplayGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendCoplayGame(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendCoplayGame");

	Params::SteamProFriends_GetFriendCoplayGame Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendCoplayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendCoplayTime(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendCoplayTime");

	Params::SteamProFriends_GetFriendCoplayTime Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<ESteamFriendFlags>               Param_Flags                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendCount(const TArray<ESteamFriendFlags>& Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendCount");

	Params::SteamProFriends_GetFriendCount Parms{};

	Parms.Param_Flags = std::move(Param_Flags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendCountFromSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDSource                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendCountFromSource(const struct FSteamID& SteamIDSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendCountFromSource");

	Params::SteamProFriends_GetFriendCountFromSource Parms{};

	Parms.SteamIDSource = std::move(SteamIDSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendFromSourceByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDSource                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Ifriend                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProFriends::GetFriendFromSourceByIndex(const struct FSteamID& SteamIDSource, int32 Ifriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendFromSourceByIndex");

	Params::SteamProFriends_GetFriendFromSourceByIndex Parms{};

	Parms.SteamIDSource = std::move(SteamIDSource);
	Parms.Ifriend = Ifriend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendGamePlayed
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamGameID                     GameID                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           GameIP                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConnectionPort                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDLobby                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::GetFriendGamePlayed(const struct FSteamID& SteamIDFriend, struct FSteamGameID* GameID, class FString* GameIP, int32* ConnectionPort, int32* QueryPort, struct FSteamID* SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendGamePlayed");

	Params::SteamProFriends_GetFriendGamePlayed Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GameID != nullptr)
		*GameID = std::move(Parms.GameID);

	if (GameIP != nullptr)
		*GameIP = std::move(Parms.GameIP);

	if (ConnectionPort != nullptr)
		*ConnectionPort = Parms.ConnectionPort;

	if (QueryPort != nullptr)
		*QueryPort = Parms.QueryPort;

	if (SteamIDLobby != nullptr)
		*SteamIDLobby = std::move(Parms.SteamIDLobby);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendMessage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MessageID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamChatEntryType                     ChatEntryType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendMessage(const struct FSteamID& SteamIDFriend, int32 MessageID, class FString* Text, ESteamChatEntryType* ChatEntryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendMessage");

	Params::SteamProFriends_GetFriendMessage Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.MessageID = MessageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	if (ChatEntryType != nullptr)
		*ChatEntryType = Parms.ChatEntryType;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendPersonaName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetFriendPersonaName(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendPersonaName");

	Params::SteamProFriends_GetFriendPersonaName Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendPersonaNameHistory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   PersonaName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetFriendPersonaNameHistory(const struct FSteamID& SteamIDFriend, int32 PersonaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendPersonaNameHistory");

	Params::SteamProFriends_GetFriendPersonaNameHistory Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.PersonaName = PersonaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendPersonaState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamPersonaState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamPersonaState USteamProFriends::GetFriendPersonaState(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendPersonaState");

	Params::SteamProFriends_GetFriendPersonaState Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendRelationship
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamFriendRelationship                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamFriendRelationship USteamProFriends::GetFriendRelationship(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendRelationship");

	Params::SteamProFriends_GetFriendRelationship Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendRichPresence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetFriendRichPresence(const struct FSteamID& SteamIDFriend, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendRichPresence");

	Params::SteamProFriends_GetFriendRichPresence Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendRichPresenceKeyByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Key                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetFriendRichPresenceKeyByIndex(const struct FSteamID& SteamIDFriend, int32 Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendRichPresenceKeyByIndex");

	Params::SteamProFriends_GetFriendRichPresenceKeyByIndex Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendRichPresenceKeyCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendRichPresenceKeyCount(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendRichPresenceKeyCount");

	Params::SteamProFriends_GetFriendRichPresenceKeyCount Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendsGroupCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendsGroupCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendsGroupCount");

	Params::SteamProFriends_GetFriendsGroupCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendsGroupIDByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   FriendGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamFriendsGroupID             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamFriendsGroupID USteamProFriends::GetFriendsGroupIDByIndex(int32 FriendGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendsGroupIDByIndex");

	Params::SteamProFriends_GetFriendsGroupIDByIndex Parms{};

	Parms.FriendGroup = FriendGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendsGroupMembersCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamFriendsGroupID             FriendsGroupID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendsGroupMembersCount(const struct FSteamFriendsGroupID& FriendsGroupID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendsGroupMembersCount");

	Params::SteamProFriends_GetFriendsGroupMembersCount Parms{};

	Parms.FriendsGroupID = std::move(FriendsGroupID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendsGroupMembersList
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamFriendsGroupID             FriendsGroupID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamID>                 SteamIDMembers                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MembersCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::GetFriendsGroupMembersList(const struct FSteamFriendsGroupID& FriendsGroupID, TArray<struct FSteamID>* SteamIDMembers, int32 MembersCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendsGroupMembersList");

	Params::SteamProFriends_GetFriendsGroupMembersList Parms{};

	Parms.FriendsGroupID = std::move(FriendsGroupID);
	Parms.MembersCount = MembersCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SteamIDMembers != nullptr)
		*SteamIDMembers = std::move(Parms.SteamIDMembers);
}


// Function SteamCorePro.SteamProFriends.GetFriendsGroupName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamFriendsGroupID             FriendsGroupID                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetFriendsGroupName(const struct FSteamFriendsGroupID& FriendsGroupID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendsGroupName");

	Params::SteamProFriends_GetFriendsGroupName Parms{};

	Parms.FriendsGroupID = std::move(FriendsGroupID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetFriendSteamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetFriendSteamLevel(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetFriendSteamLevel");

	Params::SteamProFriends_GetFriendSteamLevel Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetLargeFriendAvatar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USteamProFriends::GetLargeFriendAvatar(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetLargeFriendAvatar");

	Params::SteamProFriends_GetLargeFriendAvatar Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetMediumFriendAvatar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USteamProFriends::GetMediumFriendAvatar(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetMediumFriendAvatar");

	Params::SteamProFriends_GetMediumFriendAvatar Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPersonaName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetPersonaName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPersonaName");

	Params::SteamProFriends_GetPersonaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPersonaName_Pure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetPersonaName_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPersonaName_Pure");

	Params::SteamProFriends_GetPersonaName_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPersonaState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamPersonaState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamPersonaState USteamProFriends::GetPersonaState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPersonaState");

	Params::SteamProFriends_GetPersonaState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPersonaState_Pure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESteamPersonaState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamPersonaState USteamProFriends::GetPersonaState_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPersonaState_Pure");

	Params::SteamProFriends_GetPersonaState_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPlayerNickname
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDPlayer                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetPlayerNickname(const struct FSteamID& SteamIDPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPlayerNickname");

	Params::SteamProFriends_GetPlayerNickname Parms{};

	Parms.SteamIDPlayer = std::move(SteamIDPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetPlayerNickname_Pure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         SteamIDPlayer                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetPlayerNickname_Pure(const struct FSteamID& SteamIDPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetPlayerNickname_Pure");

	Params::SteamProFriends_GetPlayerNickname_Pure Parms{};

	Parms.SteamIDPlayer = std::move(SteamIDPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetProfileItemPropertyString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCommunityProfileItemType          ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCommunityProfileItemProperty      Prop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProFriends::GetProfileItemPropertyString(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType, ESteamCommunityProfileItemProperty Prop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetProfileItemPropertyString");

	Params::SteamProFriends_GetProfileItemPropertyString Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.ItemType = ItemType;
	Parms.Prop = Prop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetProfileItemPropertyUint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCommunityProfileItemType          ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCommunityProfileItemProperty      Prop                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProFriends::GetProfileItemPropertyUint(const struct FSteamID& SteamID, ESteamCommunityProfileItemType ItemType, ESteamCommunityProfileItemProperty Prop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetProfileItemPropertyUint");

	Params::SteamProFriends_GetProfileItemPropertyUint Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.ItemType = ItemType;
	Parms.Prop = Prop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetSmallFriendAvatar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USteamProFriends::GetSmallFriendAvatar(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetSmallFriendAvatar");

	Params::SteamProFriends_GetSmallFriendAvatar Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetSteamFriends
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProFriends*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProFriends* USteamProFriends::GetSteamFriends()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetSteamFriends");

	Params::SteamProFriends_GetSteamFriends Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.GetUserRestrictions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<ESteamUserRestriction>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ESteamUserRestriction> USteamProFriends::GetUserRestrictions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "GetUserRestrictions");

	Params::SteamProFriends_GetUserRestrictions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.HasFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<ESteamFriendFlags>               Param_Flags                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::HasFriend(const struct FSteamID& SteamIDFriend, const TArray<ESteamFriendFlags>& Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "HasFriend");

	Params::SteamProFriends_HasFriend Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.Param_Flags = std::move(Param_Flags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.InviteUserToGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ConnectString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::InviteUserToGame(const struct FSteamID& SteamIDFriend, const class FString& ConnectString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "InviteUserToGame");

	Params::SteamProFriends_InviteUserToGame Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.ConnectString = std::move(ConnectString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.IsClanChatAdmin
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::IsClanChatAdmin(const struct FSteamID& SteamIDClanChat, const struct FSteamID& SteamIDUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "IsClanChatAdmin");

	Params::SteamProFriends_IsClanChatAdmin Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);
	Parms.SteamIDUser = std::move(SteamIDUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.IsClanChatWindowOpenInSteam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::IsClanChatWindowOpenInSteam(const struct FSteamID& SteamIDClanChat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "IsClanChatWindowOpenInSteam");

	Params::SteamProFriends_IsClanChatWindowOpenInSteam Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.IsClanOfficialGameGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::IsClanOfficialGameGroup(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "IsClanOfficialGameGroup");

	Params::SteamProFriends_IsClanOfficialGameGroup Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.IsClanPublic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::IsClanPublic(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "IsClanPublic");

	Params::SteamProFriends_IsClanPublic Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.IsUserInSource
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDSource                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::IsUserInSource(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDSource)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "IsUserInSource");

	Params::SteamProFriends_IsUserInSource Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.SteamIDSource = std::move(SteamIDSource);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.LeaveClanChatRoom
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::LeaveClanChatRoom(const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "LeaveClanChatRoom");

	Params::SteamProFriends_LeaveClanChatRoom Parms{};

	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.OpenClanChatWindowInSteam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::OpenClanChatWindowInSteam(const struct FSteamID& SteamIDClanChat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "OpenClanChatWindowInSteam");

	Params::SteamProFriends_OpenClanChatWindowInSteam Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.RegisterProtocolInOverlayBrowser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Protocol                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::RegisterProtocolInOverlayBrowser(const class FString& Protocol)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "RegisterProtocolInOverlayBrowser");

	Params::SteamProFriends_RegisterProtocolInOverlayBrowser Parms{};

	Parms.Protocol = std::move(Protocol);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.ReplyToFriendMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           MsgToSend                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::ReplyToFriendMessage(const struct FSteamID& SteamIDFriend, const class FString& MsgToSend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "ReplyToFriendMessage");

	Params::SteamProFriends_ReplyToFriendMessage Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);
	Parms.MsgToSend = std::move(MsgToSend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.RequestFriendRichPresence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::RequestFriendRichPresence(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "RequestFriendRichPresence");

	Params::SteamProFriends_RequestFriendRichPresence Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.RequestUserInformation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequireNameOnly                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::RequestUserInformation(const struct FSteamID& SteamIDUser, bool bRequireNameOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "RequestUserInformation");

	Params::SteamProFriends_RequestUserInformation Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.bRequireNameOnly = bRequireNameOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.SendClanChatMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDClanChat                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::SendClanChatMessage(const struct FSteamID& SteamIDClanChat, const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "SendClanChatMessage");

	Params::SteamProFriends_SendClanChatMessage Parms{};

	Parms.SteamIDClanChat = std::move(SteamIDClanChat);
	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.SetInGameVoiceSpeaking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bSpeaking                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::SetInGameVoiceSpeaking(const struct FSteamID& SteamIDUser, bool bSpeaking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "SetInGameVoiceSpeaking");

	Params::SteamProFriends_SetInGameVoiceSpeaking Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.bSpeaking = bSpeaking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.SetListenForFriendsMessages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInterceptEnabled                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::SetListenForFriendsMessages(bool bInterceptEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "SetListenForFriendsMessages");

	Params::SteamProFriends_SetListenForFriendsMessages Parms{};

	Parms.bInterceptEnabled = bInterceptEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.SetPlayedWith
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUserPlayedWith                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::SetPlayedWith(const struct FSteamID& SteamIDUserPlayedWith)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "SetPlayedWith");

	Params::SteamProFriends_SetPlayedWith Parms{};

	Parms.SteamIDUserPlayedWith = std::move(SteamIDUserPlayedWith);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.SetRichPresence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProFriends::SetRichPresence(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProFriends", "SetRichPresence");

	Params::SteamProFriends_SetRichPresence Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProFriends.DownloadClanActivityCounts
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSteamID>                 SteamIDClans                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProFriends::DownloadClanActivityCounts(const TDelegate<void(struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamID>& SteamIDClans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "DownloadClanActivityCounts");

	Params::SteamProFriends_DownloadClanActivityCounts Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDClans = std::move(SteamIDClans);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.EnumerateFollowingList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::EnumerateFollowingList(const TDelegate<void(struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful)>& Callback, int32 StartIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "EnumerateFollowingList");

	Params::SteamProFriends_EnumerateFollowingList Parms{};

	Parms.Callback = Callback;
	Parms.StartIndex = StartIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.GetFollowerCount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FFriendsGetFollowerCount& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::GetFollowerCount(const TDelegate<void(struct FFriendsGetFollowerCount& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "GetFollowerCount");

	Params::SteamProFriends_GetFollowerCount Parms{};

	Parms.Callback = Callback;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.IsFollowing
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FFriendsIsFollowing& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::IsFollowing(const TDelegate<void(struct FFriendsIsFollowing& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "IsFollowing");

	Params::SteamProFriends_IsFollowing Parms{};

	Parms.Callback = Callback;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.JoinClanChatRoom
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::JoinClanChatRoom(const TDelegate<void(struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "JoinClanChatRoom");

	Params::SteamProFriends_JoinClanChatRoom Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.RequestClanOfficerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FClanOfficerListResponse& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::RequestClanOfficerList(const TDelegate<void(struct FClanOfficerListResponse& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "RequestClanOfficerList");

	Params::SteamProFriends_RequestClanOfficerList Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.RequestEquippedProfileItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FEquippedProfileItems& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProFriends::RequestEquippedProfileItems(const TDelegate<void(struct FEquippedProfileItems& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "RequestEquippedProfileItems");

	Params::SteamProFriends_RequestEquippedProfileItems Parms{};

	Parms.Callback = Callback;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProFriends.SetPersonaName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSetPersonaNameResponse& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProFriends::SetPersonaName(const TDelegate<void(struct FSetPersonaNameResponse& Data, bool bWasSuccessful)>& Callback, const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProFriends", "SetPersonaName");

	Params::SteamProFriends_SetPersonaName Parms{};

	Parms.Callback = Callback;
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionSetPersonaName.SetPersonaNameAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionSetPersonaName*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionSetPersonaName* USteamCoreProFriendsAsyncActionSetPersonaName::SetPersonaNameAsync(class UObject* WorldContextObject, const class FString& Param_Name, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionSetPersonaName", "SetPersonaNameAsync");

	Params::SteamCoreProFriendsAsyncActionSetPersonaName_SetPersonaNameAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Param_Name = std::move(Param_Name);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionSetPersonaName.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSetPersonaNameResponse          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionSetPersonaName::HandleCallback(const struct FSetPersonaNameResponse& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionSetPersonaName", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionSetPersonaName_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionDownloadClanActivityCounts.DownloadClanActivityCountsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSteamID>                 SteamIDClans                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionDownloadClanActivityCounts*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionDownloadClanActivityCounts* USteamCoreProFriendsAsyncActionDownloadClanActivityCounts::DownloadClanActivityCountsAsync(class UObject* WorldContextObject, const TArray<struct FSteamID>& SteamIDClans, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionDownloadClanActivityCounts", "DownloadClanActivityCountsAsync");

	Params::SteamCoreProFriendsAsyncActionDownloadClanActivityCounts_DownloadClanActivityCountsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamIDClans = std::move(SteamIDClans);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionDownloadClanActivityCounts.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FDownloadClanActivityCountsResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionDownloadClanActivityCounts::HandleCallback(const struct FDownloadClanActivityCountsResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionDownloadClanActivityCounts", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionDownloadClanActivityCounts_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionRequestClanOfficerList.RequestClanOfficerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionRequestClanOfficerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionRequestClanOfficerList* USteamCoreProFriendsAsyncActionRequestClanOfficerList::RequestClanOfficerListAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionRequestClanOfficerList", "RequestClanOfficerListAsync");

	Params::SteamCoreProFriendsAsyncActionRequestClanOfficerList_RequestClanOfficerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamIDClan = std::move(SteamIDClan);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionRequestClanOfficerList.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FClanOfficerListResponse         Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionRequestClanOfficerList::HandleCallback(const struct FClanOfficerListResponse& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionRequestClanOfficerList", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionRequestClanOfficerList_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionJoinClanChatRoom.JoinClanChatRoomAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionJoinClanChatRoom*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionJoinClanChatRoom* USteamCoreProFriendsAsyncActionJoinClanChatRoom::JoinClanChatRoomAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDClan, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionJoinClanChatRoom", "JoinClanChatRoomAsync");

	Params::SteamCoreProFriendsAsyncActionJoinClanChatRoom_JoinClanChatRoomAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamIDClan = std::move(SteamIDClan);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionJoinClanChatRoom.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FJoinClanChatRoomCompletionResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionJoinClanChatRoom::HandleCallback(const struct FJoinClanChatRoomCompletionResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionJoinClanChatRoom", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionJoinClanChatRoom_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionEnumerateFollowingList.EnumerateFollowingListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionEnumerateFollowingList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionEnumerateFollowingList* USteamCoreProFriendsAsyncActionEnumerateFollowingList::EnumerateFollowingListAsync(class UObject* WorldContextObject, int32 StartIndex, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionEnumerateFollowingList", "EnumerateFollowingListAsync");

	Params::SteamCoreProFriendsAsyncActionEnumerateFollowingList_EnumerateFollowingListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartIndex = StartIndex;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionEnumerateFollowingList.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFriendsEnumerateFollowingList   Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionEnumerateFollowingList::HandleCallback(const struct FFriendsEnumerateFollowingList& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionEnumerateFollowingList", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionEnumerateFollowingList_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionIsFollowing.IsFollowingAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionIsFollowing*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionIsFollowing* USteamCoreProFriendsAsyncActionIsFollowing::IsFollowingAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionIsFollowing", "IsFollowingAsync");

	Params::SteamCoreProFriendsAsyncActionIsFollowing_IsFollowingAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamID = std::move(SteamID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionIsFollowing.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFriendsIsFollowing              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionIsFollowing::HandleCallback(const struct FFriendsIsFollowing& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionIsFollowing", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionIsFollowing_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionGetFollowerCount.GetFollowerCountAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionGetFollowerCount*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionGetFollowerCount* USteamCoreProFriendsAsyncActionGetFollowerCount::GetFollowerCountAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionGetFollowerCount", "GetFollowerCountAsync");

	Params::SteamCoreProFriendsAsyncActionGetFollowerCount_GetFollowerCountAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamID = std::move(SteamID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionGetFollowerCount.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFriendsGetFollowerCount         Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFriendsAsyncActionGetFollowerCount::HandleCallback(const struct FFriendsGetFollowerCount& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionGetFollowerCount", "HandleCallback");

	Params::SteamCoreProFriendsAsyncActionGetFollowerCount_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionRequestUserInformation.RequestUserInformationAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bRequireNameOnly                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFriendsAsyncActionRequestUserInformation*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFriendsAsyncActionRequestUserInformation* USteamCoreProFriendsAsyncActionRequestUserInformation::RequestUserInformationAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDUser, bool bRequireNameOnly, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFriendsAsyncActionRequestUserInformation", "RequestUserInformationAsync");

	Params::SteamCoreProFriendsAsyncActionRequestUserInformation_RequestUserInformationAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.bRequireNameOnly = bRequireNameOnly;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFriendsAsyncActionRequestUserInformation.HandleCallback
// (Final, Native, Public)

void USteamCoreProFriendsAsyncActionRequestUserInformation::HandleCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFriendsAsyncActionRequestUserInformation", "HandleCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServerStats.GetSteamGameServerStats
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProGameServerStats*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProGameServerStats* USteamProGameServerStats::GetSteamGameServerStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProGameServerStats", "GetSteamGameServerStats");

	Params::SteamProGameServerStats_GetSteamGameServerStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.ClearUserAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::ClearUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "ClearUserAchievement");

	Params::SteamProGameServerStats_ClearUserAchievement Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.GetUserAchievement
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "GetUserAchievement");

	Params::SteamProGameServerStats_GetUserAchievement Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.GetUserStatFloat
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "GetUserStatFloat");

	Params::SteamProGameServerStats_GetUserStatFloat Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.GetUserStatInt
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::GetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "GetUserStatInt");

	Params::SteamProGameServerStats_GetUserStatInt Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.ServerRequestUserStats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGSStatsReceived& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServerStats::ServerRequestUserStats(const TDelegate<void(struct FGSStatsReceived& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "ServerRequestUserStats");

	Params::SteamProGameServerStats_ServerRequestUserStats Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDUser = std::move(SteamIDUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServerStats.ServerStoreUserStats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGSStatsStored& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServerStats::ServerStoreUserStats(const TDelegate<void(struct FGSStatsStored& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "ServerStoreUserStats");

	Params::SteamProGameServerStats_ServerStoreUserStats Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDUser = std::move(SteamIDUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServerStats.SetUserAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::SetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "SetUserAchievement");

	Params::SteamProGameServerStats_SetUserAchievement Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.SetUserStatFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::SetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "SetUserStatFloat");

	Params::SteamProGameServerStats_SetUserStatFloat Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.SetUserStatInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::SetUserStatInt(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32 Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "SetUserStatInt");

	Params::SteamProGameServerStats_SetUserStatInt Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServerStats.UpdateUserAvgRateStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CountThisSession                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SessionLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServerStats::UpdateUserAvgRateStat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float CountThisSession, float SessionLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServerStats", "UpdateUserAvgRateStat");

	Params::SteamProGameServerStats_UpdateUserAvgRateStat Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);
	Parms.CountThisSession = CountThisSession;
	Parms.SessionLength = SessionLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.BNewDataAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::BNewDataAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "BNewDataAvailable");

	Params::SteamProInput_BNewDataAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.BWaitForData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bWaitForever                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::BWaitForData(bool bWaitForever, int32 Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "BWaitForData");

	Params::SteamProInput_BWaitForData Parms{};

	Parms.bWaitForever = bWaitForever;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetSessionInputConfigurationSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<ESteamCoreInputConfigurationEnableType>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<ESteamCoreInputConfigurationEnableType> USteamProInput::GetSessionInputConfigurationSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "GetSessionInputConfigurationSettings");

	Params::SteamProInput_GetSessionInputConfigurationSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetSteamInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProInput*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProInput* USteamProInput::GetSteamInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "GetSteamInput");

	Params::SteamProInput_GetSteamInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetStringForAnalogActionName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInputAnalogActionHandle         ActionHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetStringForAnalogActionName(const struct FInputAnalogActionHandle& ActionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "GetStringForAnalogActionName");

	Params::SteamProInput_GetStringForAnalogActionName Parms{};

	Parms.ActionHandle = std::move(ActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetStringForDigitalActionName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInputDigitalActionHandle        ActionHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetStringForDigitalActionName(const struct FInputDigitalActionHandle& ActionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "GetStringForDigitalActionName");

	Params::SteamProInput_GetStringForDigitalActionName Parms{};

	Parms.ActionHandle = std::move(ActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.SetDualSenseTriggerEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     InputHandle                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FScePadTriggerEffectCommand      R2                                                     (Parm, NativeAccessSpecifierPublic)
// struct FScePadTriggerEffectCommand      L2                                                     (Parm, NativeAccessSpecifierPublic)

void USteamProInput::SetDualSenseTriggerEffect(const struct FInputHandle& InputHandle, const struct FScePadTriggerEffectCommand& R2, const struct FScePadTriggerEffectCommand& L2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInput", "SetDualSenseTriggerEffect");

	Params::SteamProInput_SetDualSenseTriggerEffect Parms{};

	Parms.InputHandle = std::move(InputHandle);
	Parms.R2 = std::move(R2);
	Parms.L2 = std::move(L2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.ActivateActionSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ActionSetHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInput::ActivateActionSet(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "ActivateActionSet");

	Params::SteamProInput_ActivateActionSet Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ActionSetHandle = std::move(ActionSetHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.ActivateActionSetLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ActionSetLayerHandle                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInput::ActivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "ActivateActionSetLayer");

	Params::SteamProInput_ActivateActionSetLayer Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ActionSetLayerHandle = std::move(ActionSetLayerHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.DeactivateActionSetLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ActionSetLayerHandle                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInput::DeactivateActionSetLayer(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetLayerHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "DeactivateActionSetLayer");

	Params::SteamProInput_DeactivateActionSetLayer Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ActionSetLayerHandle = std::move(ActionSetLayerHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.DeactivateAllActionSetLayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInput::DeactivateAllActionSetLayers(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "DeactivateAllActionSetLayers");

	Params::SteamProInput_DeactivateAllActionSetLayers Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.GetActionOriginFromXboxOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProXboxOrigin                 Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreProInputActionOrigin          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamCoreProInputActionOrigin USteamProInput::GetActionOriginFromXboxOrigin(const struct FInputHandle& Handle, ESteamCoreProXboxOrigin Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetActionOriginFromXboxOrigin");

	Params::SteamProInput_GetActionOriginFromXboxOrigin Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetActionSetHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ActionSetName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputActionSetHandle USteamProInput::GetActionSetHandle(const class FString& ActionSetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetActionSetHandle");

	Params::SteamProInput_GetActionSetHandle Parms{};

	Parms.ActionSetName = std::move(ActionSetName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetActiveActionSetLayers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FInputActionSetHandle>    Data                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetActiveActionSetLayers(const struct FInputHandle& Handle, TArray<struct FInputActionSetHandle>* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetActiveActionSetLayers");

	Params::SteamProInput_GetActiveActionSetLayers Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetAnalogActionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputAnalogActionHandle         AnalogActionHandle                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputAnalogActionData           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputAnalogActionData USteamProInput::GetAnalogActionData(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& AnalogActionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetAnalogActionData");

	Params::SteamProInput_GetAnalogActionData Parms{};

	Parms.Handle = std::move(Handle);
	Parms.AnalogActionHandle = std::move(AnalogActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetAnalogActionHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PszActionName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputAnalogActionHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputAnalogActionHandle USteamProInput::GetAnalogActionHandle(const class FString& PszActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetAnalogActionHandle");

	Params::SteamProInput_GetAnalogActionHandle Parms{};

	Parms.PszActionName = std::move(PszActionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetAnalogActionOrigins
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ActionSetHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputAnalogActionHandle         AnalogActionHandle                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<ESteamCoreProInputActionOrigin>  OriginsOut                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetAnalogActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputAnalogActionHandle& AnalogActionHandle, TArray<ESteamCoreProInputActionOrigin>* OriginsOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetAnalogActionOrigins");

	Params::SteamProInput_GetAnalogActionOrigins Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ActionSetHandle = std::move(ActionSetHandle);
	Parms.AnalogActionHandle = std::move(AnalogActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OriginsOut != nullptr)
		*OriginsOut = std::move(Parms.OriginsOut);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetConnectedControllers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FInputHandle>             OutHandles                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetConnectedControllers(TArray<struct FInputHandle>* OutHandles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetConnectedControllers");

	Params::SteamProInput_GetConnectedControllers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandles != nullptr)
		*OutHandles = std::move(Parms.OutHandles);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetControllerForGamepadIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputHandle                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputHandle USteamProInput::GetControllerForGamepadIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetControllerForGamepadIndex");

	Params::SteamProInput_GetControllerForGamepadIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetCurrentActionSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputActionSetHandle USteamProInput::GetCurrentActionSet(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetCurrentActionSet");

	Params::SteamProInput_GetCurrentActionSet Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetDeviceBindingRevision
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Major                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Minor                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::GetDeviceBindingRevision(const struct FInputHandle& Handle, int32* Major, int32* Minor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetDeviceBindingRevision");

	Params::SteamProInput_GetDeviceBindingRevision Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Major != nullptr)
		*Major = Parms.Major;

	if (Minor != nullptr)
		*Minor = Parms.Minor;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetDigitalActionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputDigitalActionHandle        DigitalActionHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputDigitalActionData          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputDigitalActionData USteamProInput::GetDigitalActionData(const struct FInputHandle& Handle, const struct FInputDigitalActionHandle& DigitalActionHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetDigitalActionData");

	Params::SteamProInput_GetDigitalActionData Parms{};

	Parms.Handle = std::move(Handle);
	Parms.DigitalActionHandle = std::move(DigitalActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetDigitalActionHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PszActionName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputDigitalActionHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputDigitalActionHandle USteamProInput::GetDigitalActionHandle(const class FString& PszActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetDigitalActionHandle");

	Params::SteamProInput_GetDigitalActionHandle Parms{};

	Parms.PszActionName = std::move(PszActionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetDigitalActionOrigins
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputActionSetHandle            ActionSetHandle                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputDigitalActionHandle        DigitalActionHandle                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<ESteamCoreProInputActionOrigin>  OriginsOut                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetDigitalActionOrigins(const struct FInputHandle& Handle, const struct FInputActionSetHandle& ActionSetHandle, const struct FInputDigitalActionHandle& DigitalActionHandle, TArray<ESteamCoreProInputActionOrigin>* OriginsOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetDigitalActionOrigins");

	Params::SteamProInput_GetDigitalActionOrigins Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ActionSetHandle = std::move(ActionSetHandle);
	Parms.DigitalActionHandle = std::move(DigitalActionHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OriginsOut != nullptr)
		*OriginsOut = std::move(Parms.OriginsOut);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetGamepadIndexForController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetGamepadIndexForController(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetGamepadIndexForController");

	Params::SteamProInput_GetGamepadIndexForController Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetGlyphForActionOrigin_Legacy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamCoreProInputActionOrigin          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetGlyphForActionOrigin_Legacy(ESteamCoreProInputActionOrigin Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetGlyphForActionOrigin_Legacy");

	Params::SteamProInput_GetGlyphForActionOrigin_Legacy Parms{};

	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetGlyphForXboxOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamCoreProXboxOrigin                 Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetGlyphForXboxOrigin(ESteamCoreProXboxOrigin Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetGlyphForXboxOrigin");

	Params::SteamProInput_GetGlyphForXboxOrigin Parms{};

	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetInputTypeForHandle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProInputType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamCoreProInputType USteamProInput::GetInputTypeForHandle(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetInputTypeForHandle");

	Params::SteamProInput_GetInputTypeForHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetMotionData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputMotionData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInputMotionData USteamProInput::GetMotionData(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetMotionData");

	Params::SteamProInput_GetMotionData Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetRemotePlaySessionID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInput::GetRemotePlaySessionID(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetRemotePlaySessionID");

	Params::SteamProInput_GetRemotePlaySessionID Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetStringForActionOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamCoreProInputActionOrigin          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetStringForActionOrigin(ESteamCoreProInputActionOrigin Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetStringForActionOrigin");

	Params::SteamProInput_GetStringForActionOrigin Parms{};

	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.GetStringForXboxOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamCoreProXboxOrigin                 Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProInput::GetStringForXboxOrigin(ESteamCoreProXboxOrigin Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "GetStringForXboxOrigin");

	Params::SteamProInput_GetStringForXboxOrigin Parms{};

	Parms.Origin = Origin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "Init");

	Params::SteamProInput_Init Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.Legacy_TriggerHapticPulse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProControllerPad              TargetPad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DurationMicroSec                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProInput::Legacy_TriggerHapticPulse(const struct FInputHandle& Handle, ESteamCoreProControllerPad TargetPad, uint8 DurationMicroSec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "Legacy_TriggerHapticPulse");

	Params::SteamProInput_Legacy_TriggerHapticPulse Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TargetPad = TargetPad;
	Parms.DurationMicroSec = DurationMicroSec;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.Legacy_TriggerRepeatedHapticPulse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProControllerPad              TargetPad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DurationMicroSec                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OffMicroSec                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Repeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Param_Flags                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProInput::Legacy_TriggerRepeatedHapticPulse(const struct FInputHandle& Handle, ESteamCoreProControllerPad TargetPad, uint8 DurationMicroSec, uint8 OffMicroSec, uint8 Repeat, uint8 Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "Legacy_TriggerRepeatedHapticPulse");

	Params::SteamProInput_Legacy_TriggerRepeatedHapticPulse Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TargetPad = TargetPad;
	Parms.DurationMicroSec = DurationMicroSec;
	Parms.OffMicroSec = OffMicroSec;
	Parms.Repeat = Repeat;
	Parms.Param_Flags = Param_Flags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.SetLEDColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   ColorR                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ColorG                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ColorB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreProInputLEDFlag               Param_Flags                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProInput::SetLEDColor(const struct FInputHandle& Handle, uint8 ColorR, uint8 ColorG, uint8 ColorB, ESteamCoreProInputLEDFlag Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "SetLEDColor");

	Params::SteamProInput_SetLEDColor Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ColorR = ColorR;
	Parms.ColorG = ColorG;
	Parms.ColorB = ColorB;
	Parms.Param_Flags = Param_Flags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.ShowBindingPanel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::ShowBindingPanel(const struct FInputHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "ShowBindingPanel");

	Params::SteamProInput_ShowBindingPanel Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.Shutdown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInput::Shutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "Shutdown");

	Params::SteamProInput_Shutdown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.StopAnalogActionMomentum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FInputAnalogActionHandle         EAction                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInput::StopAnalogActionMomentum(const struct FInputHandle& Handle, const struct FInputAnalogActionHandle& EAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "StopAnalogActionMomentum");

	Params::SteamProInput_StopAnalogActionMomentum Parms{};

	Parms.Handle = std::move(Handle);
	Parms.EAction = std::move(EAction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInput.TranslateActionOrigin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamCoreProInputType                  DestinationInputType                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreProInputActionOrigin          SourceOrigin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreProInputActionOrigin          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamCoreProInputActionOrigin USteamProInput::TranslateActionOrigin(ESteamCoreProInputType DestinationInputType, ESteamCoreProInputActionOrigin SourceOrigin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "TranslateActionOrigin");

	Params::SteamProInput_TranslateActionOrigin Parms{};

	Parms.DestinationInputType = DestinationInputType;
	Parms.SourceOrigin = SourceOrigin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInput.TriggerVibration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FInputHandle                     Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   LeftSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   RightSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProInput::TriggerVibration(const struct FInputHandle& Handle, uint8 LeftSpeed, uint8 RightSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInput", "TriggerVibration");

	Params::SteamProInput_TriggerVibration Parms{};

	Parms.Handle = std::move(Handle);
	Parms.LeftSpeed = LeftSpeed;
	Parms.RightSpeed = RightSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInventory.AddPromoItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemDef                    ItemDef                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::AddPromoItem(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ItemDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "AddPromoItem");

	Params::SteamProInventory_AddPromoItem Parms{};

	Parms.ItemDef = std::move(ItemDef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.AddPromoItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ItemDefs                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::AddPromoItems(struct FSteamInventoryResult* OutResult, const TArray<struct FSteamItemDef>& ItemDefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "AddPromoItems");

	Params::SteamProInventory_AddPromoItems Parms{};

	Parms.ItemDefs = std::move(ItemDefs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.CheckResultSteamID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDExpected                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::CheckResultSteamID(const struct FSteamInventoryResult& Handle, const struct FSteamID& SteamIDExpected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "CheckResultSteamID");

	Params::SteamProInventory_CheckResultSteamID Parms{};

	Parms.Handle = std::move(Handle);
	Parms.SteamIDExpected = std::move(SteamIDExpected);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.ConsumeItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemConsume                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::ConsumeItem(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemConsume, int32 Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "ConsumeItem");

	Params::SteamProInventory_ConsumeItem Parms{};

	Parms.ItemConsume = std::move(ItemConsume);
	Parms.Quantity = Quantity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.DeserializeResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           Buffer                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bReservedMustBeFalse                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::DeserializeResult(struct FSteamInventoryResult* Result, const TArray<uint8>& Buffer, bool bReservedMustBeFalse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "DeserializeResult");

	Params::SteamProInventory_DeserializeResult Parms{};

	Parms.Buffer = std::move(Buffer);
	Parms.bReservedMustBeFalse = bReservedMustBeFalse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.DestroyResult
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInventory::DestroyResult(const struct FSteamInventoryResult& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "DestroyResult");

	Params::SteamProInventory_DestroyResult Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInventory.ExchangeItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ArrayGenerate                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           ArrayGenerateQuantity                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemInstanceID>     ArrayDestroy                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           ArrayDestroyQuantity                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::ExchangeItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ArrayGenerate, const TArray<int32>& ArrayGenerateQuantity, const TArray<struct FSteamItemInstanceID>& ArrayDestroy, const TArray<int32>& ArrayDestroyQuantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "ExchangeItems");

	Params::SteamProInventory_ExchangeItems Parms{};

	Parms.ArrayGenerate = std::move(ArrayGenerate);
	Parms.ArrayGenerateQuantity = std::move(ArrayGenerateQuantity);
	Parms.ArrayDestroy = std::move(ArrayDestroy);
	Parms.ArrayDestroyQuantity = std::move(ArrayDestroyQuantity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GenerateItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ItemDefs                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Quantity                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GenerateItems(struct FSteamInventoryResult* Result, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GenerateItems");

	Params::SteamProInventory_GenerateItems Parms{};

	Parms.ItemDefs = std::move(ItemDefs);
	Parms.Quantity = std::move(Quantity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetAllItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetAllItems(struct FSteamInventoryResult* Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetAllItems");

	Params::SteamProInventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Handle != nullptr)
		*Handle = std::move(Parms.Handle);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetEligiblePromoItemDefinitionIDs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ItemDefs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetEligiblePromoItemDefinitionIDs(const struct FSteamID& SteamID, TArray<struct FSteamItemDef>* ItemDefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetEligiblePromoItemDefinitionIDs");

	Params::SteamProInventory_GetEligiblePromoItemDefinitionIDs Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemDefs != nullptr)
		*ItemDefs = std::move(Parms.ItemDefs);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetItemDefinitionIDs
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSteamItemDef>            ItemDefs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetItemDefinitionIDs(TArray<struct FSteamItemDef>* ItemDefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetItemDefinitionIDs");

	Params::SteamProInventory_GetItemDefinitionIDs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemDefs != nullptr)
		*ItemDefs = std::move(Parms.ItemDefs);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetItemDefinitionProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamItemDef                    ItemDef                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetItemDefinitionProperty(const struct FSteamItemDef& ItemDef, const class FString& PropertyName, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetItemDefinitionProperty");

	Params::SteamProInventory_GetItemDefinitionProperty Parms{};

	Parms.ItemDef = std::move(ItemDef);
	Parms.PropertyName = std::move(PropertyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetItemPrice
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamItemDef                    ItemDef                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Price                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BasePrice                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetItemPrice(const struct FSteamItemDef& ItemDef, int32* Price, int32* BasePrice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetItemPrice");

	Params::SteamProInventory_GetItemPrice Parms{};

	Parms.ItemDef = std::move(ItemDef);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Price != nullptr)
		*Price = Parms.Price;

	if (BasePrice != nullptr)
		*BasePrice = Parms.BasePrice;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetItemsByID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            InventoryResult                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemInstanceID>     InstanceIDs                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetItemsByID(struct FSteamInventoryResult* InventoryResult, const TArray<struct FSteamItemInstanceID>& InstanceIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetItemsByID");

	Params::SteamProInventory_GetItemsByID Parms{};

	Parms.InstanceIDs = std::move(InstanceIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InventoryResult != nullptr)
		*InventoryResult = std::move(Parms.InventoryResult);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetItemsWithPrices
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSteamItemDef>            ItemDefs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Prices                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           BasePrices                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetItemsWithPrices(TArray<struct FSteamItemDef>* ItemDefs, TArray<int32>* Prices, TArray<int32>* BasePrices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetItemsWithPrices");

	Params::SteamProInventory_GetItemsWithPrices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemDefs != nullptr)
		*ItemDefs = std::move(Parms.ItemDefs);

	if (Prices != nullptr)
		*Prices = std::move(Parms.Prices);

	if (BasePrices != nullptr)
		*BasePrices = std::move(Parms.BasePrices);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetNumItemsWithPrices
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInventory::GetNumItemsWithPrices()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetNumItemsWithPrices");

	Params::SteamProInventory_GetNumItemsWithPrices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetResultItemProperty
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ItemIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetResultItemProperty(const struct FSteamInventoryResult& Handle, int32 ItemIndex, const class FString& PropertyName, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetResultItemProperty");

	Params::SteamProInventory_GetResultItemProperty Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemIndex = ItemIndex;
	Parms.PropertyName = std::move(PropertyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetResultItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDetails>        Items                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GetResultItems(const struct FSteamInventoryResult& Handle, TArray<struct FSteamItemDetails>* Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetResultItems");

	Params::SteamProInventory_GetResultItems Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Items != nullptr)
		*Items = std::move(Parms.Items);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetResultStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamResult                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamResult USteamProInventory::GetResultStatus(const struct FSteamInventoryResult& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetResultStatus");

	Params::SteamProInventory_GetResultStatus Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetResultTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProInventory::GetResultTimestamp(const struct FSteamInventoryResult& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetResultTimestamp");

	Params::SteamProInventory_GetResultTimestamp Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GetSteamInventory
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProInventory*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProInventory* USteamProInventory::GetSteamInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GetSteamInventory");

	Params::SteamProInventory_GetSteamInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.GrantPromoItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::GrantPromoItems(struct FSteamInventoryResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "GrantPromoItems");

	Params::SteamProInventory_GrantPromoItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.LoadItemDefinitions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::LoadItemDefinitions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "LoadItemDefinitions");

	Params::SteamProInventory_LoadItemDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.RemoveProperty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemId                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::RemoveProperty(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "RemoveProperty");

	Params::SteamProInventory_RemoveProperty Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemId = std::move(ItemId);
	Parms.PropertyName = std::move(PropertyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SerializeResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           Buffer                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SerializeResult(const struct FSteamInventoryResult& Handle, TArray<uint8>* Buffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SerializeResult");

	Params::SteamProInventory_SerializeResult Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Buffer != nullptr)
		*Buffer = std::move(Parms.Buffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SetPropertyBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemId                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SetPropertyBool(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SetPropertyBool");

	Params::SteamProInventory_SetPropertyBool Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemId = std::move(ItemId);
	Parms.PropertyName = std::move(PropertyName);
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SetPropertyFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemId                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SetPropertyFloat(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SetPropertyFloat");

	Params::SteamProInventory_SetPropertyFloat Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemId = std::move(ItemId);
	Parms.PropertyName = std::move(PropertyName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SetPropertyInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemId                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SetPropertyInt(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SetPropertyInt");

	Params::SteamProInventory_SetPropertyInt Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemId = std::move(ItemId);
	Parms.PropertyName = std::move(PropertyName);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SetPropertyString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemId                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PropertyName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SetPropertyString(const struct FSteamInventoryUpdateHandle& Handle, const struct FSteamItemInstanceID& ItemId, const class FString& PropertyName, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SetPropertyString");

	Params::SteamProInventory_SetPropertyString Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ItemId = std::move(ItemId);
	Parms.PropertyName = std::move(PropertyName);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.StartUpdateProperties
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamInventoryUpdateHandle USteamProInventory::StartUpdateProperties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "StartUpdateProperties");

	Params::SteamProInventory_StartUpdateProperties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.SubmitUpdateProperties
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamInventoryResult            ResultHandle                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::SubmitUpdateProperties(const struct FSteamInventoryUpdateHandle& Handle, struct FSteamInventoryResult* ResultHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "SubmitUpdateProperties");

	Params::SteamProInventory_SubmitUpdateProperties Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResultHandle != nullptr)
		*ResultHandle = std::move(Parms.ResultHandle);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.TransferItemQuantity
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemIDSource                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Quantity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             ItemIDDest                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::TransferItemQuantity(struct FSteamInventoryResult* Result, const struct FSteamItemInstanceID& ItemIDSource, int32 Quantity, const struct FSteamItemInstanceID& ItemIDDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "TransferItemQuantity");

	Params::SteamProInventory_TransferItemQuantity Parms{};

	Parms.ItemIDSource = std::move(ItemIDSource);
	Parms.Quantity = Quantity;
	Parms.ItemIDDest = std::move(ItemIDDest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.TriggerItemDrop
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryResult            Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemDef                    ListDefinition                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProInventory::TriggerItemDrop(struct FSteamInventoryResult* Result, const struct FSteamItemDef& ListDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProInventory", "TriggerItemDrop");

	Params::SteamProInventory_TriggerItemDrop Parms{};

	Parms.ListDefinition = std::move(ListDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProInventory.RequestEligiblePromoItemDefinitionsIDs
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProInventory::RequestEligiblePromoItemDefinitionsIDs(const TDelegate<void(struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInventory", "RequestEligiblePromoItemDefinitionsIDs");

	Params::SteamProInventory_RequestEligiblePromoItemDefinitionsIDs Parms{};

	Parms.Callback = Callback;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInventory.RequestPrices
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProInventory::RequestPrices(const TDelegate<void(struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInventory", "RequestPrices");

	Params::SteamProInventory_RequestPrices Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProInventory.StartPurchase
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ItemDefs                                               (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Quantity                                               (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProInventory::StartPurchase(const TDelegate<void(struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProInventory", "StartPurchase");

	Params::SteamProInventory_StartPurchase Parms{};

	Parms.Callback = Callback;
	Parms.ItemDefs = std::move(ItemDefs);
	Parms.Quantity = std::move(Quantity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs.RequestEligiblePromoItemDefinitionsIDsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs* USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs::RequestEligiblePromoItemDefinitionsIDsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs", "RequestEligiblePromoItemDefinitionsIDsAsync");

	Params::SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs_RequestEligiblePromoItemDefinitionsIDsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamID = std::move(SteamID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSteamInventoryEligiblePromoItemDefIDsData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs::HandleCallback(const struct FSteamInventoryEligiblePromoItemDefIDs& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs", "HandleCallback");

	Params::SteamCoreProInventoryAsyncActionRequestEligiblePromoItemDefinitionsIDs_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionRequestPricesResult.RequestPricesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProInventoryAsyncActionRequestPricesResult*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProInventoryAsyncActionRequestPricesResult* USteamCoreProInventoryAsyncActionRequestPricesResult::RequestPricesAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProInventoryAsyncActionRequestPricesResult", "RequestPricesAsync");

	Params::SteamCoreProInventoryAsyncActionRequestPricesResult_RequestPricesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionRequestPricesResult.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSteamInventoryRequestPricesResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProInventoryAsyncActionRequestPricesResult::HandleCallback(const struct FSteamInventoryRequestPricesResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProInventoryAsyncActionRequestPricesResult", "HandleCallback");

	Params::SteamCoreProInventoryAsyncActionRequestPricesResult_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionStartPurchaseResult.StartPurchaseAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSteamItemDef>            ItemDefs                                               (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Quantity                                               (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProInventoryAsyncActionStartPurchaseResult*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProInventoryAsyncActionStartPurchaseResult* USteamCoreProInventoryAsyncActionStartPurchaseResult::StartPurchaseAsync(class UObject* WorldContextObject, const TArray<struct FSteamItemDef>& ItemDefs, const TArray<int32>& Quantity, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProInventoryAsyncActionStartPurchaseResult", "StartPurchaseAsync");

	Params::SteamCoreProInventoryAsyncActionStartPurchaseResult_StartPurchaseAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ItemDefs = std::move(ItemDefs);
	Parms.Quantity = std::move(Quantity);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProInventoryAsyncActionStartPurchaseResult.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSteamInventoryStartPurchaseResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProInventoryAsyncActionStartPurchaseResult::HandleCallback(const struct FSteamInventoryStartPurchaseResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProInventoryAsyncActionStartPurchaseResult", "HandleCallback");

	Params::SteamCoreProInventoryAsyncActionStartPurchaseResult_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddFavoriteGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConnectionPort                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ESteamFavoriteFlags>             Param_Flags                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   TimeLastPlayedOnServer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::AddFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Param_Flags, int32 TimeLastPlayedOnServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddFavoriteGame");

	Params::SteamProMatchmaking_AddFavoriteGame Parms{};

	Parms.AppID = AppID;
	Parms.IP = std::move(IP);
	Parms.ConnectionPort = ConnectionPort;
	Parms.QueryPort = QueryPort;
	Parms.Param_Flags = std::move(Param_Flags);
	Parms.TimeLastPlayedOnServer = TimeLastPlayedOnServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListCompatibleMembersFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListCompatibleMembersFilter(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListCompatibleMembersFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListCompatibleMembersFilter Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListDistanceFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamLobbyDistanceFilter               LobbyDistanceFilter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListDistanceFilter(ESteamLobbyDistanceFilter LobbyDistanceFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListDistanceFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListDistanceFilter Parms{};

	Parms.LobbyDistanceFilter = LobbyDistanceFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListFilterSlotsAvailable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SlotsAvailable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListFilterSlotsAvailable(int32 SlotsAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListFilterSlotsAvailable");

	Params::SteamProMatchmaking_AddRequestLobbyListFilterSlotsAvailable Parms{};

	Parms.SlotsAvailable = SlotsAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListNearValueFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           KeyToMatch                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ValueToBeCloseTo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListNearValueFilter(const class FString& KeyToMatch, int32 ValueToBeCloseTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListNearValueFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListNearValueFilter Parms{};

	Parms.KeyToMatch = std::move(KeyToMatch);
	Parms.ValueToBeCloseTo = ValueToBeCloseTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListNumericalFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           KeyToMatch                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ValueToMatch                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLobbyComparison                   ComparisonType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListNumericalFilter(const class FString& KeyToMatch, int32 ValueToMatch, ESteamLobbyComparison ComparisonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListNumericalFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListNumericalFilter Parms{};

	Parms.KeyToMatch = std::move(KeyToMatch);
	Parms.ValueToMatch = ValueToMatch;
	Parms.ComparisonType = ComparisonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListResultCountFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListResultCountFilter(int32 MaxResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListResultCountFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListResultCountFilter Parms{};

	Parms.MaxResults = MaxResults;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.AddRequestLobbyListStringFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           KeyToMatch                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ValueToMatch                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLobbyComparison                   ComparisonType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::AddRequestLobbyListStringFilter(const class FString& KeyToMatch, const class FString& ValueToMatch, ESteamLobbyComparison ComparisonType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "AddRequestLobbyListStringFilter");

	Params::SteamProMatchmaking_AddRequestLobbyListStringFilter Parms{};

	Parms.KeyToMatch = std::move(KeyToMatch);
	Parms.ValueToMatch = std::move(ValueToMatch);
	Parms.ComparisonType = ComparisonType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.DeleteLobbyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::DeleteLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "DeleteLobbyData");

	Params::SteamProMatchmaking_DeleteLobbyData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetFavoriteGame
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Game                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConnectionPort                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ESteamFavoriteFlags>             Param_Flags                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   TimeLastPlayedOnServer                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::GetFavoriteGame(int32 Game, int32* AppID, class FString* IP, int32* ConnectionPort, int32* QueryPort, TArray<ESteamFavoriteFlags>* Param_Flags, int32* TimeLastPlayedOnServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetFavoriteGame");

	Params::SteamProMatchmaking_GetFavoriteGame Parms{};

	Parms.Game = Game;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AppID != nullptr)
		*AppID = Parms.AppID;

	if (IP != nullptr)
		*IP = std::move(Parms.IP);

	if (ConnectionPort != nullptr)
		*ConnectionPort = Parms.ConnectionPort;

	if (QueryPort != nullptr)
		*QueryPort = Parms.QueryPort;

	if (Param_Flags != nullptr)
		*Param_Flags = std::move(Parms.Param_Flags);

	if (TimeLastPlayedOnServer != nullptr)
		*TimeLastPlayedOnServer = Parms.TimeLastPlayedOnServer;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetFavoriteGameCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::GetFavoriteGameCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetFavoriteGameCount");

	Params::SteamProMatchmaking_GetFavoriteGameCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Lobby                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProMatchmaking::GetLobbyByIndex(int32 Lobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyByIndex");

	Params::SteamProMatchmaking_GetLobbyByIndex Parms{};

	Parms.Lobby = Lobby;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyChatEntry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MessageID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamChatEntryType                     ChatEntryType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::GetLobbyChatEntry(const struct FSteamID& SteamIDLobby, int32 MessageID, struct FSteamID* SteamIDUser, class FString* Message, ESteamChatEntryType* ChatEntryType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyChatEntry");

	Params::SteamProMatchmaking_GetLobbyChatEntry Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.MessageID = MessageID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SteamIDUser != nullptr)
		*SteamIDUser = std::move(Parms.SteamIDUser);

	if (Message != nullptr)
		*Message = std::move(Parms.Message);

	if (ChatEntryType != nullptr)
		*ChatEntryType = Parms.ChatEntryType;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProMatchmaking::GetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyData");

	Params::SteamProMatchmaking_GetLobbyData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyDataByIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   LobbyData                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::GetLobbyDataByIndex(const struct FSteamID& SteamIDLobby, int32 LobbyData, class FString* Key, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyDataByIndex");

	Params::SteamProMatchmaking_GetLobbyDataByIndex Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.LobbyData = LobbyData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyDataCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::GetLobbyDataCount(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyDataCount");

	Params::SteamProMatchmaking_GetLobbyDataCount Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyGameServer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           GameServerIP                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameServerPort                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDGameServer                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::GetLobbyGameServer(const struct FSteamID& SteamIDLobby, class FString* GameServerIP, int32* GameServerPort, struct FSteamID* SteamIDGameServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyGameServer");

	Params::SteamProMatchmaking_GetLobbyGameServer Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GameServerIP != nullptr)
		*GameServerIP = std::move(Parms.GameServerIP);

	if (GameServerPort != nullptr)
		*GameServerPort = Parms.GameServerPort;

	if (SteamIDGameServer != nullptr)
		*SteamIDGameServer = std::move(Parms.SteamIDGameServer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyMemberByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Member                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProMatchmaking::GetLobbyMemberByIndex(const struct FSteamID& SteamIDLobby, int32 Member)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyMemberByIndex");

	Params::SteamProMatchmaking_GetLobbyMemberByIndex Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Member = Member;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyMemberData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProMatchmaking::GetLobbyMemberData(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDUser, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyMemberData");

	Params::SteamProMatchmaking_GetLobbyMemberData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyMemberLimit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::GetLobbyMemberLimit(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyMemberLimit");

	Params::SteamProMatchmaking_GetLobbyMemberLimit Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetLobbyOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProMatchmaking::GetLobbyOwner(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetLobbyOwner");

	Params::SteamProMatchmaking_GetLobbyOwner Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetNumLobbyMembers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProMatchmaking::GetNumLobbyMembers(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetNumLobbyMembers");

	Params::SteamProMatchmaking_GetNumLobbyMembers Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.GetSteamMatchmaking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProMatchmaking*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProMatchmaking* USteamProMatchmaking::GetSteamMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "GetSteamMatchmaking");

	Params::SteamProMatchmaking_GetSteamMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.InviteUserToLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDInvitee                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::InviteUserToLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDInvitee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "InviteUserToLobby");

	Params::SteamProMatchmaking_InviteUserToLobby Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.SteamIDInvitee = std::move(SteamIDInvitee);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.LeaveLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProMatchmaking::LeaveLobby(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "LeaveLobby");

	Params::SteamProMatchmaking_LeaveLobby Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.RemoveFavoriteGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConnectionPort                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<ESteamFavoriteFlags>             Param_Flags                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::RemoveFavoriteGame(int32 AppID, const class FString& IP, int32 ConnectionPort, int32 QueryPort, const TArray<ESteamFavoriteFlags>& Param_Flags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "RemoveFavoriteGame");

	Params::SteamProMatchmaking_RemoveFavoriteGame Parms{};

	Parms.AppID = AppID;
	Parms.IP = std::move(IP);
	Parms.ConnectionPort = ConnectionPort;
	Parms.QueryPort = QueryPort;
	Parms.Param_Flags = std::move(Param_Flags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.RequestLobbyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::RequestLobbyData(const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "RequestLobbyData");

	Params::SteamProMatchmaking_RequestLobbyData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SendLobbyChatMsg
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SendLobbyChatMsg(const struct FSteamID& SteamIDLobby, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SendLobbyChatMsg");

	Params::SteamProMatchmaking_SendLobbyChatMsg Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLinkedLobby
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDLobbyDependent                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLinkedLobby(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDLobbyDependent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLinkedLobby");

	Params::SteamProMatchmaking_SetLinkedLobby Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.SteamIDLobbyDependent = std::move(SteamIDLobbyDependent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLobbyData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyData");

	Params::SteamProMatchmaking_SetLobbyData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyGameServer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           GameServerIP                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   GameServerPort                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDGameServer                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProMatchmaking::SetLobbyGameServer(const struct FSteamID& SteamIDLobby, const class FString& GameServerIP, int32 GameServerPort, const struct FSteamID& SteamIDGameServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyGameServer");

	Params::SteamProMatchmaking_SetLobbyGameServer Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.GameServerIP = std::move(GameServerIP);
	Parms.GameServerPort = GameServerPort;
	Parms.SteamIDGameServer = std::move(SteamIDGameServer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyJoinable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bLobbyJoinable                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLobbyJoinable(const struct FSteamID& SteamIDLobby, bool bLobbyJoinable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyJoinable");

	Params::SteamProMatchmaking_SetLobbyJoinable Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.bLobbyJoinable = bLobbyJoinable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyMemberData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::SetLobbyMemberData(const struct FSteamID& SteamIDLobby, const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyMemberData");

	Params::SteamProMatchmaking_SetLobbyMemberData Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyMemberLimit
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxMembers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLobbyMemberLimit(const struct FSteamID& SteamIDLobby, int32 MaxMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyMemberLimit");

	Params::SteamProMatchmaking_SetLobbyMemberLimit Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.MaxMembers = MaxMembers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDNewOwner                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLobbyOwner(const struct FSteamID& SteamIDLobby, const struct FSteamID& SteamIDNewOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyOwner");

	Params::SteamProMatchmaking_SetLobbyOwner Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.SteamIDNewOwner = std::move(SteamIDNewOwner);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.SetLobbyType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLobbyType                         LobbyType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMatchmaking::SetLobbyType(const struct FSteamID& SteamIDLobby, ESteamLobbyType LobbyType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmaking", "SetLobbyType");

	Params::SteamProMatchmaking_SetLobbyType Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.LobbyType = LobbyType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmaking.CreateLobby
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FCreateLobbyData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLobbyType                         LobbyType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxMembers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::CreateLobby(const TDelegate<void(struct FCreateLobbyData& Data, bool bWasSuccessful)>& Callback, ESteamLobbyType LobbyType, int32 MaxMembers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmaking", "CreateLobby");

	Params::SteamProMatchmaking_CreateLobby Parms{};

	Parms.Callback = Callback;
	Parms.LobbyType = LobbyType;
	Parms.MaxMembers = MaxMembers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.JoinLobby
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FJoinLobbyData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProMatchmaking::JoinLobby(const TDelegate<void(struct FJoinLobbyData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDLobby)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmaking", "JoinLobby");

	Params::SteamProMatchmaking_JoinLobby Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDLobby = std::move(SteamIDLobby);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmaking.RequestLobbyList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FLobbyMatchList& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmaking::RequestLobbyList(const TDelegate<void(struct FLobbyMatchList& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmaking", "RequestLobbyList");

	Params::SteamProMatchmaking_RequestLobbyList Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionCreateLobby.CreateLobbyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLobbyType                         LobbyType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxMembers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingAsyncActionCreateLobby*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingAsyncActionCreateLobby* USteamCoreProMatchmakingAsyncActionCreateLobby::CreateLobbyAsync(class UObject* WorldContextObject, ESteamLobbyType LobbyType, int32 MaxMembers, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingAsyncActionCreateLobby", "CreateLobbyAsync");

	Params::SteamCoreProMatchmakingAsyncActionCreateLobby_CreateLobbyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LobbyType = LobbyType;
	Parms.MaxMembers = MaxMembers;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionCreateLobby.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCreateLobbyData                 Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingAsyncActionCreateLobby::HandleCallback(const struct FCreateLobbyData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingAsyncActionCreateLobby", "HandleCallback");

	Params::SteamCoreProMatchmakingAsyncActionCreateLobby_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionRequestLobbyList.RequestLobbyListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingAsyncActionRequestLobbyList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingAsyncActionRequestLobbyList* USteamCoreProMatchmakingAsyncActionRequestLobbyList::RequestLobbyListAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingAsyncActionRequestLobbyList", "RequestLobbyListAsync");

	Params::SteamCoreProMatchmakingAsyncActionRequestLobbyList_RequestLobbyListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionRequestLobbyList.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLobbyMatchList                  Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingAsyncActionRequestLobbyList::HandleCallback(const struct FLobbyMatchList& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingAsyncActionRequestLobbyList", "HandleCallback");

	Params::SteamCoreProMatchmakingAsyncActionRequestLobbyList_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionJoinLobby.JoinLobbyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingAsyncActionJoinLobby*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingAsyncActionJoinLobby* USteamCoreProMatchmakingAsyncActionJoinLobby::JoinLobbyAsync(class UObject* WorldContextObject, const struct FSteamID& SteamIDLobby, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingAsyncActionJoinLobby", "JoinLobbyAsync");

	Params::SteamCoreProMatchmakingAsyncActionJoinLobby_JoinLobbyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingAsyncActionJoinLobby.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FJoinLobbyData                   Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingAsyncActionJoinLobby::HandleCallback(const struct FJoinLobbyData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingAsyncActionJoinLobby", "HandleCallback");

	Params::SteamCoreProMatchmakingAsyncActionJoinLobby_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProCreateSession.CreateSteamCoreProSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FSteamSessionSetting>SessionSettings                                        (Parm, NativeAccessSpecifierPublic)
// class FString                           SessionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseLAN                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowInvites                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsesPresence                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowJoinViaPresence                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowJoinViaPresenceFriendsOnly                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAntiCheatProtected                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsesStats                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldAdvertise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseLobbiesVoiceChatIfAvailable                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProCreateSession*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProCreateSession* USteamCoreProCreateSession::CreateSteamCoreProSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSetting>& SessionSettings, const class FString& SessionName, int32 MaxPlayers, bool bUseLAN, bool bAllowInvites, bool bUsesPresence, bool bAllowJoinViaPresence, bool bAllowJoinViaPresenceFriendsOnly, bool bAntiCheatProtected, bool bUsesStats, bool bShouldAdvertise, bool bUseLobbiesVoiceChatIfAvailable, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProCreateSession", "CreateSteamCoreProSession");

	Params::SteamCoreProCreateSession_CreateSteamCoreProSession Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SessionSettings = std::move(SessionSettings);
	Parms.SessionName = std::move(SessionName);
	Parms.MaxPlayers = MaxPlayers;
	Parms.bUseLAN = bUseLAN;
	Parms.bAllowInvites = bAllowInvites;
	Parms.bUsesPresence = bUsesPresence;
	Parms.bAllowJoinViaPresence = bAllowJoinViaPresence;
	Parms.bAllowJoinViaPresenceFriendsOnly = bAllowJoinViaPresenceFriendsOnly;
	Parms.bAntiCheatProtected = bAntiCheatProtected;
	Parms.bUsesStats = bUsesStats;
	Parms.bShouldAdvertise = bShouldAdvertise;
	Parms.bUseLobbiesVoiceChatIfAvailable = bUseLobbiesVoiceChatIfAvailable;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFindSession.FindSteamCoreProSessions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FSteamSessionSearchSetting>SearchSettings                                         (Parm, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseLAN                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamSessionFindType                   ServerType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLobbyDistanceFilter               DistanceFilter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEmptyServersOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSecureServersOnly                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProFindSession*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProFindSession* USteamCoreProFindSession::FindSteamCoreProSessions(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& SearchSettings, int32 MaxResults, bool bUseLAN, ESteamSessionFindType ServerType, ESteamLobbyDistanceFilter DistanceFilter, bool bEmptyServersOnly, bool bSecureServersOnly, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProFindSession", "FindSteamCoreProSessions");

	Params::SteamCoreProFindSession_FindSteamCoreProSessions Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SearchSettings = std::move(SearchSettings);
	Parms.MaxResults = MaxResults;
	Parms.bUseLAN = bUseLAN;
	Parms.ServerType = ServerType;
	Parms.DistanceFilter = DistanceFilter;
	Parms.bEmptyServersOnly = bEmptyServersOnly;
	Parms.bSecureServersOnly = bSecureServersOnly;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProFindSession.OnCompleted
// (Final, Native, Public)
// Parameters:
// bool                                    bSuccessful                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProFindSession::OnCompleted(bool bSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProFindSession", "OnCompleted");

	Params::SteamCoreProFindSession_OnCompleted Parms{};

	Parms.bSuccessful = bSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProDestroySession.DestroySteamCoreProSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProDestroySession*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProDestroySession* USteamCoreProDestroySession::DestroySteamCoreProSession(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProDestroySession", "DestroySteamCoreProSession");

	Params::SteamCoreProDestroySession_DestroySteamCoreProSession Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProDestroySession.OnCompleted
// (Final, Native, Public)
// Parameters:
// class FName                             SessionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProDestroySession::OnCompleted(class FName SessionName, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProDestroySession", "OnCompleted");

	Params::SteamCoreProDestroySession_OnCompleted Parms{};

	Parms.SessionName = SessionName;
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUpdateSession.UpdateSteamCoreProSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, struct FSteamSessionSearchSetting>Settings                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           SessionName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxPlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUpdateSession*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUpdateSession* USteamCoreProUpdateSession::UpdateSteamCoreProSession(class UObject* WorldContextObject, const TMap<class FString, struct FSteamSessionSearchSetting>& Settings, const class FString& SessionName, int32 MaxPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUpdateSession", "UpdateSteamCoreProSession");

	Params::SteamCoreProUpdateSession_UpdateSteamCoreProSession Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Settings = std::move(Settings);
	Parms.SessionName = std::move(SessionName);
	Parms.MaxPlayers = MaxPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUpdateSession.OnCompleted
// (Final, Native, Public)
// Parameters:
// class FName                             SessionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUpdateSession::OnCompleted(class FName SessionName, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUpdateSession", "OnCompleted");

	Params::SteamCoreProUpdateSession_OnCompleted Parms{};

	Parms.SessionName = SessionName;
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.GetSteamMatchmakingServers
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProMatchmakingServers*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProMatchmakingServers* USteamProMatchmakingServers::GetSteamMatchmakingServers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMatchmakingServers", "GetSteamMatchmakingServers");

	Params::SteamProMatchmakingServers_GetSteamMatchmakingServers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMatchmakingServers.PingServer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::PingServer(const TDelegate<void(struct FGameServerItem& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "PingServer");

	Params::SteamProMatchmakingServers_PingServer Parms{};

	Parms.Callback = Callback;
	Parms.IP = std::move(IP);
	Parms.QueryPort = QueryPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestFavoritesServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestFavoritesServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestFavoritesServerList");

	Params::SteamProMatchmakingServers_RequestFavoritesServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestFriendsServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestFriendsServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestFriendsServerList");

	Params::SteamProMatchmakingServers_RequestFriendsServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestHistoryServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestHistoryServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestHistoryServerList");

	Params::SteamProMatchmakingServers_RequestHistoryServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestInternetServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestInternetServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestInternetServerList");

	Params::SteamProMatchmakingServers_RequestInternetServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestLANServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestLANServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestLANServerList");

	Params::SteamProMatchmakingServers_RequestLANServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.RequestSpectatorServerList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGameServerItem& Data)>ServerCallback                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::RequestSpectatorServerList(const TDelegate<void(struct FGameServerItem& Data)>& ServerCallback, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "RequestSpectatorServerList");

	Params::SteamProMatchmakingServers_RequestSpectatorServerList Parms{};

	Parms.ServerCallback = ServerCallback;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMatchmakingServers.ServerRules
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<struct FGameServerRule>& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMatchmakingServers::ServerRules(const TDelegate<void(TArray<struct FGameServerRule>& Data, bool bWasSuccessful)>& Callback, const class FString& IP, int32 QueryPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMatchmakingServers", "ServerRules");

	Params::SteamProMatchmakingServers_ServerRules Parms{};

	Parms.Callback = Callback;
	Parms.IP = std::move(IP);
	Parms.QueryPort = QueryPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionPingServer.CancelPingQueries
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionPingServer::CancelPingQueries(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionPingServer", "CancelPingQueries");

	Params::SteamCoreProMatchmakingServersAsyncActionPingServer_CancelPingQueries Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionPingServer.PingServerAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Port                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionPingServer*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionPingServer* USteamCoreProMatchmakingServersAsyncActionPingServer::PingServerAsync(class UObject* WorldContextObject, const class FString& IP, int32 Port, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionPingServer", "PingServerAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionPingServer_PingServerAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IP = std::move(IP);
	Parms.Port = Port;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionPingServer.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameServerItem                  Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionPingServer::HandleCallback(const struct FGameServerItem& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingServersAsyncActionPingServer", "HandleCallback");

	Params::SteamCoreProMatchmakingServersAsyncActionPingServer_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.CancelServerListQueries
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionRequestServerList::CancelServerListQueries(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "CancelServerListQueries");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_CancelServerListQueries Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestFavoritesServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestFavoritesServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestFavoritesServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestFavoritesServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestFriendsServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestFriendsServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestFriendsServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestFriendsServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestHistoryServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestHistoryServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestHistoryServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestHistoryServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestInternetServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestInternetServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestInternetServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestInternetServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestLANServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestLANServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestLANServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestLANServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.RequestSpectatorServerListAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxResults                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreNonResponsive                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ServerFilter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionRequestServerList*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionRequestServerList* USteamCoreProMatchmakingServersAsyncActionRequestServerList::RequestSpectatorServerListAsync(class UObject* WorldContextObject, int32 AppID, float Timeout, int32 MaxResults, bool bIgnoreNonResponsive, class UServerFilter* ServerFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "RequestSpectatorServerListAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_RequestSpectatorServerListAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;
	Parms.MaxResults = MaxResults;
	Parms.bIgnoreNonResponsive = bIgnoreNonResponsive;
	Parms.ServerFilter = ServerFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.HandleCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameServerItem                  Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionRequestServerList::HandleCallback(const struct FGameServerItem& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "HandleCallback");

	Params::SteamCoreProMatchmakingServersAsyncActionRequestServerList_HandleCallback Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionRequestServerList.HandleServerListFinished
// (Final, Native, Private)

void USteamCoreProMatchmakingServersAsyncActionRequestServerList::HandleServerListFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingServersAsyncActionRequestServerList", "HandleServerListFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionServerRules.CancelServerRulesQueries
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionServerRules::CancelServerRulesQueries(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionServerRules", "CancelServerRulesQueries");

	Params::SteamCoreProMatchmakingServersAsyncActionServerRules_CancelServerRulesQueries Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionServerRules.ServerRulesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           IP                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QueryPort                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProMatchmakingServersAsyncActionServerRules*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProMatchmakingServersAsyncActionServerRules* USteamCoreProMatchmakingServersAsyncActionServerRules::ServerRulesAsync(class UObject* WorldContextObject, const class FString& IP, int32 QueryPort, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProMatchmakingServersAsyncActionServerRules", "ServerRulesAsync");

	Params::SteamCoreProMatchmakingServersAsyncActionServerRules_ServerRulesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.IP = std::move(IP);
	Parms.QueryPort = QueryPort;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProMatchmakingServersAsyncActionServerRules.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FGameServerRule>          Data                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProMatchmakingServersAsyncActionServerRules::HandleCallback(const TArray<struct FGameServerRule>& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProMatchmakingServersAsyncActionServerRules", "HandleCallback");

	Params::SteamCoreProMatchmakingServersAsyncActionServerRules_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterAnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterAnd(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterAnd");

	Params::ServerFilter_AddFilterAnd Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterDedicated
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterDedicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterDedicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameAddr
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameAddr(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameAddr");

	Params::ServerFilter_AddFilterGameAddr Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameDataAnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameDataAnd(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameDataAnd");

	Params::ServerFilter_AddFilterGameDataAnd Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameDataNor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameDataNor(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameDataNor");

	Params::ServerFilter_AddFilterGameDataNor Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameDataOr
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameDataOr(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameDataOr");

	Params::ServerFilter_AddFilterGameDataOr Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameTagsAnd
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameTagsAnd(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameTagsAnd");

	Params::ServerFilter_AddFilterGameTagsAnd Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterGameTagsNor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterGameTagsNor(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterGameTagsNor");

	Params::ServerFilter_AddFilterGameTagsNor Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterHasPlayers
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterHasPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterHasPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterLinux
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterLinux()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterLinux");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterMap(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterMap");

	Params::ServerFilter_AddFilterMap Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterName(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterName");

	Params::ServerFilter_AddFilterName Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterNand
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterNand(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterNand");

	Params::ServerFilter_AddFilterNand Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterNoPlayers
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterNoPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterNoPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterNor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterNor(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterNor");

	Params::ServerFilter_AddFilterNor Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterNotAppId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterNotAppId(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterNotAppId");

	Params::ServerFilter_AddFilterNotAppId Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterNotFull
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterNotFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterNotFull");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterOr
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterOr(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterOr");

	Params::ServerFilter_AddFilterOr Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterPassword
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterPassword()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterPassword");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterProxy
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterProxy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterProxy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterSecure
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterSecure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterSecure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterVersion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UServerFilter::AddFilterVersion(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterVersion");

	Params::ServerFilter_AddFilterVersion Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.AddFilterWhitelisted
// (Final, Native, Public, BlueprintCallable)

void UServerFilter::AddFilterWhitelisted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "AddFilterWhitelisted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.ServerFilter.GetFilters
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class FString, class FString>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> UServerFilter::GetFilters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServerFilter", "GetFilters");

	Params::ServerFilter_GetFilters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.GetSteamMusic
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProMusic*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProMusic* USteamProMusic::GetSteamMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProMusic", "GetSteamMusic");

	Params::SteamProMusic_GetSteamMusic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.bIsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMusic::bIsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "bIsEnabled");

	Params::SteamProMusic_bIsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.BIsPlaying
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProMusic::BIsPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "BIsPlaying");

	Params::SteamProMusic_BIsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.GetPlaybackStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamAudioPlaybackStatus               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamAudioPlaybackStatus USteamProMusic::GetPlaybackStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "GetPlaybackStatus");

	Params::SteamProMusic_GetPlaybackStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.GetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USteamProMusic::GetVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "GetVolume");

	Params::SteamProMusic_GetVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProMusic.Pause
// (Final, Native, Public, BlueprintCallable)

void USteamProMusic::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMusic.Play
// (Final, Native, Public, BlueprintCallable)

void USteamProMusic::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMusic.PlayNext
// (Final, Native, Public, BlueprintCallable)

void USteamProMusic::PlayNext()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "PlayNext");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMusic.PlayPrevious
// (Final, Native, Public, BlueprintCallable)

void USteamProMusic::PlayPrevious()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "PlayPrevious");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProMusic.SetVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FlVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProMusic::SetVolume(float FlVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProMusic", "SetVolume");

	Params::SteamProMusic_SetVolume Parms{};

	Parms.FlVolume = FlVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProNetworking.GetSteamNetworking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProNetworking*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProNetworking* USteamProNetworking::GetSteamNetworking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProNetworking", "GetSteamNetworking");

	Params::SteamProNetworking_GetSteamNetworking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.AcceptP2PSessionWithUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDRemote                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::AcceptP2PSessionWithUser(const struct FSteamID& SteamIDRemote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "AcceptP2PSessionWithUser");

	Params::SteamProNetworking_AcceptP2PSessionWithUser Parms{};

	Parms.SteamIDRemote = std::move(SteamIDRemote);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.AllowP2PPacketRelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::AllowP2PPacketRelay(bool bAllow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "AllowP2PPacketRelay");

	Params::SteamProNetworking_AllowP2PPacketRelay Parms{};

	Parms.bAllow = bAllow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.CloseP2PChannelWithUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDRemote                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::CloseP2PChannelWithUser(const struct FSteamID& SteamIDRemote, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "CloseP2PChannelWithUser");

	Params::SteamProNetworking_CloseP2PChannelWithUser Parms{};

	Parms.SteamIDRemote = std::move(SteamIDRemote);
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.CloseP2PSessionWithUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDRemote                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::CloseP2PSessionWithUser(const struct FSteamID& SteamIDRemote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "CloseP2PSessionWithUser");

	Params::SteamProNetworking_CloseP2PSessionWithUser Parms{};

	Parms.SteamIDRemote = std::move(SteamIDRemote);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.GetP2PSessionState
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDRemote                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamP2PSessionState            ConnectionState                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::GetP2PSessionState(const struct FSteamID& SteamIDRemote, struct FSteamP2PSessionState* ConnectionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "GetP2PSessionState");

	Params::SteamProNetworking_GetP2PSessionState Parms{};

	Parms.SteamIDRemote = std::move(SteamIDRemote);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectionState != nullptr)
		*ConnectionState = std::move(Parms.ConnectionState);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.IsP2PPacketAvailable
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   MessageSize                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::IsP2PPacketAvailable(int32* MessageSize, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "IsP2PPacketAvailable");

	Params::SteamProNetworking_IsP2PPacketAvailable Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MessageSize != nullptr)
		*MessageSize = Parms.MessageSize;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.ReadP2PPacket
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Data                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamID                         OutSteamIdRemote                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MessageSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::ReadP2PPacket(TArray<uint8>* Data, struct FSteamID* OutSteamIdRemote, int32 MessageSize, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "ReadP2PPacket");

	Params::SteamProNetworking_ReadP2PPacket Parms{};

	Parms.MessageSize = MessageSize;
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (OutSteamIdRemote != nullptr)
		*OutSteamIdRemote = std::move(Parms.OutSteamIdRemote);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworking.SendP2PPacket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDRemote                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           Data                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESteamP2PSend                           P2PSendType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworking::SendP2PPacket(const struct FSteamID& SteamIDRemote, const TArray<uint8>& Data, ESteamP2PSend P2PSendType, int32 Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworking", "SendP2PPacket");

	Params::SteamProNetworking_SendP2PPacket Parms{};

	Parms.SteamIDRemote = std::move(SteamIDRemote);
	Parms.Data = std::move(Data);
	Parms.P2PSendType = P2PSendType;
	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.ConvertPingLocationToString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkPingLocation        Location                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           String                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProNetworkingUtils::ConvertPingLocationToString(const struct FSteamNetworkPingLocation& Location, class FString* String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProNetworkingUtils", "ConvertPingLocationToString");

	Params::SteamProNetworkingUtils_ConvertPingLocationToString Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (String != nullptr)
		*String = std::move(Parms.String);
}


// Function SteamCorePro.SteamProNetworkingUtils.GetSteamNetworkingUtils
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProNetworkingUtils*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProNetworkingUtils* USteamProNetworkingUtils::GetSteamNetworkingUtils()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProNetworkingUtils", "GetSteamNetworkingUtils");

	Params::SteamProNetworkingUtils_GetSteamNetworkingUtils Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.ParsePingLocationString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamNetworkPingLocation        Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworkingUtils::ParsePingLocationString(const class FString& String, struct FSteamNetworkPingLocation* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProNetworkingUtils", "ParsePingLocationString");

	Params::SteamProNetworkingUtils_ParsePingLocationString Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.CheckPingDataUpToDate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   MaxAgeSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProNetworkingUtils::CheckPingDataUpToDate(float MaxAgeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworkingUtils", "CheckPingDataUpToDate");

	Params::SteamProNetworkingUtils_CheckPingDataUpToDate Parms{};

	Parms.MaxAgeSeconds = MaxAgeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.EstimatePingTimeBetweenTwoLocations
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkPingLocation        Location1                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FSteamNetworkPingLocation        Location2                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProNetworkingUtils::EstimatePingTimeBetweenTwoLocations(const struct FSteamNetworkPingLocation& Location1, const struct FSteamNetworkPingLocation& Location2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworkingUtils", "EstimatePingTimeBetweenTwoLocations");

	Params::SteamProNetworkingUtils_EstimatePingTimeBetweenTwoLocations Parms{};

	Parms.Location1 = std::move(Location1);
	Parms.Location2 = std::move(Location2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.EstimatePingTimeFromLocalHost
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkPingLocation        RemoteLocation                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProNetworkingUtils::EstimatePingTimeFromLocalHost(const struct FSteamNetworkPingLocation& RemoteLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworkingUtils", "EstimatePingTimeFromLocalHost");

	Params::SteamProNetworkingUtils_EstimatePingTimeFromLocalHost Parms{};

	Parms.RemoteLocation = std::move(RemoteLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.GetLocalPingLocation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkPingLocation        Result                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USteamProNetworkingUtils::GetLocalPingLocation(struct FSteamNetworkPingLocation* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworkingUtils", "GetLocalPingLocation");

	Params::SteamProNetworkingUtils_GetLocalPingLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProNetworkingUtils.InitRelayNetworkAccess
// (Final, Native, Public, BlueprintCallable)

void USteamProNetworkingUtils::InitRelayNetworkAccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProNetworkingUtils", "InitRelayNetworkAccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProParentalSettings.GetSteamParentalSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProParentalSettings*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProParentalSettings* USteamProParentalSettings::GetSteamParentalSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParentalSettings", "GetSteamParentalSettings");

	Params::SteamProParentalSettings_GetSteamParentalSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsAppBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsAppBlocked(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsAppBlocked");

	Params::SteamProParentalSettings_BIsAppBlocked Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsAppInBlockList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsAppInBlockList(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsAppInBlockList");

	Params::SteamProParentalSettings_BIsAppInBlockList Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsFeatureBlocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamParentalFeature                   Feature                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsFeatureBlocked(ESteamParentalFeature Feature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsFeatureBlocked");

	Params::SteamProParentalSettings_BIsFeatureBlocked Parms{};

	Parms.Feature = Feature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsFeatureInBlockList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamParentalFeature                   Feature                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsFeatureInBlockList(ESteamParentalFeature Feature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsFeatureInBlockList");

	Params::SteamProParentalSettings_BIsFeatureInBlockList Parms{};

	Parms.Feature = Feature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsParentalLockEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsParentalLockEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsParentalLockEnabled");

	Params::SteamProParentalSettings_BIsParentalLockEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParentalSettings.BIsParentalLockLocked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParentalSettings::BIsParentalLockLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParentalSettings", "BIsParentalLockLocked");

	Params::SteamProParentalSettings_BIsParentalLockLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionJoinParty.JoinPartyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProSteamPartiesAsyncActionJoinParty*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProSteamPartiesAsyncActionJoinParty* USteamCoreProSteamPartiesAsyncActionJoinParty::JoinPartyAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProSteamPartiesAsyncActionJoinParty", "JoinPartyAsync");

	Params::SteamCoreProSteamPartiesAsyncActionJoinParty_JoinPartyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BeaconID = std::move(BeaconID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionJoinParty.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FJoinPartyData                   Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProSteamPartiesAsyncActionJoinParty::HandleCallback(const struct FJoinPartyData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProSteamPartiesAsyncActionJoinParty", "HandleCallback");

	Params::SteamCoreProSteamPartiesAsyncActionJoinParty_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionCreateBeacon.CreateBeaconAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OpenSlots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamPartyBeaconLocation        BeaconLocation                                         (Parm, NativeAccessSpecifierPublic)
// class FString                           ConnectString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MetaData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProSteamPartiesAsyncActionCreateBeacon*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProSteamPartiesAsyncActionCreateBeacon* USteamCoreProSteamPartiesAsyncActionCreateBeacon::CreateBeaconAsync(class UObject* WorldContextObject, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProSteamPartiesAsyncActionCreateBeacon", "CreateBeaconAsync");

	Params::SteamCoreProSteamPartiesAsyncActionCreateBeacon_CreateBeaconAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OpenSlots = OpenSlots;
	Parms.BeaconLocation = std::move(BeaconLocation);
	Parms.ConnectString = std::move(ConnectString);
	Parms.MetaData = std::move(MetaData);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionCreateBeacon.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCreateBeaconData                Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProSteamPartiesAsyncActionCreateBeacon::HandleCallback(const struct FCreateBeaconData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProSteamPartiesAsyncActionCreateBeacon", "HandleCallback");

	Params::SteamCoreProSteamPartiesAsyncActionCreateBeacon_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots.ChangeNumOpenSlotsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   OpenSlots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots* USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots::ChangeNumOpenSlotsAsync(class UObject* WorldContextObject, const struct FPartyBeaconID& BeaconID, int32 OpenSlots, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots", "ChangeNumOpenSlotsAsync");

	Params::SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots_ChangeNumOpenSlotsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BeaconID = std::move(BeaconID);
	Parms.OpenSlots = OpenSlots;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FChangeNumOpenSlotsData          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots::HandleCallback(const struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots", "HandleCallback");

	Params::SteamCoreProSteamPartiesAsyncActionChangeNumOpenSlots_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProAppList.GetSteamAppList
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProAppList*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProAppList* USteamProAppList::GetSteamAppList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProAppList", "GetSteamAppList");

	Params::SteamProAppList_GetSteamAppList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProAppList.GetAppBuildId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProAppList::GetAppBuildId(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProAppList", "GetAppBuildId");

	Params::SteamProAppList_GetAppBuildId Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProAppList.GetAppInstallDir
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Directory                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProAppList::GetAppInstallDir(int32 AppID, class FString* Directory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProAppList", "GetAppInstallDir");

	Params::SteamProAppList_GetAppInstallDir Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Directory != nullptr)
		*Directory = std::move(Parms.Directory);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProAppList.GetAppName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProAppList::GetAppName(int32 AppID, class FString* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProAppList", "GetAppName");

	Params::SteamProAppList_GetAppName Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProAppList.GetInstalledApps
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           AppIDs                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MaxAppIDs                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProAppList::GetInstalledApps(TArray<int32>* AppIDs, int32 MaxAppIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProAppList", "GetInstalledApps");

	Params::SteamProAppList_GetInstalledApps Parms{};

	Parms.MaxAppIDs = MaxAppIDs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AppIDs != nullptr)
		*AppIDs = std::move(Parms.AppIDs);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProAppList.GetNumInstalledApps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProAppList::GetNumInstalledApps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProAppList", "GetNumInstalledApps");

	Params::SteamProAppList_GetNumInstalledApps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BGetDLCDataByIndex
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   DLC                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAvailable                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BGetDLCDataByIndex(int32 DLC, int32* AppID, bool* bAvailable, class FString* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BGetDLCDataByIndex");

	Params::SteamProApps_BGetDLCDataByIndex Parms{};

	Parms.DLC = DLC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AppID != nullptr)
		*AppID = Parms.AppID;

	if (bAvailable != nullptr)
		*bAvailable = Parms.bAvailable;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsAppInstalled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsAppInstalled(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsAppInstalled");

	Params::SteamProApps_BIsAppInstalled Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsCybercafe
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsCybercafe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsCybercafe");

	Params::SteamProApps_BIsCybercafe Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsDlcInstalled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsDlcInstalled(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsDlcInstalled");

	Params::SteamProApps_BIsDlcInstalled Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsLowViolence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsLowViolence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsLowViolence");

	Params::SteamProApps_BIsLowViolence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsSubscribed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsSubscribed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsSubscribed");

	Params::SteamProApps_BIsSubscribed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsSubscribedApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsSubscribedApp(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsSubscribedApp");

	Params::SteamProApps_BIsSubscribedApp Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsSubscribedFromFamilySharing
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsSubscribedFromFamilySharing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsSubscribedFromFamilySharing");

	Params::SteamProApps_BIsSubscribedFromFamilySharing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsSubscribedFromFreeWeekend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsSubscribedFromFreeWeekend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsSubscribedFromFreeWeekend");

	Params::SteamProApps_BIsSubscribedFromFreeWeekend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsTimedTrial
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SecondsAllowed                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondsPlayed                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsTimedTrial(int32* SecondsAllowed, int32* SecondsPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsTimedTrial");

	Params::SteamProApps_BIsTimedTrial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SecondsAllowed != nullptr)
		*SecondsAllowed = Parms.SecondsAllowed;

	if (SecondsPlayed != nullptr)
		*SecondsPlayed = Parms.SecondsPlayed;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.BIsVACBanned
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::BIsVACBanned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "BIsVACBanned");

	Params::SteamProApps_BIsVACBanned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetAppBuildId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetAppBuildId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetAppBuildId");

	Params::SteamProApps_GetAppBuildId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetAppInstallDir
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Folder                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetAppInstallDir(int32 AppID, class FString* Folder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetAppInstallDir");

	Params::SteamProApps_GetAppInstallDir Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Folder != nullptr)
		*Folder = std::move(Parms.Folder);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetAppOwner
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProApps::GetAppOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetAppOwner");

	Params::SteamProApps_GetAppOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetAvailableGameLanguages
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProApps::GetAvailableGameLanguages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetAvailableGameLanguages");

	Params::SteamProApps_GetAvailableGameLanguages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetCurrentBetaName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::GetCurrentBetaName(class FString* Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetCurrentBetaName");

	Params::SteamProApps_GetCurrentBetaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetCurrentGameLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProApps::GetCurrentGameLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetCurrentGameLanguage");

	Params::SteamProApps_GetCurrentGameLanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetDLCCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetDLCCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetDLCCount");

	Params::SteamProApps_GetDLCCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetDlcDownloadProgress
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesDownloaded                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesTotal                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::GetDlcDownloadProgress(int32 AppID, int32* BytesDownloaded, int32* BytesTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetDlcDownloadProgress");

	Params::SteamProApps_GetDlcDownloadProgress Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BytesDownloaded != nullptr)
		*BytesDownloaded = Parms.BytesDownloaded;

	if (BytesTotal != nullptr)
		*BytesTotal = Parms.BytesTotal;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetEarliestPurchaseUnixTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetEarliestPurchaseUnixTime(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetEarliestPurchaseUnixTime");

	Params::SteamProApps_GetEarliestPurchaseUnixTime Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetInstalledDepots
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxDepots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Depots                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetInstalledDepots(int32 AppID, int32 MaxDepots, TArray<int32>* Depots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetInstalledDepots");

	Params::SteamProApps_GetInstalledDepots Parms{};

	Parms.AppID = AppID;
	Parms.MaxDepots = MaxDepots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Depots != nullptr)
		*Depots = std::move(Parms.Depots);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetLaunchCommandLine
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           CommandLine                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProApps::GetLaunchCommandLine(class FString* CommandLine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetLaunchCommandLine");

	Params::SteamProApps_GetLaunchCommandLine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CommandLine != nullptr)
		*CommandLine = std::move(Parms.CommandLine);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetLaunchQueryParam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProApps::GetLaunchQueryParam(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetLaunchQueryParam");

	Params::SteamProApps_GetLaunchQueryParam Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.GetSteamApps
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProApps*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProApps* USteamProApps::GetSteamApps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "GetSteamApps");

	Params::SteamProApps_GetSteamApps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.InstallDLC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProApps::InstallDLC(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "InstallDLC");

	Params::SteamProApps_InstallDLC Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProApps.MarkContentCorrupt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bMissingFilesOnly                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProApps::MarkContentCorrupt(bool bMissingFilesOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "MarkContentCorrupt");

	Params::SteamProApps_MarkContentCorrupt Parms{};

	Parms.bMissingFilesOnly = bMissingFilesOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProApps.UninstallDLC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProApps::UninstallDLC(int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProApps", "UninstallDLC");

	Params::SteamProApps_UninstallDLC Parms{};

	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProApps.GetFileDetails
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FFileDetailsResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProApps::GetFileDetails(const TDelegate<void(struct FFileDetailsResult& Data, bool bWasSuccessful)>& Callback, const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProApps", "GetFileDetails");

	Params::SteamProApps_GetFileDetails Parms{};

	Parms.Callback = Callback;
	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameSearch.GetSteamGameSearch
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProGameSearch*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProGameSearch* USteamProGameSearch::GetSteamGameSearch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProGameSearch", "GetSteamGameSearch");

	Params::SteamProGameSearch_GetSteamGameSearch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.AcceptGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::AcceptGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "AcceptGame");

	Params::SteamProGameSearch_AcceptGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.AddGameSearchParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           KeyToFind                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ValuesToFind                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::AddGameSearchParams(const class FString& KeyToFind, const TArray<class FString>& ValuesToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "AddGameSearchParams");

	Params::SteamProGameSearch_AddGameSearchParams Parms{};

	Parms.KeyToFind = std::move(KeyToFind);
	Parms.ValuesToFind = std::move(ValuesToFind);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.CancelRequestPlayersForGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::CancelRequestPlayersForGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "CancelRequestPlayersForGame");

	Params::SteamProGameSearch_CancelRequestPlayersForGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.DeclineGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::DeclineGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "DeclineGame");

	Params::SteamProGameSearch_DeclineGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.EndGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueGameID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::EndGame(const class FString& UniqueGameID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "EndGame");

	Params::SteamProGameSearch_EndGame Parms{};

	Parms.UniqueGameID = std::move(UniqueGameID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.EndGameSearch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::EndGameSearch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "EndGameSearch");

	Params::SteamProGameSearch_EndGameSearch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.HostConfirmGameStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueGameID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::HostConfirmGameStart(const class FString& UniqueGameID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "HostConfirmGameStart");

	Params::SteamProGameSearch_HostConfirmGameStart Parms{};

	Parms.UniqueGameID = std::move(UniqueGameID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.RequestPlayersForGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxTeamSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::RequestPlayersForGame(int32 PlayerMin, int32 PlayerMax, int32 MaxTeamSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "RequestPlayersForGame");

	Params::SteamProGameSearch_RequestPlayersForGame Parms{};

	Parms.PlayerMin = PlayerMin;
	Parms.PlayerMax = PlayerMax;
	Parms.MaxTeamSize = MaxTeamSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.RetrieveConnectionDetails
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDHost                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ConnectionDetails                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NumConnectionDetails                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::RetrieveConnectionDetails(const struct FSteamID& SteamIDHost, class FString* ConnectionDetails, int32 NumConnectionDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "RetrieveConnectionDetails");

	Params::SteamProGameSearch_RetrieveConnectionDetails Parms{};

	Parms.SteamIDHost = std::move(SteamIDHost);
	Parms.NumConnectionDetails = NumConnectionDetails;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ConnectionDetails != nullptr)
		*ConnectionDetails = std::move(Parms.ConnectionDetails);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.SearchForGameSolo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::SearchForGameSolo(int32 PlayerMin, int32 PlayerMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "SearchForGameSolo");

	Params::SteamProGameSearch_SearchForGameSolo Parms{};

	Parms.PlayerMin = PlayerMin;
	Parms.PlayerMax = PlayerMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.SearchForGameWithLobby
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDLobby                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   PlayerMin                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerMax                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::SearchForGameWithLobby(const struct FSteamID& SteamIDLobby, int32 PlayerMin, int32 PlayerMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "SearchForGameWithLobby");

	Params::SteamProGameSearch_SearchForGameWithLobby Parms{};

	Parms.SteamIDLobby = std::move(SteamIDLobby);
	Parms.PlayerMin = PlayerMin;
	Parms.PlayerMax = PlayerMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.SetConnectionDetails
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ConnectionDetails                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::SetConnectionDetails(const class FString& ConnectionDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "SetConnectionDetails");

	Params::SteamProGameSearch_SetConnectionDetails Parms{};

	Parms.ConnectionDetails = std::move(ConnectionDetails);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.SetGameHostParams
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::SetGameHostParams(const class FString& Key, const TArray<class FString>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "SetGameHostParams");

	Params::SteamProGameSearch_SetGameHostParams Parms{};

	Parms.Key = std::move(Key);
	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameSearch.SubmitPlayerResult
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UniqueGameID                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDPlayer                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamPlayerResult                      PlayerResult                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGameSearchErrorCode               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamGameSearchErrorCode USteamProGameSearch::SubmitPlayerResult(const class FString& UniqueGameID, const struct FSteamID& SteamIDPlayer, ESteamPlayerResult PlayerResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameSearch", "SubmitPlayerResult");

	Params::SteamProGameSearch_SubmitPlayerResult Parms{};

	Parms.UniqueGameID = std::move(UniqueGameID);
	Parms.SteamIDPlayer = std::move(SteamIDPlayer);
	Parms.PlayerResult = PlayerResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetSteamGameServer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProGameServer*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProGameServer* USteamProGameServer::GetSteamGameServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProGameServer", "GetSteamGameServer");

	Params::SteamProGameServer_GetSteamGameServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.AssociateWithClan
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FAssociateWithClanResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDClan                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServer::AssociateWithClan(const TDelegate<void(struct FAssociateWithClanResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDClan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "AssociateWithClan");

	Params::SteamProGameServer_AssociateWithClan Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDClan = std::move(SteamIDClan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.BeginAuthSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Ticket                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamBeginAuthSessionResult            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamBeginAuthSessionResult USteamProGameServer::BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "BeginAuthSession");

	Params::SteamProGameServer_BeginAuthSession Parms{};

	Parms.Ticket = std::move(Ticket);
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.BLoggedOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServer::BLoggedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "BLoggedOn");

	Params::SteamProGameServer_BLoggedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.BSecure
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServer::BSecure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "BSecure");

	Params::SteamProGameServer_BSecure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.BUpdateUserData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServer::BUpdateUserData(const struct FSteamID& SteamIDUser, const class FString& PlayerName, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "BUpdateUserData");

	Params::SteamProGameServer_BUpdateUserData Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.PlayerName = std::move(PlayerName);
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.CancelAuthTicket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamTicketHandle               TicketHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServer::CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "CancelAuthTicket");

	Params::SteamProGameServer_CancelAuthTicket Parms{};

	Parms.TicketHandle = std::move(TicketHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.ClearAllKeyValues
// (Final, Native, Public, BlueprintCallable)

void USteamProGameServer::ClearAllKeyValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "ClearAllKeyValues");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.ComputeNewPlayerCompatibility
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FComputeNewPlayerCompatibilityResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDNewPlayer                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServer::ComputeNewPlayerCompatibility(const TDelegate<void(struct FComputeNewPlayerCompatibilityResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamIDNewPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "ComputeNewPlayerCompatibility");

	Params::SteamProGameServer_ComputeNewPlayerCompatibility Parms{};

	Parms.Callback = Callback;
	Parms.SteamIDNewPlayer = std::move(SteamIDNewPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.CreateUnauthenticatedUserConnection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProGameServer::CreateUnauthenticatedUserConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "CreateUnauthenticatedUserConnection");

	Params::SteamProGameServer_CreateUnauthenticatedUserConnection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.EndAuthSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProGameServer::EndAuthSession(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "EndAuthSession");

	Params::SteamProGameServer_EndAuthSession Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.GetAuthSessionTicket
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Ticket                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamTicketHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamTicketHandle USteamProGameServer::GetAuthSessionTicket(TArray<uint8>* Ticket, const struct FSteamNetworkingIdentity& SteamNetworkingIdentity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetAuthSessionTicket");

	Params::SteamProGameServer_GetAuthSessionTicket Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Ticket != nullptr)
		*Ticket = std::move(Parms.Ticket);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerPublicIP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProGameServer::GetServerPublicIP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerPublicIP");

	Params::SteamProGameServer_GetServerPublicIP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerPublicIP_Pure
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProGameServer::GetServerPublicIP_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerPublicIP_Pure");

	Params::SteamProGameServer_GetServerPublicIP_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerPublicIP_PureCompact
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProGameServer::GetServerPublicIP_PureCompact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerPublicIP_PureCompact");

	Params::SteamProGameServer_GetServerPublicIP_PureCompact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerSteamID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProGameServer::GetServerSteamID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerSteamID");

	Params::SteamProGameServer_GetServerSteamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerSteamID_Pure
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProGameServer::GetServerSteamID_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerSteamID_Pure");

	Params::SteamProGameServer_GetServerSteamID_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.GetServerSteamID_PureCompact
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProGameServer::GetServerSteamID_PureCompact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "GetServerSteamID_PureCompact");

	Params::SteamProGameServer_GetServerSteamID_PureCompact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.LogOff
// (Final, Native, Public, BlueprintCallable)

void USteamProGameServer::LogOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "LogOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.LogOn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Token                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::LogOn(const class FString& Token)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "LogOn");

	Params::SteamProGameServer_LogOn Parms{};

	Parms.Token = std::move(Token);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.LogOnAnonymous
// (Final, Native, Public, BlueprintCallable)

void USteamProGameServer::LogOnAnonymous()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "LogOnAnonymous");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.RequestUserGroupStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDGroup                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServer::RequestUserGroupStatus(const struct FSteamID& SteamIDUser, const struct FSteamID& SteamIDGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "RequestUserGroupStatus");

	Params::SteamProGameServer_RequestUserGroupStatus Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.SteamIDGroup = std::move(SteamIDGroup);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.SetAdvertiseServerActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetAdvertiseServerActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetAdvertiseServerActive");

	Params::SteamProGameServer_SetAdvertiseServerActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetBotPlayerCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   BotPlayers                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetBotPlayerCount(int32 BotPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetBotPlayerCount");

	Params::SteamProGameServer_SetBotPlayerCount Parms{};

	Parms.BotPlayers = BotPlayers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetDedicatedServer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDedicated                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetDedicatedServer(bool bDedicated)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetDedicatedServer");

	Params::SteamProGameServer_SetDedicatedServer Parms{};

	Parms.bDedicated = bDedicated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GameData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetGameData(const class FString& GameData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetGameData");

	Params::SteamProGameServer_SetGameData Parms{};

	Parms.GameData = std::move(GameData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetGameDescription
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GameDescription                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetGameDescription(const class FString& GameDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetGameDescription");

	Params::SteamProGameServer_SetGameDescription Parms{};

	Parms.GameDescription = std::move(GameDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetGameTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           GameTags                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetGameTags(const class FString& GameTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetGameTags");

	Params::SteamProGameServer_SetGameTags Parms{};

	Parms.GameTags = std::move(GameTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetKeyValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetKeyValue(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetKeyValue");

	Params::SteamProGameServer_SetKeyValue Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetMapName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MapName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetMapName(const class FString& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetMapName");

	Params::SteamProGameServer_SetMapName Parms{};

	Parms.MapName = std::move(MapName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetMaxPlayerCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayersMax                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetMaxPlayerCount(int32 PlayersMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetMaxPlayerCount");

	Params::SteamProGameServer_SetMaxPlayerCount Parms{};

	Parms.PlayersMax = PlayersMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetModDir
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ModDir                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetModDir(const class FString& ModDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetModDir");

	Params::SteamProGameServer_SetModDir Parms{};

	Parms.ModDir = std::move(ModDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetPasswordProtected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPasswordProtected                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetPasswordProtected(bool bPasswordProtected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetPasswordProtected");

	Params::SteamProGameServer_SetPasswordProtected Parms{};

	Parms.bPasswordProtected = bPasswordProtected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetProduct
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Product                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetProduct(const class FString& Product)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetProduct");

	Params::SteamProGameServer_SetProduct Parms{};

	Parms.Product = std::move(Product);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetRegion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Region                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetRegion(const class FString& Region)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetRegion");

	Params::SteamProGameServer_SetRegion Parms{};

	Parms.Region = std::move(Region);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetServerName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ServerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetServerName(const class FString& ServerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetServerName");

	Params::SteamProGameServer_SetServerName Parms{};

	Parms.ServerName = std::move(ServerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetSpectatorPort
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SpectatorPort                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetSpectatorPort(int32 SpectatorPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetSpectatorPort");

	Params::SteamProGameServer_SetSpectatorPort Parms{};

	Parms.SpectatorPort = SpectatorPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.SetSpectatorServerName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SpectatorServerName                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProGameServer::SetSpectatorServerName(const class FString& SpectatorServerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "SetSpectatorServerName");

	Params::SteamProGameServer_SetSpectatorServerName Parms{};

	Parms.SpectatorServerName = std::move(SpectatorServerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProGameServer.UserHasLicenseForApp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUserHasLicenseForAppResult        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamUserHasLicenseForAppResult USteamProGameServer::UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "UserHasLicenseForApp");

	Params::SteamProGameServer_UserHasLicenseForApp Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProGameServer.WasRestartRequested
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProGameServer::WasRestartRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProGameServer", "WasRestartRequested");

	Params::SteamProGameServer_WasRestartRequested Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.CancelReservation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProParties::CancelReservation(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "CancelReservation");

	Params::SteamProParties_CancelReservation Parms{};

	Parms.BeaconID = std::move(BeaconID);
	Parms.SteamIDUser = std::move(SteamIDUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProParties.DestroyBeacon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParties::DestroyBeacon(const struct FPartyBeaconID& BeaconID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "DestroyBeacon");

	Params::SteamProParties_DestroyBeacon Parms{};

	Parms.BeaconID = std::move(BeaconID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetAvailableBeaconLocations
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FSteamPartyBeaconLocation>LocationList                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MaxNumLocations                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParties::GetAvailableBeaconLocations(TArray<struct FSteamPartyBeaconLocation>* LocationList, int32 MaxNumLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetAvailableBeaconLocations");

	Params::SteamProParties_GetAvailableBeaconLocations Parms{};

	Parms.MaxNumLocations = MaxNumLocations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LocationList != nullptr)
		*LocationList = std::move(Parms.LocationList);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetBeaconByIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyBeaconID                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPartyBeaconID USteamProParties::GetBeaconByIndex(int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetBeaconByIndex");

	Params::SteamProParties_GetBeaconByIndex Parms{};

	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetBeaconDetails
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDBeaconOwner                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamPartyBeaconLocation        Location                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// class FString                           OutMetadata                                            (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParties::GetBeaconDetails(const struct FPartyBeaconID& BeaconID, struct FSteamID* SteamIDBeaconOwner, struct FSteamPartyBeaconLocation* Location, class FString* OutMetadata)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetBeaconDetails");

	Params::SteamProParties_GetBeaconDetails Parms{};

	Parms.BeaconID = std::move(BeaconID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SteamIDBeaconOwner != nullptr)
		*SteamIDBeaconOwner = std::move(Parms.SteamIDBeaconOwner);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (OutMetadata != nullptr)
		*OutMetadata = std::move(Parms.OutMetadata);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetBeaconLocationData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamPartyBeaconLocation        BeaconLocation                                         (Parm, NativeAccessSpecifierPublic)
// ESteamPartiesBeaconLocationData         EData                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PCHDataStringOut                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParties::GetBeaconLocationData(const struct FSteamPartyBeaconLocation& BeaconLocation, ESteamPartiesBeaconLocationData EData, class FString* PCHDataStringOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetBeaconLocationData");

	Params::SteamProParties_GetBeaconLocationData Parms{};

	Parms.BeaconLocation = std::move(BeaconLocation);
	Parms.EData = EData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PCHDataStringOut != nullptr)
		*PCHDataStringOut = std::move(Parms.PCHDataStringOut);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetNumActiveBeacons
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProParties::GetNumActiveBeacons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetNumActiveBeacons");

	Params::SteamProParties_GetNumActiveBeacons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetNumAvailableBeaconLocations
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   NumLocations                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProParties::GetNumAvailableBeaconLocations(int32* NumLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetNumAvailableBeaconLocations");

	Params::SteamProParties_GetNumAvailableBeaconLocations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NumLocations != nullptr)
		*NumLocations = Parms.NumLocations;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.GetSteamParties
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProParties*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProParties* USteamProParties::GetSteamParties()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "GetSteamParties");

	Params::SteamProParties_GetSteamParties Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProParties.OnReservationCompleted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProParties::OnReservationCompleted(const struct FPartyBeaconID& BeaconID, const struct FSteamID& SteamIDUser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProParties", "OnReservationCompleted");

	Params::SteamProParties_OnReservationCompleted Parms{};

	Parms.BeaconID = std::move(BeaconID);
	Parms.SteamIDUser = std::move(SteamIDUser);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProParties.ChangeNumOpenSlots
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   OpenSlots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProParties::ChangeNumOpenSlots(const TDelegate<void(struct FChangeNumOpenSlotsData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID, int32 OpenSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParties", "ChangeNumOpenSlots");

	Params::SteamProParties_ChangeNumOpenSlots Parms{};

	Parms.Callback = Callback;
	Parms.BeaconID = std::move(BeaconID);
	Parms.OpenSlots = OpenSlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProParties.CreateBeacon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FCreateBeaconData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OpenSlots                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamPartyBeaconLocation        BeaconLocation                                         (Parm, NativeAccessSpecifierPublic)
// class FString                           ConnectString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MetaData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProParties::CreateBeacon(const TDelegate<void(struct FCreateBeaconData& Data, bool bWasSuccessful)>& Callback, int32 OpenSlots, const struct FSteamPartyBeaconLocation& BeaconLocation, const class FString& ConnectString, const class FString& MetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParties", "CreateBeacon");

	Params::SteamProParties_CreateBeacon Parms{};

	Parms.Callback = Callback;
	Parms.OpenSlots = OpenSlots;
	Parms.BeaconLocation = std::move(BeaconLocation);
	Parms.ConnectString = std::move(ConnectString);
	Parms.MetaData = std::move(MetaData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProParties.JoinParty
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FJoinPartyData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPartyBeaconID                   BeaconID                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProParties::JoinParty(const TDelegate<void(struct FJoinPartyData& Data, bool bWasSuccessful)>& Callback, const struct FPartyBeaconID& BeaconID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProParties", "JoinParty");

	Params::SteamProParties_JoinParty Parms{};

	Parms.Callback = Callback;
	Parms.BeaconID = std::move(BeaconID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemotePlay.GetSteamRemotePlay
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProRemotePlay*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProRemotePlay* USteamProRemotePlay::GetSteamRemotePlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemotePlay", "GetSteamRemotePlay");

	Params::SteamProRemotePlay_GetSteamRemotePlay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.BGetSessionClientResolution
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SessionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResolutionX                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ResolutionY                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemotePlay::BGetSessionClientResolution(int32 SessionID, int32* ResolutionX, int32* ResolutionY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "BGetSessionClientResolution");

	Params::SteamProRemotePlay_BGetSessionClientResolution Parms{};

	Parms.SessionID = SessionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResolutionX != nullptr)
		*ResolutionX = Parms.ResolutionX;

	if (ResolutionY != nullptr)
		*ResolutionY = Parms.ResolutionY;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.BSendRemotePlayTogetherInvite
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDFriend                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemotePlay::BSendRemotePlayTogetherInvite(const struct FSteamID& SteamIDFriend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "BSendRemotePlayTogetherInvite");

	Params::SteamProRemotePlay_BSendRemotePlayTogetherInvite Parms{};

	Parms.SteamIDFriend = std::move(SteamIDFriend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.BStartRemotePlayTogether
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShowOverlay                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemotePlay::BStartRemotePlayTogether(bool bShowOverlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "BStartRemotePlayTogether");

	Params::SteamProRemotePlay_BStartRemotePlayTogether Parms{};

	Parms.bShowOverlay = bShowOverlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.GetSessionClientFormFactor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SessionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreProDeviceFormFactor           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamCoreProDeviceFormFactor USteamProRemotePlay::GetSessionClientFormFactor(int32 SessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "GetSessionClientFormFactor");

	Params::SteamProRemotePlay_GetSessionClientFormFactor Parms{};

	Parms.SessionID = SessionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.GetSessionClientName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SessionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProRemotePlay::GetSessionClientName(int32 SessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "GetSessionClientName");

	Params::SteamProRemotePlay_GetSessionClientName Parms{};

	Parms.SessionID = SessionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.GetSessionCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemotePlay::GetSessionCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "GetSessionCount");

	Params::SteamProRemotePlay_GetSessionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.GetSessionID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SessionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemotePlay::GetSessionID(int32 SessionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "GetSessionID");

	Params::SteamProRemotePlay_GetSessionID Parms{};

	Parms.SessionIndex = SessionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemotePlay.GetSessionSteamID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SessionID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProRemotePlay::GetSessionSteamID(int32 SessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemotePlay", "GetSessionSteamID");

	Params::SteamProRemotePlay_GetSessionSteamID Parms{};

	Parms.SessionID = SessionID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.BeginFileWriteBatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::BeginFileWriteBatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "BeginFileWriteBatch");

	Params::SteamProRemoteStorage_BeginFileWriteBatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.EndFileWriteBatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::EndFileWriteBatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "EndFileWriteBatch");

	Params::SteamProRemoteStorage_EndFileWriteBatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileDelete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileDelete(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileDelete");

	Params::SteamProRemoteStorage_FileDelete Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileExists
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileExists(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileExists");

	Params::SteamProRemoteStorage_FileExists Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileForget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileForget(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileForget");

	Params::SteamProRemoteStorage_FileForget Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FilePersisted
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FilePersisted(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FilePersisted");

	Params::SteamProRemoteStorage_FilePersisted Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileRead
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Buffer                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   DataToRead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::FileRead(const class FString& File, TArray<uint8>* Buffer, int32 DataToRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileRead");

	Params::SteamProRemoteStorage_FileRead Parms{};

	Parms.File = std::move(File);
	Parms.DataToRead = DataToRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Buffer != nullptr)
		*Buffer = std::move(Parms.Buffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileReadAsyncComplete
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FRemoteStorageFileReadAsyncCompleteReadCall                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           Buffer                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   BytesToRead                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileReadAsyncComplete(const struct FRemoteStorageFileReadAsyncComplete& ReadCall, TArray<uint8>* Buffer, int32 BytesToRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileReadAsyncComplete");

	Params::SteamProRemoteStorage_FileReadAsyncComplete Parms{};

	Parms.ReadCall = std::move(ReadCall);
	Parms.BytesToRead = BytesToRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Buffer != nullptr)
		*Buffer = std::move(Parms.Buffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWrite
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Data                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileWrite(const class FString& File, const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileWrite");

	Params::SteamProRemoteStorage_FileWrite Parms{};

	Parms.File = std::move(File);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWriteStreamCancel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCFileWriteStreamHandle        Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileWriteStreamCancel(const struct FUGCFileWriteStreamHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileWriteStreamCancel");

	Params::SteamProRemoteStorage_FileWriteStreamCancel Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWriteStreamClose
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCFileWriteStreamHandle        Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileWriteStreamClose(const struct FUGCFileWriteStreamHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileWriteStreamClose");

	Params::SteamProRemoteStorage_FileWriteStreamClose Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWriteStreamOpen
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCFileWriteStreamHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FUGCFileWriteStreamHandle USteamProRemoteStorage::FileWriteStreamOpen(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileWriteStreamOpen");

	Params::SteamProRemoteStorage_FileWriteStreamOpen Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWriteStreamWriteChunk
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCFileWriteStreamHandle        Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           Data                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::FileWriteStreamWriteChunk(const struct FUGCFileWriteStreamHandle& Handle, const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "FileWriteStreamWriteChunk");

	Params::SteamProRemoteStorage_FileWriteStreamWriteChunk Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetCachedUGCCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::GetCachedUGCCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetCachedUGCCount");

	Params::SteamProRemoteStorage_GetCachedUGCCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetCachedUGCHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ICachedContent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamUGCHandle USteamProRemoteStorage::GetCachedUGCHandle(int32 ICachedContent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetCachedUGCHandle");

	Params::SteamProRemoteStorage_GetCachedUGCHandle Parms{};

	Parms.ICachedContent = ICachedContent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetFileCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::GetFileCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetFileCount");

	Params::SteamProRemoteStorage_GetFileCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetFileNameAndSize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   File                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FileSizeInBytes                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProRemoteStorage::GetFileNameAndSize(int32 File, int32* FileSizeInBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetFileNameAndSize");

	Params::SteamProRemoteStorage_GetFileNameAndSize Parms{};

	Parms.File = File;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FileSizeInBytes != nullptr)
		*FileSizeInBytes = Parms.FileSizeInBytes;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetFileSize
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::GetFileSize(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetFileSize");

	Params::SteamProRemoteStorage_GetFileSize Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetFileTimestamp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::GetFileTimestamp(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetFileTimestamp");

	Params::SteamProRemoteStorage_GetFileTimestamp Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetLocalFileChangeCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::GetLocalFileChangeCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetLocalFileChangeCount");

	Params::SteamProRemoteStorage_GetLocalFileChangeCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetQuota
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   TotalBytes                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AvailableBytes                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::GetQuota(int32* TotalBytes, int32* AvailableBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetQuota");

	Params::SteamProRemoteStorage_GetQuota Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TotalBytes != nullptr)
		*TotalBytes = Parms.TotalBytes;

	if (AvailableBytes != nullptr)
		*AvailableBytes = Parms.AvailableBytes;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetSteamRemoteStorage
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProRemoteStorage*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProRemoteStorage* USteamProRemoteStorage::GetSteamRemoteStorage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetSteamRemoteStorage");

	Params::SteamProRemoteStorage_GetSteamRemoteStorage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetSyncPlatforms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamRemoteStoragePlatform             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamRemoteStoragePlatform USteamProRemoteStorage::GetSyncPlatforms(const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetSyncPlatforms");

	Params::SteamProRemoteStorage_GetSyncPlatforms Parms{};

	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetUGCDetails
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamUGCHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FileSizeInBytes                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamIDOwner                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::GetUGCDetails(const struct FSteamUGCHandle& Handle, int32* AppID, class FString* Param_Name, int32* FileSizeInBytes, struct FSteamID* SteamIDOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetUGCDetails");

	Params::SteamProRemoteStorage_GetUGCDetails Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AppID != nullptr)
		*AppID = Parms.AppID;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	if (FileSizeInBytes != nullptr)
		*FileSizeInBytes = Parms.FileSizeInBytes;

	if (SteamIDOwner != nullptr)
		*SteamIDOwner = std::move(Parms.SteamIDOwner);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.GetUGCDownloadProgress
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamUGCHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   BytesDownloaded                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesExpected                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::GetUGCDownloadProgress(const struct FSteamUGCHandle& Handle, int32* BytesDownloaded, int32* BytesExpected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "GetUGCDownloadProgress");

	Params::SteamProRemoteStorage_GetUGCDownloadProgress Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BytesDownloaded != nullptr)
		*BytesDownloaded = Parms.BytesDownloaded;

	if (BytesExpected != nullptr)
		*BytesExpected = Parms.BytesExpected;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.IsCloudEnabledForAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::IsCloudEnabledForAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "IsCloudEnabledForAccount");

	Params::SteamProRemoteStorage_IsCloudEnabledForAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.IsCloudEnabledForApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::IsCloudEnabledForApp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "IsCloudEnabledForApp");

	Params::SteamProRemoteStorage_IsCloudEnabledForApp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.SetCloudEnabledForApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::SetCloudEnabledForApp(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "SetCloudEnabledForApp");

	Params::SteamProRemoteStorage_SetCloudEnabledForApp Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemoteStorage.SetSyncPlatforms
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamRemoteStoragePlatform             RemoteStoragePlatform                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProRemoteStorage::SetSyncPlatforms(const class FString& File, ESteamRemoteStoragePlatform RemoteStoragePlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "SetSyncPlatforms");

	Params::SteamProRemoteStorage_SetSyncPlatforms Parms{};

	Parms.File = std::move(File);
	Parms.RemoteStoragePlatform = RemoteStoragePlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.UGCRead
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamUGCHandle                  Content                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<uint8>                           OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   DataToRead                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUGCReadAction                     Action                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProRemoteStorage::UGCRead(const struct FSteamUGCHandle& Content, TArray<uint8>* OutData, int32 DataToRead, int32 Offset, ESteamUGCReadAction Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProRemoteStorage", "UGCRead");

	Params::SteamProRemoteStorage_UGCRead Parms{};

	Parms.Content = std::move(Content);
	Parms.DataToRead = DataToRead;
	Parms.Offset = Offset;
	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProRemoteStorage.FileReadAsync
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageFileReadAsyncComplete& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesToRead                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::FileReadAsync(const TDelegate<void(struct FRemoteStorageFileReadAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, int32 Offset, int32 BytesToRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemoteStorage", "FileReadAsync");

	Params::SteamProRemoteStorage_FileReadAsync Parms{};

	Parms.Callback = Callback;
	Parms.File = std::move(File);
	Parms.Offset = Offset;
	Parms.BytesToRead = BytesToRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemoteStorage.FileShare
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageFileShareResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::FileShare(const TDelegate<void(struct FRemoteStorageFileShareResult& Data, bool bWasSuccessful)>& Callback, const class FString& File)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemoteStorage", "FileShare");

	Params::SteamProRemoteStorage_FileShare Parms{};

	Parms.Callback = Callback;
	Parms.File = std::move(File);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemoteStorage.FileWriteAsync
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageFileWriteAsyncComplete& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           File                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           Data                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::FileWriteAsync(const TDelegate<void(struct FRemoteStorageFileWriteAsyncComplete& Data, bool bWasSuccessful)>& Callback, const class FString& File, const TArray<uint8>& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemoteStorage", "FileWriteAsync");

	Params::SteamProRemoteStorage_FileWriteAsync Parms{};

	Parms.Callback = Callback;
	Parms.File = std::move(File);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemoteStorage.UGCDownload
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  Content                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::UGCDownload(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemoteStorage", "UGCDownload");

	Params::SteamProRemoteStorage_UGCDownload Parms{};

	Parms.Callback = Callback;
	Parms.Content = std::move(Content);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProRemoteStorage.UGCDownloadToLocation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  Content                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Location                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProRemoteStorage::UGCDownloadToLocation(const TDelegate<void(struct FRemoteStorageDownloadUGCResult& Data, bool bWasSuccessful)>& Callback, const struct FSteamUGCHandle& Content, const class FString& Location, int32 Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProRemoteStorage", "UGCDownloadToLocation");

	Params::SteamProRemoteStorage_UGCDownloadToLocation Parms{};

	Parms.Callback = Callback;
	Parms.Content = std::move(Content);
	Parms.Location = std::move(Location);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProScreenshots.AddScreenshotToLibrary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ThumbnailFilename                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FScreenshotHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FScreenshotHandle USteamProScreenshots::AddScreenshotToLibrary(const class FString& Filename, const class FString& ThumbnailFilename, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "AddScreenshotToLibrary");

	Params::SteamProScreenshots_AddScreenshotToLibrary Parms{};

	Parms.Filename = std::move(Filename);
	Parms.ThumbnailFilename = std::move(ThumbnailFilename);
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.AddVRScreenshotToLibrary
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamVRScreenshotType                  EType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VRFileName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FScreenshotHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FScreenshotHandle USteamProScreenshots::AddVRScreenshotToLibrary(ESteamVRScreenshotType EType, const class FString& Filename, const class FString& VRFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "AddVRScreenshotToLibrary");

	Params::SteamProScreenshots_AddVRScreenshotToLibrary Parms{};

	Parms.EType = EType;
	Parms.Filename = std::move(Filename);
	Parms.VRFileName = std::move(VRFileName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.GetSteamScreenshots
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProScreenshots*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProScreenshots* USteamProScreenshots::GetSteamScreenshots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "GetSteamScreenshots");

	Params::SteamProScreenshots_GetSteamScreenshots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.HookScreenshots
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bHook                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProScreenshots::HookScreenshots(bool bHook)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "HookScreenshots");

	Params::SteamProScreenshots_HookScreenshots Parms{};

	Parms.bHook = bHook;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProScreenshots.IsScreenshotsHooked
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProScreenshots::IsScreenshotsHooked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "IsScreenshotsHooked");

	Params::SteamProScreenshots_IsScreenshotsHooked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.SetLocation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScreenshotHandle                Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Location                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProScreenshots::SetLocation(const struct FScreenshotHandle& Handle, const class FString& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "SetLocation");

	Params::SteamProScreenshots_SetLocation Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.TagPublishedFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScreenshotHandle                Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProScreenshots::TagPublishedFile(const struct FScreenshotHandle& Handle, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "TagPublishedFile");

	Params::SteamProScreenshots_TagPublishedFile Parms{};

	Parms.Handle = std::move(Handle);
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.TagUser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FScreenshotHandle                Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProScreenshots::TagUser(const struct FScreenshotHandle& Handle, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "TagUser");

	Params::SteamProScreenshots_TagUser Parms{};

	Parms.Handle = std::move(Handle);
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProScreenshots.TriggerScreenshot
// (Final, Native, Static, Public, BlueprintCallable)

void USteamProScreenshots::TriggerScreenshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "TriggerScreenshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProScreenshots.WriteScreenshot
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           PubRGB                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FScreenshotHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FScreenshotHandle USteamProScreenshots::WriteScreenshot(const TArray<uint8>& PubRGB, int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProScreenshots", "WriteScreenshot");

	Params::SteamProScreenshots_WriteScreenshot Parms{};

	Parms.PubRGB = std::move(PubRGB);
	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddContentDescriptor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamUGCContentDescriptorID            DescId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddContentDescriptor(const struct FUGCUpdateHandle& Handle, ESteamUGCContentDescriptorID DescId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddContentDescriptor");

	Params::SteamProUGC_AddContentDescriptor Parms{};

	Parms.Handle = std::move(Handle);
	Parms.DescId = DescId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddExcludedTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddExcludedTag(const struct FUGCQueryHandle& Handle, const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddExcludedTag");

	Params::SteamProUGC_AddExcludedTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddItemKeyValueTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddItemKeyValueTag(const struct FUGCUpdateHandle& Handle, const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddItemKeyValueTag");

	Params::SteamProUGC_AddItemKeyValueTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddItemPreviewFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PreviewFile                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamItemPreviewType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddItemPreviewFile(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile, ESteamItemPreviewType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddItemPreviewFile");

	Params::SteamProUGC_AddItemPreviewFile Parms{};

	Parms.Handle = std::move(Handle);
	Parms.PreviewFile = std::move(PreviewFile);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddItemPreviewVideo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           VideoID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddItemPreviewVideo(const struct FUGCUpdateHandle& Handle, const class FString& VideoID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddItemPreviewVideo");

	Params::SteamProUGC_AddItemPreviewVideo Parms{};

	Parms.Handle = std::move(Handle);
	Parms.VideoID = std::move(VideoID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddRequiredKeyValueTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddRequiredKeyValueTag(const struct FUGCQueryHandle& Handle, const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddRequiredKeyValueTag");

	Params::SteamProUGC_AddRequiredKeyValueTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddRequiredTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddRequiredTag(const struct FUGCQueryHandle& Handle, const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddRequiredTag");

	Params::SteamProUGC_AddRequiredTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddRequiredTagGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   TagGroups                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::AddRequiredTagGroup(const struct FUGCQueryHandle& Handle, const TArray<class FString>& TagGroups)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "AddRequiredTagGroup");

	Params::SteamProUGC_AddRequiredTagGroup Parms{};

	Parms.Handle = std::move(Handle);
	Parms.TagGroups = std::move(TagGroups);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.BInitWorkshopForGameServer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   WorkshopDepotID                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Folder                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::BInitWorkshopForGameServer(int32 WorkshopDepotID, const class FString& Folder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "BInitWorkshopForGameServer");

	Params::SteamProUGC_BInitWorkshopForGameServer Parms{};

	Parms.WorkshopDepotID = WorkshopDepotID;
	Parms.Folder = std::move(Folder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.CreateQueryAllUGCRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamUGCQuery                          QueryType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUGCMatchingUGCType                FileType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CreatorAppID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumerAppID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCQueryHandle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FUGCQueryHandle USteamProUGC::CreateQueryAllUGCRequest(ESteamUGCQuery QueryType, ESteamUGCMatchingUGCType FileType, int32 CreatorAppID, int32 ConsumerAppID, int32 Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "CreateQueryAllUGCRequest");

	Params::SteamProUGC_CreateQueryAllUGCRequest Parms{};

	Parms.QueryType = QueryType;
	Parms.FileType = FileType;
	Parms.CreatorAppID = CreatorAppID;
	Parms.ConsumerAppID = ConsumerAppID;
	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.CreateQueryUGCDetailsRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FUGCQueryHandle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FUGCQueryHandle USteamProUGC::CreateQueryUGCDetailsRequest(const TArray<struct FPublishedFileID>& PublishedFileIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "CreateQueryUGCDetailsRequest");

	Params::SteamProUGC_CreateQueryUGCDetailsRequest Parms{};

	Parms.PublishedFileIDs = std::move(PublishedFileIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.CreateQueryUserUGCRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamUserUGCList                       ListType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUGCMatchingUGCType                MatchingUGCType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUserUGCListSortOrder              SortOrder                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CreatorAppID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumerAppID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCQueryHandle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FUGCQueryHandle USteamProUGC::CreateQueryUserUGCRequest(const struct FSteamID& SteamID, ESteamUserUGCList ListType, ESteamUGCMatchingUGCType MatchingUGCType, ESteamUserUGCListSortOrder SortOrder, int32 CreatorAppID, int32 ConsumerAppID, int32 Page)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "CreateQueryUserUGCRequest");

	Params::SteamProUGC_CreateQueryUserUGCRequest Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.ListType = ListType;
	Parms.MatchingUGCType = MatchingUGCType;
	Parms.SortOrder = SortOrder;
	Parms.CreatorAppID = CreatorAppID;
	Parms.ConsumerAppID = ConsumerAppID;
	Parms.Page = Page;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.DownloadItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bHighPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::DownloadItem(const struct FPublishedFileID& PublishedFileID, bool bHighPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "DownloadItem");

	Params::SteamProUGC_DownloadItem Parms{};

	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.bHighPriority = bHighPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetItemDownloadInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   BytesDownloaded                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesTotal                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetItemDownloadInfo(const struct FPublishedFileID& PublishedFileID, int32* BytesDownloaded, int32* BytesTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetItemDownloadInfo");

	Params::SteamProUGC_GetItemDownloadInfo Parms{};

	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BytesDownloaded != nullptr)
		*BytesDownloaded = Parms.BytesDownloaded;

	if (BytesTotal != nullptr)
		*BytesTotal = Parms.BytesTotal;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetItemInstallInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   SizeOnDisk                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Folder                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Timestamp                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetItemInstallInfo(const struct FPublishedFileID& PublishedFileID, int32* SizeOnDisk, class FString* Folder, int32* Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetItemInstallInfo");

	Params::SteamProUGC_GetItemInstallInfo Parms{};

	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SizeOnDisk != nullptr)
		*SizeOnDisk = Parms.SizeOnDisk;

	if (Folder != nullptr)
		*Folder = std::move(Parms.Folder);

	if (Timestamp != nullptr)
		*Timestamp = Parms.Timestamp;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetItemState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<ESteamItemState>                 States                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetItemState(const struct FPublishedFileID& PublishedFileID, TArray<ESteamItemState>* States)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetItemState");

	Params::SteamProUGC_GetItemState Parms{};

	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (States != nullptr)
		*States = std::move(Parms.States);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetItemUpdateProgress
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   BytesProcessed                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BytesTotal                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamItemUpdateStatus                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamItemUpdateStatus USteamProUGC::GetItemUpdateProgress(const struct FUGCUpdateHandle& Handle, int32* BytesProcessed, int32* BytesTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetItemUpdateProgress");

	Params::SteamProUGC_GetItemUpdateProgress Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BytesProcessed != nullptr)
		*BytesProcessed = Parms.BytesProcessed;

	if (BytesTotal != nullptr)
		*BytesTotal = Parms.BytesTotal;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetNumSubscribedItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetNumSubscribedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetNumSubscribedItems");

	Params::SteamProUGC_GetNumSubscribedItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCAdditionalPreview
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PreviewIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           URLOrVideoID                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OriginalFileName                                       (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamItemPreviewType                   PreviewType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCAdditionalPreview(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 PreviewIndex, class FString* URLOrVideoID, class FString* OriginalFileName, ESteamItemPreviewType* PreviewType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCAdditionalPreview");

	Params::SteamProUGC_GetQueryUGCAdditionalPreview Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.PreviewIndex = PreviewIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (URLOrVideoID != nullptr)
		*URLOrVideoID = std::move(Parms.URLOrVideoID);

	if (OriginalFileName != nullptr)
		*OriginalFileName = std::move(Parms.OriginalFileName);

	if (PreviewType != nullptr)
		*PreviewType = Parms.PreviewType;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCChildren
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MaxEntries                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCChildren(const struct FUGCQueryHandle& Handle, int32 Param_Index, TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCChildren");

	Params::SteamProUGC_GetQueryUGCChildren Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.MaxEntries = MaxEntries;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PublishedFileIDs != nullptr)
		*PublishedFileIDs = std::move(Parms.PublishedFileIDs);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCKeyValueTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   KeyValueTagIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCKeyValueTag(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 KeyValueTagIndex, class FString* Key, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCKeyValueTag");

	Params::SteamProUGC_GetQueryUGCKeyValueTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.KeyValueTagIndex = KeyValueTagIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCMetadata
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MetaData                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MetadataSize                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCMetadata(const struct FUGCQueryHandle& Handle, int32 Param_Index, class FString* MetaData, int32 MetadataSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCMetadata");

	Params::SteamProUGC_GetQueryUGCMetadata Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.MetadataSize = MetadataSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MetaData != nullptr)
		*MetaData = std::move(Parms.MetaData);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCNumAdditionalPreviews
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetQueryUGCNumAdditionalPreviews(const struct FUGCQueryHandle& Handle, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCNumAdditionalPreviews");

	Params::SteamProUGC_GetQueryUGCNumAdditionalPreviews Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCNumKeyValueTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetQueryUGCNumKeyValueTags(const struct FUGCQueryHandle& Handle, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCNumKeyValueTags");

	Params::SteamProUGC_GetQueryUGCNumKeyValueTags Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCNumTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetQueryUGCNumTags(const struct FUGCQueryHandle& Handle, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCNumTags");

	Params::SteamProUGC_GetQueryUGCNumTags Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCPreviewURL
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           URL                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCPreviewURL(const struct FUGCQueryHandle& Handle, int32 Param_Index, class FString* URL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCPreviewURL");

	Params::SteamProUGC_GetQueryUGCPreviewURL Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (URL != nullptr)
		*URL = std::move(Parms.URL);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamUGCDetails                 Details                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCResult(const struct FUGCQueryHandle& Handle, int32 Param_Index, struct FSteamUGCDetails* Details)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCResult");

	Params::SteamProUGC_GetQueryUGCResult Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Details != nullptr)
		*Details = std::move(Parms.Details);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCStatistic
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamItemStatistic                     StatType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           StatValue                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCStatistic(const struct FUGCQueryHandle& Handle, int32 Param_Index, ESteamItemStatistic StatType, class FString* StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCStatistic");

	Params::SteamProUGC_GetQueryUGCStatistic Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.StatType = StatType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StatValue != nullptr)
		*StatValue = std::move(Parms.StatValue);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IndexTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCTag(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 IndexTag, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCTag");

	Params::SteamProUGC_GetQueryUGCTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.IndexTag = IndexTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetQueryUGCTagDisplayName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IndexTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::GetQueryUGCTagDisplayName(const struct FUGCQueryHandle& Handle, int32 Param_Index, int32 IndexTag, class FString* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetQueryUGCTagDisplayName");

	Params::SteamProUGC_GetQueryUGCTagDisplayName Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.IndexTag = IndexTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetSteamUGC
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProUGC*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProUGC* USteamProUGC::GetSteamUGC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetSteamUGC");

	Params::SteamProUGC_GetSteamUGC Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetSubscribedItems
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MaxEntries                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetSubscribedItems(TArray<struct FPublishedFileID>* PublishedFileIDs, int32 MaxEntries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetSubscribedItems");

	Params::SteamProUGC_GetSubscribedItems Parms{};

	Parms.MaxEntries = MaxEntries;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PublishedFileIDs != nullptr)
		*PublishedFileIDs = std::move(Parms.PublishedFileIDs);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.GetUserContentDescriptorPreferences
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<ESteamUGCContentDescriptorID>    Descriptors                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   MaxEntries                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUGC::GetUserContentDescriptorPreferences(const TArray<ESteamUGCContentDescriptorID>& Descriptors, int32 MaxEntries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "GetUserContentDescriptorPreferences");

	Params::SteamProUGC_GetUserContentDescriptorPreferences Parms{};

	Parms.Descriptors = std::move(Descriptors);
	Parms.MaxEntries = MaxEntries;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.ReleaseQueryUGCRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::ReleaseQueryUGCRequest(const struct FUGCQueryHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "ReleaseQueryUGCRequest");

	Params::SteamProUGC_ReleaseQueryUGCRequest Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.RemoveContentDescriptor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamUGCContentDescriptorID            DescId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::RemoveContentDescriptor(const struct FUGCUpdateHandle& Handle, ESteamUGCContentDescriptorID DescId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "RemoveContentDescriptor");

	Params::SteamProUGC_RemoveContentDescriptor Parms{};

	Parms.Handle = std::move(Handle);
	Parms.DescId = DescId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.RemoveItemKeyValueTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::RemoveItemKeyValueTags(const struct FUGCUpdateHandle& Handle, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "RemoveItemKeyValueTags");

	Params::SteamProUGC_RemoveItemKeyValueTags Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.RemoveItemPreview
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::RemoveItemPreview(const struct FUGCUpdateHandle& Handle, int32 Param_Index)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "RemoveItemPreview");

	Params::SteamProUGC_RemoveItemPreview Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetAllowCachedResponse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   MaxAgeSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetAllowCachedResponse(const struct FUGCQueryHandle& Handle, int32 MaxAgeSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetAllowCachedResponse");

	Params::SteamProUGC_SetAllowCachedResponse Parms{};

	Parms.Handle = std::move(Handle);
	Parms.MaxAgeSeconds = MaxAgeSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetCloudFileNameFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           MatchCloudFileName                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetCloudFileNameFilter(const struct FUGCQueryHandle& Handle, const class FString& MatchCloudFileName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetCloudFileNameFilter");

	Params::SteamProUGC_SetCloudFileNameFilter Parms{};

	Parms.Handle = std::move(Handle);
	Parms.MatchCloudFileName = std::move(MatchCloudFileName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemContent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ContentFolder                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemContent(const struct FUGCUpdateHandle& Handle, const class FString& ContentFolder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemContent");

	Params::SteamProUGC_SetItemContent Parms{};

	Parms.Handle = std::move(Handle);
	Parms.ContentFolder = std::move(ContentFolder);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemDescription
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Description                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemDescription(const struct FUGCUpdateHandle& Handle, const class FString& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemDescription");

	Params::SteamProUGC_SetItemDescription Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemMetadata
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           MetaData                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemMetadata(const struct FUGCUpdateHandle& Handle, const class FString& MetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemMetadata");

	Params::SteamProUGC_SetItemMetadata Parms{};

	Parms.Handle = std::move(Handle);
	Parms.MetaData = std::move(MetaData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemPreview
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           PreviewFile                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemPreview(const struct FUGCUpdateHandle& Handle, const class FString& PreviewFile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemPreview");

	Params::SteamProUGC_SetItemPreview Parms{};

	Parms.Handle = std::move(Handle);
	Parms.PreviewFile = std::move(PreviewFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Tags                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemTags(const struct FUGCUpdateHandle& Handle, const TArray<class FString>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemTags");

	Params::SteamProUGC_SetItemTags Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemTitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemTitle(const struct FUGCUpdateHandle& Handle, const class FString& Title)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemTitle");

	Params::SteamProUGC_SetItemTitle Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Title = std::move(Title);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemUpdateLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Language                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemUpdateLanguage(const struct FUGCUpdateHandle& Handle, const class FString& Language)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemUpdateLanguage");

	Params::SteamProUGC_SetItemUpdateLanguage Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Language = std::move(Language);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetItemVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamRemoteStoragePublishedFileVisibilityVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetItemVisibility(const struct FUGCUpdateHandle& Handle, ESteamRemoteStoragePublishedFileVisibility Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetItemVisibility");

	Params::SteamProUGC_SetItemVisibility Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Visibility = Visibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetLanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Language                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetLanguage(const struct FUGCQueryHandle& Handle, const class FString& Language)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetLanguage");

	Params::SteamProUGC_SetLanguage Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Language = std::move(Language);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetMatchAnyTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bMatchAnyTag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetMatchAnyTag(const struct FUGCQueryHandle& Handle, bool bMatchAnyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetMatchAnyTag");

	Params::SteamProUGC_SetMatchAnyTag Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bMatchAnyTag = bMatchAnyTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetRankedByTrendDays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetRankedByTrendDays(const struct FUGCQueryHandle& Handle, int32 Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetRankedByTrendDays");

	Params::SteamProUGC_SetRankedByTrendDays Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnAdditionalPreviews
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnAdditionalPreviews                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnAdditionalPreviews(const struct FUGCQueryHandle& Handle, bool bReturnAdditionalPreviews)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnAdditionalPreviews");

	Params::SteamProUGC_SetReturnAdditionalPreviews Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnAdditionalPreviews = bReturnAdditionalPreviews;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnChildren
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnChildren                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnChildren(const struct FUGCQueryHandle& Handle, bool bReturnChildren)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnChildren");

	Params::SteamProUGC_SetReturnChildren Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnChildren = bReturnChildren;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnKeyValueTags
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnKeyValueTags                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnKeyValueTags(const struct FUGCQueryHandle& Handle, bool bReturnKeyValueTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnKeyValueTags");

	Params::SteamProUGC_SetReturnKeyValueTags Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnKeyValueTags = bReturnKeyValueTags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnLongDescription
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnLongDescription                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnLongDescription(const struct FUGCQueryHandle& Handle, bool bReturnLongDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnLongDescription");

	Params::SteamProUGC_SetReturnLongDescription Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnLongDescription = bReturnLongDescription;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnMetadata
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnMetadata                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnMetadata(const struct FUGCQueryHandle& Handle, bool bReturnMetadata)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnMetadata");

	Params::SteamProUGC_SetReturnMetadata Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnMetadata = bReturnMetadata;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnOnlyIDs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnOnlyIDs                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnOnlyIDs(const struct FUGCQueryHandle& Handle, bool bReturnOnlyIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnOnlyIDs");

	Params::SteamProUGC_SetReturnOnlyIDs Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnOnlyIDs = bReturnOnlyIDs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnPlaytimeStats
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Days                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnPlaytimeStats(const struct FUGCQueryHandle& Handle, int32 Days)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnPlaytimeStats");

	Params::SteamProUGC_SetReturnPlaytimeStats Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Days = Days;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetReturnTotalOnly
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bReturnTotalOnly                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetReturnTotalOnly(const struct FUGCQueryHandle& Handle, bool bReturnTotalOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetReturnTotalOnly");

	Params::SteamProUGC_SetReturnTotalOnly Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bReturnTotalOnly = bReturnTotalOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetSearchText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           SearchText                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetSearchText(const struct FUGCQueryHandle& Handle, const class FString& SearchText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SetSearchText");

	Params::SteamProUGC_SetSearchText Parms{};

	Parms.Handle = std::move(Handle);
	Parms.SearchText = std::move(SearchText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.ShowWorkshopEULA
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::ShowWorkshopEULA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "ShowWorkshopEULA");

	Params::SteamProUGC_ShowWorkshopEULA Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.StartItemUpdate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ConsumerAppID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FUGCUpdateHandle                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FUGCUpdateHandle USteamProUGC::StartItemUpdate(int32 ConsumerAppID, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "StartItemUpdate");

	Params::SteamProUGC_StartItemUpdate Parms{};

	Parms.ConsumerAppID = ConsumerAppID;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SuspendDownloads
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bSuspend                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::SuspendDownloads(bool bSuspend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "SuspendDownloads");

	Params::SteamProUGC_SuspendDownloads Parms{};

	Parms.bSuspend = bSuspend;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.UpdateItemPreviewFile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PreviewFile                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::UpdateItemPreviewFile(const struct FUGCUpdateHandle& Handle, int32 Param_Index, const class FString& PreviewFile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "UpdateItemPreviewFile");

	Params::SteamProUGC_UpdateItemPreviewFile Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.PreviewFile = std::move(PreviewFile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.UpdateItemPreviewVideo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PreviewVideo                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::UpdateItemPreviewVideo(const struct FUGCUpdateHandle& Handle, int32 Param_Index, const class FString& PreviewVideo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUGC", "UpdateItemPreviewVideo");

	Params::SteamProUGC_UpdateItemPreviewVideo Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Param_Index = Param_Index;
	Parms.PreviewVideo = std::move(PreviewVideo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.AddAppDependency
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FAddAppDependencyResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::AddAppDependency(const TDelegate<void(struct FAddAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "AddAppDependency");

	Params::SteamProUGC_AddAppDependency Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.AddDependency
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FAddUGCDependencyResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ChildPublishedFileId                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::AddDependency(const TDelegate<void(struct FAddUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "AddDependency");

	Params::SteamProUGC_AddDependency Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.ChildPublishedFileId = std::move(ChildPublishedFileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.AddItemToFavorites
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::AddItemToFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "AddItemToFavorites");

	Params::SteamProUGC_AddItemToFavorites Parms{};

	Parms.Callback = Callback;
	Parms.AppID = AppID;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.CreateItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FCreateItemResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumerAppID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamWorkshopFileType                  FileType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::CreateItem(const TDelegate<void(struct FCreateItemResult& Data, bool bWasSuccessful)>& Callback, int32 ConsumerAppID, ESteamWorkshopFileType FileType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "CreateItem");

	Params::SteamProUGC_CreateItem Parms{};

	Parms.Callback = Callback;
	Parms.ConsumerAppID = ConsumerAppID;
	Parms.FileType = FileType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.DeleteItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FUGCDeleteItemResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::DeleteItem(const TDelegate<void(struct FUGCDeleteItemResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "DeleteItem");

	Params::SteamProUGC_DeleteItem Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.GetAppDependencies
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGetAppDependenciesResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::GetAppDependencies(const TDelegate<void(struct FGetAppDependenciesResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "GetAppDependencies");

	Params::SteamProUGC_GetAppDependencies Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.GetUserItemVote
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGetUserItemVoteResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::GetUserItemVote(const TDelegate<void(struct FGetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "GetUserItemVote");

	Params::SteamProUGC_GetUserItemVote Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.GetWorkshopEULAStatus
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FWorkshopEULAStatus& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::GetWorkshopEULAStatus(const TDelegate<void(struct FWorkshopEULAStatus& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "GetWorkshopEULAStatus");

	Params::SteamProUGC_GetWorkshopEULAStatus Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.RemoveAppDependency
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoveAppDependencyResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::RemoveAppDependency(const TDelegate<void(struct FRemoveAppDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "RemoveAppDependency");

	Params::SteamProUGC_RemoveAppDependency Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.RemoveDependency
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ParentPublishedFileID                                  (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ChildPublishedFileId                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::RemoveDependency(const TDelegate<void(struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& ParentPublishedFileID, const struct FPublishedFileID& ChildPublishedFileId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "RemoveDependency");

	Params::SteamProUGC_RemoveDependency Parms{};

	Parms.Callback = Callback;
	Parms.ParentPublishedFileID = std::move(ParentPublishedFileID);
	Parms.ChildPublishedFileId = std::move(ChildPublishedFileId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.RemoveItemFromFavorites
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::RemoveItemFromFavorites(const TDelegate<void(struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)>& Callback, int32 AppID, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "RemoveItemFromFavorites");

	Params::SteamProUGC_RemoveItemFromFavorites Parms{};

	Parms.Callback = Callback;
	Parms.AppID = AppID;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.SendQueryUGCRequest
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::SendQueryUGCRequest(const TDelegate<void(struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful)>& Callback, const struct FUGCQueryHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "SendQueryUGCRequest");

	Params::SteamProUGC_SendQueryUGCRequest Parms{};

	Parms.Callback = Callback;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.SetAllowLegacyUpload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bAllowLegacyUpload                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUGC::SetAllowLegacyUpload(const struct FUGCUpdateHandle& Handle, bool bAllowLegacyUpload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "SetAllowLegacyUpload");

	Params::SteamProUGC_SetAllowLegacyUpload Parms{};

	Parms.Handle = std::move(Handle);
	Parms.bAllowLegacyUpload = bAllowLegacyUpload;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUGC.SetUserItemVote
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSetUserItemVoteResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bVoteUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::SetUserItemVote(const TDelegate<void(struct FSetUserItemVoteResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID, bool bVoteUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "SetUserItemVote");

	Params::SteamProUGC_SetUserItemVote Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.bVoteUp = bVoteUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.StartPlaytimeTracking
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPublishedFileID>         PublishedFileID                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProUGC::StartPlaytimeTracking(const TDelegate<void(struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "StartPlaytimeTracking");

	Params::SteamProUGC_StartPlaytimeTracking Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.StopPlaytimeTracking
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProUGC::StopPlaytimeTracking(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback, const TArray<struct FPublishedFileID>& PublishedFileIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "StopPlaytimeTracking");

	Params::SteamProUGC_StopPlaytimeTracking Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileIDs = std::move(PublishedFileIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.StopPlaytimeTrackingForAllItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::StopPlaytimeTrackingForAllItems(const TDelegate<void(struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "StopPlaytimeTrackingForAllItems");

	Params::SteamProUGC_StopPlaytimeTrackingForAllItems Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.SubmitItemUpdate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FSubmitItemUpdateResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ChangeNote                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUGC::SubmitItemUpdate(const TDelegate<void(struct FSubmitItemUpdateResult& Data, bool bWasSuccessful)>& Callback, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "SubmitItemUpdate");

	Params::SteamProUGC_SubmitItemUpdate Parms{};

	Parms.Callback = Callback;
	Parms.Handle = std::move(Handle);
	Parms.ChangeNote = std::move(ChangeNote);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.SubscribeItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::SubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "SubscribeItem");

	Params::SteamProUGC_SubscribeItem Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUGC.UnsubscribeItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUGC::UnsubscribeItem(const TDelegate<void(struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)>& Callback, const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUGC", "UnsubscribeItem");

	Params::SteamProUGC_UnsubscribeItem Parms{};

	Parms.Callback = Callback;
	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems.StopPlaytimeTrackingForAllItemsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems* USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems::StopPlaytimeTrackingForAllItemsAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems", "StopPlaytimeTrackingForAllItemsAsync");

	Params::SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems_StopPlaytimeTrackingForAllItemsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FStopPlaytimeTrackingResult      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems::HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionStopPlaytimeTrackingForAllItems_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTracking.StopPlaytimeTrackingAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionStopPlaytimeTracking*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionStopPlaytimeTracking* USteamCoreProUGCAsyncActionStopPlaytimeTracking::StopPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionStopPlaytimeTracking", "StopPlaytimeTrackingAsync");

	Params::SteamCoreProUGCAsyncActionStopPlaytimeTracking_StopPlaytimeTrackingAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileIDs = std::move(PublishedFileIDs);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStopPlaytimeTracking.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FStopPlaytimeTrackingResult      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionStopPlaytimeTracking::HandleCallback(const struct FStopPlaytimeTrackingResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionStopPlaytimeTracking", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionStopPlaytimeTracking_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStartPlaytimeTracking.StartPlaytimeTrackingAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPublishedFileID>         PublishedFileIDs                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionStartPlaytimeTracking*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionStartPlaytimeTracking* USteamCoreProUGCAsyncActionStartPlaytimeTracking::StartPlaytimeTrackingAsync(class UObject* WorldContextObject, const TArray<struct FPublishedFileID>& PublishedFileIDs, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionStartPlaytimeTracking", "StartPlaytimeTrackingAsync");

	Params::SteamCoreProUGCAsyncActionStartPlaytimeTracking_StartPlaytimeTrackingAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileIDs = std::move(PublishedFileIDs);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionStartPlaytimeTracking.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FStartPlaytimeTrackingResult     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionStartPlaytimeTracking::HandleCallback(const struct FStartPlaytimeTrackingResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionStartPlaytimeTracking", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionStartPlaytimeTracking_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionUnsubscribeItem.UnsubscribeItemAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileIDs                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionUnsubscribeItem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionUnsubscribeItem* USteamCoreProUGCAsyncActionUnsubscribeItem::UnsubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionUnsubscribeItem", "UnsubscribeItemAsync");

	Params::SteamCoreProUGCAsyncActionUnsubscribeItem_UnsubscribeItemAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileIDs = std::move(PublishedFileIDs);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionUnsubscribeItem.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRemoteStorageSubscribePublishedFileResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionUnsubscribeItem::HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionUnsubscribeItem", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionUnsubscribeItem_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSubscribeItem.SubscribeItemAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileIDs                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionSubscribeItem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionSubscribeItem* USteamCoreProUGCAsyncActionSubscribeItem::SubscribeItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileIDs, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionSubscribeItem", "SubscribeItemAsync");

	Params::SteamCoreProUGCAsyncActionSubscribeItem_SubscribeItemAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileIDs = std::move(PublishedFileIDs);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSubscribeItem.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRemoteStorageSubscribePublishedFileResultData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionSubscribeItem::HandleCallback(const struct FRemoteStorageSubscribePublishedFileResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionSubscribeItem", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionSubscribeItem_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveItemFromFavorites.RemoveItemFromFavoritesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionRemoveItemFromFavorites*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionRemoveItemFromFavorites* USteamCoreProUGCAsyncActionRemoveItemFromFavorites::RemoveItemFromFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionRemoveItemFromFavorites", "RemoveItemFromFavoritesAsync");

	Params::SteamCoreProUGCAsyncActionRemoveItemFromFavorites_RemoveItemFromFavoritesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveItemFromFavorites.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUserFavoriteItemsListChanged    Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionRemoveItemFromFavorites::HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionRemoveItemFromFavorites", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionRemoveItemFromFavorites_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddItemToFavorites.AddItemToFavoritesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionAddItemToFavorites*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionAddItemToFavorites* USteamCoreProUGCAsyncActionAddItemToFavorites::AddItemToFavoritesAsync(class UObject* WorldContextObject, int32 AppID, const struct FPublishedFileID& PublishedFileID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionAddItemToFavorites", "AddItemToFavoritesAsync");

	Params::SteamCoreProUGCAsyncActionAddItemToFavorites_AddItemToFavoritesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AppID = AppID;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddItemToFavorites.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUserFavoriteItemsListChanged    Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionAddItemToFavorites::HandleCallback(const struct FUserFavoriteItemsListChanged& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionAddItemToFavorites", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionAddItemToFavorites_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionGetUserItemVote.GetUserItemVoteAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionGetUserItemVote*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionGetUserItemVote* USteamCoreProUGCAsyncActionGetUserItemVote::GetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionGetUserItemVote", "GetUserItemVoteAsync");

	Params::SteamCoreProUGCAsyncActionGetUserItemVote_GetUserItemVoteAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionGetUserItemVote.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGetUserItemVoteResult           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionGetUserItemVote::HandleCallback(const struct FGetUserItemVoteResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionGetUserItemVote", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionGetUserItemVote_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSetUserItemVote.SetUserItemVoteAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bVoteUp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionSetUserItemVote*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionSetUserItemVote* USteamCoreProUGCAsyncActionSetUserItemVote::SetUserItemVoteAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bVoteUp, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionSetUserItemVote", "SetUserItemVoteAsync");

	Params::SteamCoreProUGCAsyncActionSetUserItemVote_SetUserItemVoteAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.bVoteUp = bVoteUp;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSetUserItemVote.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSetUserItemVoteResult           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionSetUserItemVote::HandleCallback(const struct FSetUserItemVoteResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionSetUserItemVote", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionSetUserItemVote_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSubmitItemUpdate.SubmitItemUpdateAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCUpdateHandle                 Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ChangeNote                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionSubmitItemUpdate*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionSubmitItemUpdate* USteamCoreProUGCAsyncActionSubmitItemUpdate::SubmitItemUpdateAsync(class UObject* WorldContextObject, const struct FUGCUpdateHandle& Handle, const class FString& ChangeNote, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionSubmitItemUpdate", "SubmitItemUpdateAsync");

	Params::SteamCoreProUGCAsyncActionSubmitItemUpdate_SubmitItemUpdateAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);
	Parms.ChangeNote = std::move(ChangeNote);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSubmitItemUpdate.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSubmitItemUpdateResult          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionSubmitItemUpdate::HandleCallback(const struct FSubmitItemUpdateResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionSubmitItemUpdate", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionSubmitItemUpdate_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionCreateItem.CreateItemAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ConsumerAppID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamWorkshopFileType                  FileType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionCreateItem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionCreateItem* USteamCoreProUGCAsyncActionCreateItem::CreateItemAsync(class UObject* WorldContextObject, int32 ConsumerAppID, ESteamWorkshopFileType FileType, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionCreateItem", "CreateItemAsync");

	Params::SteamCoreProUGCAsyncActionCreateItem_CreateItemAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ConsumerAppID = ConsumerAppID;
	Parms.FileType = FileType;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionCreateItem.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FCreateItemResult                Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionCreateItem::HandleCallback(const struct FCreateItemResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionCreateItem", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionCreateItem_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSendQueryUGCRequest.SendQueryUGCRequestAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FUGCQueryHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionSendQueryUGCRequest*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionSendQueryUGCRequest* USteamCoreProUGCAsyncActionSendQueryUGCRequest::SendQueryUGCRequestAsync(class UObject* WorldContextObject, const struct FUGCQueryHandle& Handle, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionSendQueryUGCRequest", "SendQueryUGCRequestAsync");

	Params::SteamCoreProUGCAsyncActionSendQueryUGCRequest_SendQueryUGCRequestAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Handle = std::move(Handle);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionSendQueryUGCRequest.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSteamUGCQueryCompleted          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionSendQueryUGCRequest::HandleCallback(const struct FSteamUGCQueryCompleted& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionSendQueryUGCRequest", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionSendQueryUGCRequest_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddAppDependency.AddAppDependencyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionAddAppDependency*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionAddAppDependency* USteamCoreProUGCAsyncActionAddAppDependency::AddAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionAddAppDependency", "AddAppDependencyAsync");

	Params::SteamCoreProUGCAsyncActionAddAppDependency_AddAppDependencyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddAppDependency.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAddAppDependencyResult          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionAddAppDependency::HandleCallback(const struct FAddAppDependencyResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionAddAppDependency", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionAddAppDependency_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveAppDependency.RemoveAppDependencyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionRemoveAppDependency*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionRemoveAppDependency* USteamCoreProUGCAsyncActionRemoveAppDependency::RemoveAppDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, int32 AppID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionRemoveAppDependency", "RemoveAppDependencyAsync");

	Params::SteamCoreProUGCAsyncActionRemoveAppDependency_RemoveAppDependencyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.AppID = AppID;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveAppDependency.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRemoveAppDependencyResult       Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionRemoveAppDependency::HandleCallback(const struct FRemoveAppDependencyResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionRemoveAppDependency", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionRemoveAppDependency_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddUGCDependency.AddDependencyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ChildPublishedFileId                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionAddUGCDependency*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionAddUGCDependency* USteamCoreProUGCAsyncActionAddUGCDependency::AddDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionAddUGCDependency", "AddDependencyAsync");

	Params::SteamCoreProUGCAsyncActionAddUGCDependency_AddDependencyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.ChildPublishedFileId = std::move(ChildPublishedFileId);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionAddUGCDependency.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAddUGCDependencyResult          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionAddUGCDependency::HandleCallback(const struct FAddUGCDependencyResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionAddUGCDependency", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionAddUGCDependency_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveUGCDependency.RemoveDependencyAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ChildPublishedFileId                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionRemoveUGCDependency*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionRemoveUGCDependency* USteamCoreProUGCAsyncActionRemoveUGCDependency::RemoveDependencyAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, const struct FPublishedFileID& ChildPublishedFileId, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionRemoveUGCDependency", "RemoveDependencyAsync");

	Params::SteamCoreProUGCAsyncActionRemoveUGCDependency_RemoveDependencyAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.ChildPublishedFileId = std::move(ChildPublishedFileId);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionRemoveUGCDependency.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRemoveUGCDependencyResult       Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionRemoveUGCDependency::HandleCallback(const struct FRemoveUGCDependencyResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionRemoveUGCDependency", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionRemoveUGCDependency_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionDeleteItem.DeleteItemAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionDeleteItem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionDeleteItem* USteamCoreProUGCAsyncActionDeleteItem::DeleteItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionDeleteItem", "DeleteItemAsync");

	Params::SteamCoreProUGCAsyncActionDeleteItem_DeleteItemAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionDeleteItem.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FUGCDeleteItemResult             Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionDeleteItem::HandleCallback(const struct FUGCDeleteItemResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionDeleteItem", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionDeleteItem_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionGetAppDependencies.GetAppDependenciesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionGetAppDependencies*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionGetAppDependencies* USteamCoreProUGCAsyncActionGetAppDependencies::GetAppDependenciesAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionGetAppDependencies", "GetAppDependenciesAsync");

	Params::SteamCoreProUGCAsyncActionGetAppDependencies_GetAppDependenciesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionGetAppDependencies.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGetAppDependenciesResult        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionGetAppDependencies::HandleCallback(const struct FGetAppDependenciesResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionGetAppDependencies", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionGetAppDependencies_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionDownloadItem.DownloadItemAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bHighPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUGCAsyncActionDownloadItem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUGCAsyncActionDownloadItem* USteamCoreProUGCAsyncActionDownloadItem::DownloadItemAsync(class UObject* WorldContextObject, const struct FPublishedFileID& PublishedFileID, bool bHighPriority, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUGCAsyncActionDownloadItem", "DownloadItemAsync");

	Params::SteamCoreProUGCAsyncActionDownloadItem_DownloadItemAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PublishedFileID = std::move(PublishedFileID);
	Parms.bHighPriority = bHighPriority;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUGCAsyncActionDownloadItem.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FDownloadItemResult              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUGCAsyncActionDownloadItem::HandleCallback(const struct FDownloadItemResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUGCAsyncActionDownloadItem", "HandleCallback");

	Params::SteamCoreProUGCAsyncActionDownloadItem_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.AdvertiseGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDGameServer                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ServerIP                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ServerPort                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUser::AdvertiseGame(const struct FSteamID& SteamIDGameServer, const class FString& ServerIP, int32 ServerPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "AdvertiseGame");

	Params::SteamProUser_AdvertiseGame Parms{};

	Parms.SteamIDGameServer = std::move(SteamIDGameServer);
	Parms.ServerIP = std::move(ServerIP);
	Parms.ServerPort = ServerPort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.BeginAuthSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Ticket                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamBeginAuthSessionResult            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamBeginAuthSessionResult USteamProUser::BeginAuthSession(const TArray<uint8>& Ticket, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BeginAuthSession");

	Params::SteamProUser_BeginAuthSession Parms{};

	Parms.Ticket = std::move(Ticket);
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BIsBehindNAT
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BIsBehindNAT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BIsBehindNAT");

	Params::SteamProUser_BIsBehindNAT Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BIsPhoneIdentifying
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BIsPhoneIdentifying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BIsPhoneIdentifying");

	Params::SteamProUser_BIsPhoneIdentifying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BIsPhoneRequiringVerification
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BIsPhoneRequiringVerification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BIsPhoneRequiringVerification");

	Params::SteamProUser_BIsPhoneRequiringVerification Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BIsPhoneVerified
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BIsPhoneVerified()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BIsPhoneVerified");

	Params::SteamProUser_BIsPhoneVerified Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BIsTwoFactorEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BIsTwoFactorEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BIsTwoFactorEnabled");

	Params::SteamProUser_BIsTwoFactorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.BLoggedOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::BLoggedOn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "BLoggedOn");

	Params::SteamProUser_BLoggedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.CancelAuthTicket
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamTicketHandle               TicketHandle                                           (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUser::CancelAuthTicket(const struct FSteamTicketHandle& TicketHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "CancelAuthTicket");

	Params::SteamProUser_CancelAuthTicket Parms{};

	Parms.TicketHandle = std::move(TicketHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.DecompressVoice
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           CompressedBuffer                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DesiredSampleRate                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           DestBuffer                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESteamVoiceResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamVoiceResult USteamProUser::DecompressVoice(const TArray<uint8>& CompressedBuffer, int32 DesiredSampleRate, TArray<uint8>* DestBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "DecompressVoice");

	Params::SteamProUser_DecompressVoice Parms{};

	Parms.CompressedBuffer = std::move(CompressedBuffer);
	Parms.DesiredSampleRate = DesiredSampleRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DestBuffer != nullptr)
		*DestBuffer = std::move(Parms.DestBuffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.EndAuthSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUser::EndAuthSession(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "EndAuthSession");

	Params::SteamProUser_EndAuthSession Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.GetAuthSessionTicket
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Ticket                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamTicketHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamTicketHandle USteamProUser::GetAuthSessionTicket(TArray<uint8>* Ticket, const struct FSteamNetworkingIdentity& SteamNetworkingIdentity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetAuthSessionTicket");

	Params::SteamProUser_GetAuthSessionTicket Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Ticket != nullptr)
		*Ticket = std::move(Parms.Ticket);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetAuthTicketForWebApi
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Identity                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamTicketHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamTicketHandle USteamProUser::GetAuthTicketForWebApi(const class FString& Identity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetAuthTicketForWebApi");

	Params::SteamProUser_GetAuthTicketForWebApi Parms{};

	Parms.Identity = std::move(Identity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetAvailableVoice
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   CompressedBytes                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UncompressedBytes                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UncompressedVoiceDesiredSampleRate                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamVoiceResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamVoiceResult USteamProUser::GetAvailableVoice(int32* CompressedBytes, int32* UncompressedBytes, int32 UncompressedVoiceDesiredSampleRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetAvailableVoice");

	Params::SteamProUser_GetAvailableVoice Parms{};

	Parms.UncompressedVoiceDesiredSampleRate = UncompressedVoiceDesiredSampleRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CompressedBytes != nullptr)
		*CompressedBytes = Parms.CompressedBytes;

	if (UncompressedBytes != nullptr)
		*UncompressedBytes = Parms.UncompressedBytes;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetEncryptedAppTicket
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Ticket                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUser::GetEncryptedAppTicket(TArray<uint8>* Ticket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetEncryptedAppTicket");

	Params::SteamProUser_GetEncryptedAppTicket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Ticket != nullptr)
		*Ticket = std::move(Parms.Ticket);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetGameBadgeLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Series                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFoil                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUser::GetGameBadgeLevel(int32 Series, bool bFoil)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetGameBadgeLevel");

	Params::SteamProUser_GetGameBadgeLevel Parms{};

	Parms.Series = Series;
	Parms.bFoil = bFoil;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetPlayerSteamLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUser::GetPlayerSteamLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetPlayerSteamLevel");

	Params::SteamProUser_GetPlayerSteamLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetSteamID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProUser::GetSteamID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetSteamID");

	Params::SteamProUser_GetSteamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetSteamID_Pure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamProUser::GetSteamID_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetSteamID_Pure");

	Params::SteamProUser_GetSteamID_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetSteamUser
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProUser*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProUser* USteamProUser::GetSteamUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetSteamUser");

	Params::SteamProUser_GetSteamUser Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetVoice
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           DestBuffer                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   BytesWritten                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamVoiceResult                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamVoiceResult USteamProUser::GetVoice(TArray<uint8>* DestBuffer, int32* BytesWritten)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetVoice");

	Params::SteamProUser_GetVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DestBuffer != nullptr)
		*DestBuffer = std::move(Parms.DestBuffer);

	if (BytesWritten != nullptr)
		*BytesWritten = Parms.BytesWritten;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.GetVoiceOptimalSampleRate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUser::GetVoiceOptimalSampleRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "GetVoiceOptimalSampleRate");

	Params::SteamProUser_GetVoiceOptimalSampleRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.StartVoiceRecording
// (Final, Native, Static, Public, BlueprintCallable)

void USteamProUser::StartVoiceRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "StartVoiceRecording");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.StopVoiceRecording
// (Final, Native, Static, Public, BlueprintCallable)

void USteamProUser::StopVoiceRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "StopVoiceRecording");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.UserHasLicenseForApp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   AppID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamUserHasLicenseForAppResult        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamUserHasLicenseForAppResult USteamProUser::UserHasLicenseForApp(const struct FSteamID& SteamID, int32 AppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUser", "UserHasLicenseForApp");

	Params::SteamProUser_UserHasLicenseForApp Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.AppID = AppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUser.RequestEncryptedAppTicket
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           DataToInclude                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProUser::RequestEncryptedAppTicket(const TDelegate<void(struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful)>& Callback, const TArray<uint8>& DataToInclude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUser", "RequestEncryptedAppTicket");

	Params::SteamProUser_RequestEncryptedAppTicket Parms{};

	Parms.Callback = Callback;
	Parms.DataToInclude = std::move(DataToInclude);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUser.RequestStoreAuthURL
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FStoreAuthURLResponse& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RedirectURL                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUser::RequestStoreAuthURL(const TDelegate<void(struct FStoreAuthURLResponse& Data, bool bWasSuccessful)>& Callback, const class FString& RedirectURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUser", "RequestStoreAuthURL");

	Params::SteamProUser_RequestStoreAuthURL Parms{};

	Parms.Callback = Callback;
	Parms.RedirectURL = std::move(RedirectURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserAsyncActionRequestEncryptedAppTicket.RequestEncryptedAppTicketAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           DataToInclude                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserAsyncActionRequestEncryptedAppTicket*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserAsyncActionRequestEncryptedAppTicket* USteamCoreProUserAsyncActionRequestEncryptedAppTicket::RequestEncryptedAppTicketAsync(class UObject* WorldContextObject, const TArray<uint8>& DataToInclude, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserAsyncActionRequestEncryptedAppTicket", "RequestEncryptedAppTicketAsync");

	Params::SteamCoreProUserAsyncActionRequestEncryptedAppTicket_RequestEncryptedAppTicketAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DataToInclude = std::move(DataToInclude);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserAsyncActionRequestEncryptedAppTicket.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEncryptedAppTicketResponse      Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserAsyncActionRequestEncryptedAppTicket::HandleCallback(const struct FEncryptedAppTicketResponse& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserAsyncActionRequestEncryptedAppTicket", "HandleCallback");

	Params::SteamCoreProUserAsyncActionRequestEncryptedAppTicket_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserAsyncActionRequestStoreAuthURL.RequestStoreAuthURLAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           RedirectURL                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserAsyncActionRequestStoreAuthURL*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserAsyncActionRequestStoreAuthURL* USteamCoreProUserAsyncActionRequestStoreAuthURL::RequestStoreAuthURLAsync(class UObject* WorldContextObject, const class FString& RedirectURL, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserAsyncActionRequestStoreAuthURL", "RequestStoreAuthURLAsync");

	Params::SteamCoreProUserAsyncActionRequestStoreAuthURL_RequestStoreAuthURLAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.RedirectURL = std::move(RedirectURL);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserAsyncActionRequestStoreAuthURL.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FStoreAuthURLResponse            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserAsyncActionRequestStoreAuthURL::HandleCallback(const struct FStoreAuthURLResponse& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserAsyncActionRequestStoreAuthURL", "HandleCallback");

	Params::SteamCoreProUserAsyncActionRequestStoreAuthURL_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.ClearAchievement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::ClearAchievement(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "ClearAchievement");

	Params::SteamProUserStats_ClearAchievement Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievement
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetAchievement(const class FString& Param_Name, bool* bAchieved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievement");

	Params::SteamProUserStats_GetAchievement Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementAchievedPercent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetAchievementAchievedPercent(const class FString& Param_Name, float* Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementAchievedPercent");

	Params::SteamProUserStats_GetAchievementAchievedPercent Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Percent != nullptr)
		*Percent = Parms.Percent;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementAndUnlockTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UnlockTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetAchievementAndUnlockTime(const class FString& Param_Name, bool* bAchieved, int32* UnlockTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementAndUnlockTime");

	Params::SteamProUserStats_GetAchievementAndUnlockTime Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	if (UnlockTime != nullptr)
		*UnlockTime = Parms.UnlockTime;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementDisplayAttribute
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProUserStats::GetAchievementDisplayAttribute(const class FString& Param_Name, const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementDisplayAttribute");

	Params::SteamProUserStats_GetAchievementDisplayAttribute Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* USteamProUserStats::GetAchievementIcon(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementIcon");

	Params::SteamProUserStats_GetAchievementIcon Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Achievement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProUserStats::GetAchievementName(int32 Achievement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementName");

	Params::SteamProUserStats_GetAchievementName Parms{};

	Parms.Achievement = Achievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementProgressLimits
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetAchievementProgressLimits(const class FString& Param_Name, int32* MinProgress, int32* MaxProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementProgressLimits");

	Params::SteamProUserStats_GetAchievementProgressLimits Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MinProgress != nullptr)
		*MinProgress = Parms.MinProgress;

	if (MaxProgress != nullptr)
		*MaxProgress = Parms.MaxProgress;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetAchievementProgressLimitsFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetAchievementProgressLimitsFloat(const class FString& Param_Name, float* MinProgress, float* MaxProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetAchievementProgressLimitsFloat");

	Params::SteamProUserStats_GetAchievementProgressLimitsFloat Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MinProgress != nullptr)
		*MinProgress = Parms.MinProgress;

	if (MaxProgress != nullptr)
		*MaxProgress = Parms.MaxProgress;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetDownloadedLeaderboardEntry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamLeaderboardEntries         LeaderboardEntries                                     (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   Param_Index                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboardEntry           LeaderboardEntry                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<int32>                           Details                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           OutDetails                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetDownloadedLeaderboardEntry(const struct FSteamLeaderboardEntries& LeaderboardEntries, int32 Param_Index, struct FSteamLeaderboardEntry* LeaderboardEntry, const TArray<int32>& Details, TArray<int32>* OutDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetDownloadedLeaderboardEntry");

	Params::SteamProUserStats_GetDownloadedLeaderboardEntry Parms{};

	Parms.LeaderboardEntries = std::move(LeaderboardEntries);
	Parms.Param_Index = Param_Index;
	Parms.Details = std::move(Details);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (LeaderboardEntry != nullptr)
		*LeaderboardEntry = std::move(Parms.LeaderboardEntry);

	if (OutDetails != nullptr)
		*OutDetails = std::move(Parms.OutDetails);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetGlobalStatFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetGlobalStatFloat(const class FString& StatName, float* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetGlobalStatFloat");

	Params::SteamProUserStats_GetGlobalStatFloat Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetGlobalStatHistoryFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryDays                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           Data                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetGlobalStatHistoryFloat(const class FString& StatName, int32 HistoryDays, TArray<float>* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetGlobalStatHistoryFloat");

	Params::SteamProUserStats_GetGlobalStatHistoryFloat Parms{};

	Parms.StatName = std::move(StatName);
	Parms.HistoryDays = HistoryDays;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetGlobalStatHistoryInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryDays                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           Data                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetGlobalStatHistoryInt(const class FString& StatName, int32 HistoryDays, TArray<int32>* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetGlobalStatHistoryInt");

	Params::SteamProUserStats_GetGlobalStatHistoryInt Parms{};

	Parms.StatName = std::move(StatName);
	Parms.HistoryDays = HistoryDays;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetGlobalStatInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           StatName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetGlobalStatInt(const class FString& StatName, int32* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetGlobalStatInt");

	Params::SteamProUserStats_GetGlobalStatInt Parms{};

	Parms.StatName = std::move(StatName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetLeaderboardDisplayType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardDisplayType            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamLeaderboardDisplayType USteamProUserStats::GetLeaderboardDisplayType(const struct FSteamLeaderboard& SteamLeaderboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetLeaderboardDisplayType");

	Params::SteamProUserStats_GetLeaderboardDisplayType Parms{};

	Parms.SteamLeaderboard = std::move(SteamLeaderboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetLeaderboardEntryCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetLeaderboardEntryCount(const struct FSteamLeaderboard& SteamLeaderboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetLeaderboardEntryCount");

	Params::SteamProUserStats_GetLeaderboardEntryCount Parms{};

	Parms.SteamLeaderboard = std::move(SteamLeaderboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetLeaderboardName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProUserStats::GetLeaderboardName(const struct FSteamLeaderboard& SteamLeaderboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetLeaderboardName");

	Params::SteamProUserStats_GetLeaderboardName Parms{};

	Parms.SteamLeaderboard = std::move(SteamLeaderboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetLeaderboardSortMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardSortMethod             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamLeaderboardSortMethod USteamProUserStats::GetLeaderboardSortMethod(const struct FSteamLeaderboard& SteamLeaderboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetLeaderboardSortMethod");

	Params::SteamProUserStats_GetLeaderboardSortMethod Parms{};

	Parms.SteamLeaderboard = std::move(SteamLeaderboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetMostAchievedAchievementInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetMostAchievedAchievementInfo(class FString* Param_Name, float* Percent, bool* bAchieved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetMostAchievedAchievementInfo");

	Params::SteamProUserStats_GetMostAchievedAchievementInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	if (Percent != nullptr)
		*Percent = Parms.Percent;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetNextMostAchievedAchievementInfo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   IteratorPrevious                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percent                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetNextMostAchievedAchievementInfo(int32 IteratorPrevious, class FString* Param_Name, float* Percent, bool* bAchieved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetNextMostAchievedAchievementInfo");

	Params::SteamProUserStats_GetNextMostAchievedAchievementInfo Parms{};

	Parms.IteratorPrevious = IteratorPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Param_Name != nullptr)
		*Param_Name = std::move(Parms.Param_Name);

	if (Percent != nullptr)
		*Percent = Parms.Percent;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetNumAchievements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUserStats::GetNumAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetNumAchievements");

	Params::SteamProUserStats_GetNumAchievements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetStatFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetStatFloat(const class FString& Param_Name, float* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetStatFloat");

	Params::SteamProUserStats_GetStatFloat Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetStatInt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetStatInt(const class FString& Param_Name, int32* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetStatInt");

	Params::SteamProUserStats_GetStatInt Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetSteamUserStats
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProUserStats*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProUserStats* USteamProUserStats::GetSteamUserStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetSteamUserStats");

	Params::SteamProUserStats_GetSteamUserStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetUserAchievement
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetUserAchievement(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetUserAchievement");

	Params::SteamProUserStats_GetUserAchievement Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetUserAchievementAndUnlockTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAchieved                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UnlockTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetUserAchievementAndUnlockTime(const struct FSteamID& SteamIDUser, const class FString& Param_Name, bool* bAchieved, int32* UnlockTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetUserAchievementAndUnlockTime");

	Params::SteamProUserStats_GetUserAchievementAndUnlockTime Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bAchieved != nullptr)
		*bAchieved = Parms.bAchieved;

	if (UnlockTime != nullptr)
		*UnlockTime = Parms.UnlockTime;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetUserStatFloat
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetUserStatFloat(const struct FSteamID& SteamIDUser, const class FString& Param_Name, float* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetUserStatFloat");

	Params::SteamProUserStats_GetUserStatFloat Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.GetUserStatInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamIDUser                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::GetUserStatInteger(const struct FSteamID& SteamIDUser, const class FString& Param_Name, int32* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "GetUserStatInteger");

	Params::SteamProUserStats_GetUserStatInteger Parms{};

	Parms.SteamIDUser = std::move(SteamIDUser);
	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = Parms.Data;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.IndicateAchievementProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentProgress                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxProgress                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::IndicateAchievementProgress(const class FString& Param_Name, int32 CurrentProgress, int32 MaxProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "IndicateAchievementProgress");

	Params::SteamProUserStats_IndicateAchievementProgress Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.CurrentProgress = CurrentProgress;
	Parms.MaxProgress = MaxProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.RequestCurrentStats
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::RequestCurrentStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "RequestCurrentStats");

	Params::SteamProUserStats_RequestCurrentStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.ResetAllStats
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bAchievementsToo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::ResetAllStats(bool bAchievementsToo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "ResetAllStats");

	Params::SteamProUserStats_ResetAllStats Parms{};

	Parms.bAchievementsToo = bAchievementsToo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.SetAchievement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::SetAchievement(const class FString& Param_Name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "SetAchievement");

	Params::SteamProUserStats_SetAchievement Parms{};

	Parms.Param_Name = std::move(Param_Name);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.SetStatFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::SetStatFloat(const class FString& Param_Name, float Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "SetStatFloat");

	Params::SteamProUserStats_SetStatFloat Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.SetStatInt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Data                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::SetStatInt(const class FString& Param_Name, int32 Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "SetStatInt");

	Params::SteamProUserStats_SetStatInt Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.StoreStats
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::StoreStats()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "StoreStats");

	Params::SteamProUserStats_StoreStats Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.UpdateAvgRateStat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Param_Name                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CountThisSession                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SessionLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUserStats::UpdateAvgRateStat(const class FString& Param_Name, float CountThisSession, float SessionLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUserStats", "UpdateAvgRateStat");

	Params::SteamProUserStats_UpdateAvgRateStat Parms{};

	Parms.Param_Name = std::move(Param_Name);
	Parms.CountThisSession = CountThisSession;
	Parms.SessionLength = SessionLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUserStats.AttachLeaderboardUGC
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUserStats::AttachLeaderboardUGC(const TDelegate<void(struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "AttachLeaderboardUGC");

	Params::SteamProUserStats_AttachLeaderboardUGC Parms{};

	Parms.Callback = Callback;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.DownloadLeaderboardEntries
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardDataRequest            DataRequest                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RangeStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RangeEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::DownloadLeaderboardEntries(const TDelegate<void(struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest DataRequest, int32 RangeStart, int32 RangeEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "DownloadLeaderboardEntries");

	Params::SteamProUserStats_DownloadLeaderboardEntries Parms{};

	Parms.Callback = Callback;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.DataRequest = DataRequest;
	Parms.RangeStart = RangeStart;
	Parms.RangeEnd = RangeEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.DownloadLeaderboardEntriesForUsers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamID>                 Users                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProUserStats::DownloadLeaderboardEntriesForUsers(const TDelegate<void(struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "DownloadLeaderboardEntriesForUsers");

	Params::SteamProUserStats_DownloadLeaderboardEntriesForUsers Parms{};

	Parms.Callback = Callback;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.Users = std::move(Users);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.FindLeaderboard
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FLeaderboardFindResult& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LeaderboardName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::FindLeaderboard(const TDelegate<void(struct FLeaderboardFindResult& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "FindLeaderboard");

	Params::SteamProUserStats_FindLeaderboard Parms{};

	Parms.Callback = Callback;
	Parms.LeaderboardName = std::move(LeaderboardName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.FindOrCreateLeaderboard
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LeaderboardName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLeaderboardSortMethod             SortMethod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLeaderboardDisplayType            DisplayType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::FindOrCreateLeaderboard(const TDelegate<void(struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful)>& Callback, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "FindOrCreateLeaderboard");

	Params::SteamProUserStats_FindOrCreateLeaderboard Parms{};

	Parms.Callback = Callback;
	Parms.LeaderboardName = std::move(LeaderboardName);
	Parms.SortMethod = SortMethod;
	Parms.DisplayType = DisplayType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.GetNumberOfCurrentPlayers
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::GetNumberOfCurrentPlayers(const TDelegate<void(struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "GetNumberOfCurrentPlayers");

	Params::SteamProUserStats_GetNumberOfCurrentPlayers Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.RequestGlobalAchievementPercentages
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::RequestGlobalAchievementPercentages(const TDelegate<void(struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "RequestGlobalAchievementPercentages");

	Params::SteamProUserStats_RequestGlobalAchievementPercentages Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.RequestGlobalStats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FGlobalStatsReceived& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryDays                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUserStats::RequestGlobalStats(const TDelegate<void(struct FGlobalStatsReceived& Data, bool bWasSuccessful)>& Callback, int32 HistoryDays)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "RequestGlobalStats");

	Params::SteamProUserStats_RequestGlobalStats Parms{};

	Parms.Callback = Callback;
	Parms.HistoryDays = HistoryDays;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.RequestUserStats
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FRequestUserStatsData& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamProUserStats::RequestUserStats(const TDelegate<void(struct FRequestUserStatsData& Data, bool bWasSuccessful)>& Callback, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "RequestUserStats");

	Params::SteamProUserStats_RequestUserStats Parms{};

	Parms.Callback = Callback;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUserStats.UploadLeaderboardScore
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardUploadScoreMethod      UploadScoreMethod                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ScoreDetails                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void USteamProUserStats::UploadLeaderboardScore(const TDelegate<void(struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful)>& Callback, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUserStats", "UploadLeaderboardScore");

	Params::SteamProUserStats_UploadLeaderboardScore Parms{};

	Parms.Callback = Callback;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.UploadScoreMethod = UploadScoreMethod;
	Parms.Score = Score;
	Parms.ScoreDetails = std::move(ScoreDetails);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionFindLeaderboard.FindLeaderboardAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LeaderboardName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionFindLeaderboard*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionFindLeaderboard* USteamCoreProUserStatsAsyncActionFindLeaderboard::FindLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionFindLeaderboard", "FindLeaderboardAsync");

	Params::SteamCoreProUserStatsAsyncActionFindLeaderboard_FindLeaderboardAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LeaderboardName = std::move(LeaderboardName);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionFindLeaderboard.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLeaderboardFindResult           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionFindLeaderboard::HandleCallback(const struct FLeaderboardFindResult& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionFindLeaderboard", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionFindLeaderboard_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries.DownloadLeaderboardEntriesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardDataRequest            Request                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RangeStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RangeEnd                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries* USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries::DownloadLeaderboardEntriesAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardDataRequest Request, int32 RangeStart, int32 RangeEnd, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries", "DownloadLeaderboardEntriesAsync");

	Params::SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries_DownloadLeaderboardEntriesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.Request = Request;
	Parms.RangeStart = RangeStart;
	Parms.RangeEnd = RangeEnd;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLeaderboardScoresDownloaded     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries::HandleCallback(const struct FLeaderboardScoresDownloaded& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntries_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats.RequestGlobalStatsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HistoryDays                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats* USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats::RequestGlobalStatsAsync(class UObject* WorldContextObject, int32 HistoryDays, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats", "RequestGlobalStatsAsync");

	Params::SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats_RequestGlobalStatsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.HistoryDays = HistoryDays;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGlobalStatsReceived             Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats::HandleCallback(const struct FGlobalStatsReceived& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionDownloadRequestGlobalStats_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages.RequestGlobalAchievementPercentagesAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages* USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages::RequestGlobalAchievementPercentagesAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages", "RequestGlobalAchievementPercentagesAsync");

	Params::SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages_RequestGlobalAchievementPercentagesAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGlobalAchievementPercentagesReadyData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages::HandleCallback(const struct FGlobalAchievementPercentagesReady& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionRequestGlobalAchievementPercentages_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers.GetNumberOfCurrentPlayersAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers* USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers::GetNumberOfCurrentPlayersAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers", "GetNumberOfCurrentPlayersAsync");

	Params::SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers_GetNumberOfCurrentPlayersAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FNumberOfCurrentPlayers          Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers::HandleCallback(const struct FNumberOfCurrentPlayers& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionGetNumberOfCurrentPlayers_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionUploadLeaderboardScore.UploadLeaderboardScoreAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamLeaderboardUploadScoreMethod      UploadScoreMethod                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ScoreDetails                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionUploadLeaderboardScore*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionUploadLeaderboardScore* USteamCoreProUserStatsAsyncActionUploadLeaderboardScore::UploadLeaderboardScoreAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, ESteamLeaderboardUploadScoreMethod UploadScoreMethod, int32 Score, const TArray<int32>& ScoreDetails, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionUploadLeaderboardScore", "UploadLeaderboardScoreAsync");

	Params::SteamCoreProUserStatsAsyncActionUploadLeaderboardScore_UploadLeaderboardScoreAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.UploadScoreMethod = UploadScoreMethod;
	Parms.Score = Score;
	Parms.ScoreDetails = std::move(ScoreDetails);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionUploadLeaderboardScore.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLeaderboardScoreUploaded        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionUploadLeaderboardScore::HandleCallback(const struct FLeaderboardScoreUploaded& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionUploadLeaderboardScore", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionUploadLeaderboardScore_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard.FindOrCreateLeaderboardAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           LeaderboardName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLeaderboardSortMethod             SortMethod                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamLeaderboardDisplayType            DisplayType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard* USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard::FindOrCreateLeaderboardAsync(class UObject* WorldContextObject, const class FString& LeaderboardName, ESteamLeaderboardSortMethod SortMethod, ESteamLeaderboardDisplayType DisplayType, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard", "FindOrCreateLeaderboardAsync");

	Params::SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard_FindOrCreateLeaderboardAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LeaderboardName = std::move(LeaderboardName);
	Parms.SortMethod = SortMethod;
	Parms.DisplayType = DisplayType;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FFindOrCreateLeaderboardData     Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard::HandleCallback(const struct FFindOrCreateLeaderboardData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionFindOrCreateLeaderboard_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestUserStats.RequestUserStatsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionRequestUserStats*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionRequestUserStats* USteamCoreProUserStatsAsyncActionRequestUserStats::RequestUserStatsAsync(class UObject* WorldContextObject, const struct FSteamID& SteamID, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionRequestUserStats", "RequestUserStatsAsync");

	Params::SteamCoreProUserStatsAsyncActionRequestUserStats_RequestUserStatsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamID = std::move(SteamID);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestUserStats.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRequestUserStatsData            Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionRequestUserStats::HandleCallback(const struct FRequestUserStatsData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionRequestUserStats", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionRequestUserStats_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestCurrentStats.RequestCurrentStatsAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionRequestCurrentStats*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionRequestCurrentStats* USteamCoreProUserStatsAsyncActionRequestCurrentStats::RequestCurrentStatsAsync(class UObject* WorldContextObject, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionRequestCurrentStats", "RequestCurrentStatsAsync");

	Params::SteamCoreProUserStatsAsyncActionRequestCurrentStats_RequestCurrentStatsAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionRequestCurrentStats.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FRequestCurrentStatsData         Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionRequestCurrentStats::HandleCallback(const struct FRequestCurrentStatsData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionRequestCurrentStats", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionRequestCurrentStats_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers.DownloadLeaderboardEntriesForUsersAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FSteamID>                 Users                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers* USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers::DownloadLeaderboardEntriesForUsersAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const TArray<struct FSteamID>& Users, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers", "DownloadLeaderboardEntriesForUsersAsync");

	Params::SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers_DownloadLeaderboardEntriesForUsersAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.Users = std::move(Users);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FLeaderboardScoresDownloadedForUsersData                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers::HandleCallback(const struct FLeaderboardScoresDownloadedForUsers& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionDownloadLeaderboardEntriesForUsers_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC.AttachLeaderboardUGCAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamLeaderboard                SteamLeaderboard                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC* USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC::AttachLeaderboardUGCAsync(class UObject* WorldContextObject, const struct FSteamLeaderboard& SteamLeaderboard, const struct FSteamUGCHandle& Handle, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC", "AttachLeaderboardUGCAsync");

	Params::SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC_AttachLeaderboardUGCAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamLeaderboard = std::move(SteamLeaderboard);
	Parms.Handle = std::move(Handle);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC.HandleCallback
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FAttachLeaderboardUGCData        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProUserStatsAsyncActionAttachLeaderboardUGC::HandleCallback(const struct FAttachLeaderboardUGCData& Data, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC", "HandleCallback");

	Params::SteamCoreProUserStatsAsyncActionAttachLeaderboardUGC_HandleCallback Parms{};

	Parms.Data = std::move(Data);
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProVoice.ConstructSteamCoreProVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AudioSampleRate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProVoice*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProVoice* USteamCoreProVoice::ConstructSteamCoreProVoice(int32 AudioSampleRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProVoice", "ConstructSteamCoreProVoice");

	Params::SteamCoreProVoice_ConstructSteamCoreProVoice Parms{};

	Parms.AudioSampleRate = AudioSampleRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProVoice.DestroySteamCoreProVoice
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USteamCoreProVoice*               Obj                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProVoice::DestroySteamCoreProVoice(class USteamCoreProVoice* Obj)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProVoice", "DestroySteamCoreProVoice");

	Params::SteamCoreProVoice_DestroySteamCoreProVoice Parms{};

	Parms.Obj = Obj;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProVoice.AddAudioBuffer
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<uint8>                           Buffer                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USteamCoreProVoice::AddAudioBuffer(const TArray<uint8>& Buffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProVoice", "AddAudioBuffer");

	Params::SteamCoreProVoice_AddAudioBuffer Parms{};

	Parms.Buffer = std::move(Buffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamCoreProAsyncActionListenForControllerChange.ListenForControllerChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USteamCoreProAsyncActionListenForControllerChange*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamCoreProAsyncActionListenForControllerChange* USteamCoreProAsyncActionListenForControllerChange::ListenForControllerChange(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamCoreProAsyncActionListenForControllerChange", "ListenForControllerChange");

	Params::SteamCoreProAsyncActionListenForControllerChange_ListenForControllerChange Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamCoreProAsyncActionListenForControllerChange.HandleCallback
// (Final, Native, Public)
// Parameters:
// bool                                    bIsConnected                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlatformUserId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamCoreProAsyncActionListenForControllerChange::HandleCallback(bool bIsConnected, int32 PlatformUserId, int32 UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamCoreProAsyncActionListenForControllerChange", "HandleCallback");

	Params::SteamCoreProAsyncActionListenForControllerChange_HandleCallback Parms{};

	Parms.bIsConnected = bIsConnected;
	Parms.PlatformUserId = PlatformUserId;
	Parms.UserId = UserId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.BP_BytesToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BP_BytesToString(const TArray<uint8>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BP_BytesToString");

	Params::SteamUtilities_BP_BytesToString Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BP_StringToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> USteamUtilities::BP_StringToBytes(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BP_StringToBytes");

	Params::SteamUtilities_BP_StringToBytes Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakInventoryUpdateHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakInventoryUpdateHandle(const struct FSteamInventoryUpdateHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakInventoryUpdateHandle");

	Params::SteamUtilities_BreakInventoryUpdateHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakPublishedFileID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPublishedFileID                 FileID                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakPublishedFileID(const struct FPublishedFileID& FileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakPublishedFileID");

	Params::SteamUtilities_BreakPublishedFileID Parms{};

	Parms.FileID = std::move(FileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakSteamGameID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamGameID                     SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakSteamGameID(const struct FSteamGameID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakSteamGameID");

	Params::SteamUtilities_BreakSteamGameID Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakSteamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakSteamID(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakSteamID");

	Params::SteamUtilities_BreakSteamID Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakTicketHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamTicketHandle               Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakTicketHandle(const struct FSteamTicketHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakTicketHandle");

	Params::SteamUtilities_BreakTicketHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.BreakUGCHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamUGCHandle                  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::BreakUGCHandle(const struct FSteamUGCHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "BreakUGCHandle");

	Params::SteamUtilities_BreakUGCHandle Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.ConstructServerFilter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UServerFilter*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UServerFilter* USteamUtilities::ConstructServerFilter(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "ConstructServerFilter");

	Params::SteamUtilities_ConstructServerFilter Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.EncryptString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::EncryptString(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "EncryptString");

	Params::SteamUtilities_EncryptString Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.Equal
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::Equal(const struct FSteamID& A, const struct FSteamID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "Equal");

	Params::SteamUtilities_Equal Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.Equal_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         B                                                      (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProIdentical                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::Equal_Exec(const struct FSteamID& A, const struct FSteamID& B, ESteamCoreProIdentical* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "Equal_Exec");

	Params::SteamUtilities_Equal_Exec Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.FromUnixTimestamp
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Timestamp                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime USteamUtilities::FromUnixTimestamp(const class FString& Timestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "FromUnixTimestamp");

	Params::SteamUtilities_FromUnixTimestamp Parms{};

	Parms.Timestamp = std::move(Timestamp);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetAccountType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamAccountType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamAccountType USteamUtilities::GetAccountType(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetAccountType");

	Params::SteamUtilities_GetAccountType Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetFriendsList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EFriendListType                         FriendListType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FOnlineFriendSteamCoreBlueprint>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FOnlineFriendSteamCoreBlueprint> USteamUtilities::GetFriendsList(EFriendListType FriendListType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetFriendsList");

	Params::SteamUtilities_GetFriendsList Parms{};

	Parms.FriendListType = FriendListType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetGameEngineInitialized
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::GetGameEngineInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetGameEngineInitialized");

	Params::SteamUtilities_GetGameEngineInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetHostPingData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::GetHostPingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetHostPingData");

	Params::SteamUtilities_GetHostPingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetInteger
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamSessionSetting             Settings                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutValue                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::GetInteger(const struct FSteamSessionSetting& Settings, class FString* Key, int32* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetInteger");

	Params::SteamUtilities_GetInteger Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (OutValue != nullptr)
		*OutValue = Parms.OutValue;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetPingFromHostData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamUtilities::GetPingFromHostData(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetPingFromHostData");

	Params::SteamUtilities_GetPingFromHostData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetPublicIp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(const class FString& Response)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::GetPublicIp(const TDelegate<void(const class FString& Response)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetPublicIp");

	Params::SteamUtilities_GetPublicIp Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.GetSteamIdFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamUtilities::GetSteamIdFromPlayerState(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetSteamIdFromPlayerState");

	Params::SteamUtilities_GetSteamIdFromPlayerState Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetString
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamSessionSetting             Settings                                               (Parm, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutValue                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::GetString(const struct FSteamSessionSetting& Settings, class FString* Key, class FString* OutValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetString");

	Params::SteamUtilities_GetString Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Key != nullptr)
		*Key = std::move(Parms.Key);

	if (OutValue != nullptr)
		*OutValue = std::move(Parms.OutValue);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.GetType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamSessionSetting             Settings                                               (Parm, NativeAccessSpecifierPublic)
// ESteamAttributeType                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamAttributeType USteamUtilities::GetType(const struct FSteamSessionSetting& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "GetType");

	Params::SteamUtilities_GetType Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsGameIDValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamGameID                     GameID                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsGameIDValid(const struct FSteamGameID& GameID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsGameIDValid");

	Params::SteamUtilities_IsGameIDValid Parms{};

	Parms.GameID = std::move(GameID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsGameIDValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamGameID                     GameID                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsGameIDValid_Exec(const struct FSteamGameID& GameID, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsGameIDValid_Exec");

	Params::SteamUtilities_IsGameIDValid_Exec Parms{};

	Parms.GameID = std::move(GameID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsLobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsLobby(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsLobby");

	Params::SteamUtilities_IsLobby Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsLocalPlayerTalking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LocalUserNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsLocalPlayerTalking(class UObject* WorldContextObject, int32 LocalUserNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsLocalPlayerTalking");

	Params::SteamUtilities_IsLocalPlayerTalking Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LocalUserNum = LocalUserNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsPlayerMuted
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsPlayerMuted(class UObject* WorldContextObject, class APlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsPlayerMuted");

	Params::SteamUtilities_IsPlayerMuted Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsPublishedFileIDValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPublishedFileID                 PublishedFileID                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsPublishedFileIDValid(const struct FPublishedFileID& PublishedFileID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsPublishedFileIDValid");

	Params::SteamUtilities_IsPublishedFileIDValid Parms{};

	Parms.PublishedFileID = std::move(PublishedFileID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsPublishedFileIDValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsPublishedFileIDValid_Exec(const struct FPublishedFileID& Handle, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsPublishedFileIDValid_Exec");

	Params::SteamUtilities_IsPublishedFileIDValid_Exec Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsRecalculatingPing
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsRecalculatingPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsRecalculatingPing");

	Params::SteamUtilities_IsRecalculatingPing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsRemotePlayerTalking
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsRemotePlayerTalking(class UObject* WorldContextObject, class APlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsRemotePlayerTalking");

	Params::SteamUtilities_IsRemotePlayerTalking Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsSteamAvailable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsSteamAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamAvailable");

	Params::SteamUtilities_IsSteamAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsSteamIDValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamID                         SteamID                                                (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsSteamIDValid_Exec(const struct FSteamID& SteamID, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamIDValid_Exec");

	Params::SteamUtilities_IsSteamIDValid_Exec Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsSteamInventoryUpdateHandleValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsSteamInventoryUpdateHandleValid(const struct FSteamInventoryUpdateHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamInventoryUpdateHandleValid");

	Params::SteamUtilities_IsSteamInventoryUpdateHandleValid Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsSteamInventoryUpdateHandleValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamInventoryUpdateHandle      Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsSteamInventoryUpdateHandleValid_Exec(const struct FSteamInventoryUpdateHandle& Handle, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamInventoryUpdateHandleValid_Exec");

	Params::SteamUtilities_IsSteamInventoryUpdateHandleValid_Exec Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsSteamServerInitialized
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsSteamServerInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamServerInitialized");

	Params::SteamUtilities_IsSteamServerInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsSteamTicketHandleValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamTicketHandle               Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsSteamTicketHandleValid(const struct FSteamTicketHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamTicketHandleValid");

	Params::SteamUtilities_IsSteamTicketHandleValid Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsSteamTicketHandleValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamTicketHandle               Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsSteamTicketHandleValid_Exec(const struct FSteamTicketHandle& Handle, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsSteamTicketHandleValid_Exec");

	Params::SteamUtilities_IsSteamTicketHandleValid_Exec Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsUGCHandleValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamUGCHandle                  Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsUGCHandleValid(const struct FSteamUGCHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsUGCHandleValid");

	Params::SteamUtilities_IsUGCHandleValid Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsUGCHandleValid_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamUGCHandle                  Handle                                                 (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProValid                      Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::IsUGCHandleValid_Exec(const struct FSteamUGCHandle& Handle, ESteamCoreProValid* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsUGCHandleValid_Exec");

	Params::SteamUtilities_IsUGCHandleValid_Exec Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.IsUsingP2PRelays
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsUsingP2PRelays()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsUsingP2PRelays");

	Params::SteamUtilities_IsUsingP2PRelays Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.IsValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::IsValid(const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "IsValid");

	Params::SteamUtilities_IsValid Parms{};

	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.K2_HexToBytes
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> USteamUtilities::K2_HexToBytes(const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "K2_HexToBytes");

	Params::SteamUtilities_K2_HexToBytes Parms{};

	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.K2_HexToString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           Array                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamUtilities::K2_HexToString(const TArray<uint8>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "K2_HexToString");

	Params::SteamUtilities_K2_HexToString Parms{};

	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.K2_IsPlayerInSession
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   LocalUserNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::K2_IsPlayerInSession(int32 LocalUserNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "K2_IsPlayerInSession");

	Params::SteamUtilities_K2_IsPlayerInSession Parms{};

	Parms.LocalUserNum = LocalUserNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.KickPlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                KickedPlayer                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             KickReason                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::KickPlayer(class UObject* WorldContextObject, class APlayerController* KickedPlayer, const class FText& KickReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "KickPlayer");

	Params::SteamUtilities_KickPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.KickedPlayer = KickedPlayer;
	Parms.KickReason = std::move(KickReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.ListenForSessionInviteAccepted
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(bool bWasSuccessful, int32 LocalPlayerNum, const class FString& InvitedBy, struct FBlueprintSessionResult& Session)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::ListenForSessionInviteAccepted(const TDelegate<void(bool bWasSuccessful, int32 LocalPlayerNum, const class FString& InvitedBy, struct FBlueprintSessionResult& Session)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "ListenForSessionInviteAccepted");

	Params::SteamUtilities_ListenForSessionInviteAccepted Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.ListenForSteamMessages
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(ESteamMessageType Type, const class FString& Message)>Callback                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::ListenForSteamMessages(const TDelegate<void(ESteamMessageType Type, const class FString& Message)>& Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "ListenForSteamMessages");

	Params::SteamUtilities_ListenForSteamMessages Parms{};

	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.MakeInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamSessionSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSteamSessionSetting USteamUtilities::MakeInteger(const int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeInteger");

	Params::SteamUtilities_MakeInteger Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeInventoryUpdateHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamInventoryUpdateHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamInventoryUpdateHandle USteamUtilities::MakeInventoryUpdateHandle(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeInventoryUpdateHandle");

	Params::SteamUtilities_MakeInventoryUpdateHandle Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakePublishedFileID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPublishedFileID USteamUtilities::MakePublishedFileID(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakePublishedFileID");

	Params::SteamUtilities_MakePublishedFileID Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeSearchInteger
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESteamComparisonOp                      ComparisonOperator                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamSessionSearchSetting       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSteamSessionSearchSetting USteamUtilities::MakeSearchInteger(const ESteamComparisonOp ComparisonOperator, const int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeSearchInteger");

	Params::SteamUtilities_MakeSearchInteger Parms{};

	Parms.ComparisonOperator = ComparisonOperator;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeSearchString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamSessionSearchSetting       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSteamSessionSearchSetting USteamUtilities::MakeSearchString(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeSearchString");

	Params::SteamUtilities_MakeSearchString Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeSteamGameID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamGameID                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamGameID USteamUtilities::MakeSteamGameID(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeSteamGameID");

	Params::SteamUtilities_MakeSteamGameID Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeSteamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamID                         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamID USteamUtilities::MakeSteamID(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeSteamID");

	Params::SteamUtilities_MakeSteamID Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamSessionSetting             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSteamSessionSetting USteamUtilities::MakeString(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeString");

	Params::SteamUtilities_MakeString Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeTicketHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamTicketHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamTicketHandle USteamUtilities::MakeTicketHandle(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeTicketHandle");

	Params::SteamUtilities_MakeTicketHandle Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MakeUGCHandle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamUGCHandle                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSteamUGCHandle USteamUtilities::MakeUGCHandle(const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MakeUGCHandle");

	Params::SteamUtilities_MakeUGCHandle Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.MuteRemoteTalker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LocalUserNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSystemWide                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::MuteRemoteTalker(class UObject* WorldContextObject, int32 LocalUserNum, class APlayerState* PlayerState, bool bIsSystemWide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "MuteRemoteTalker");

	Params::SteamUtilities_MuteRemoteTalker Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LocalUserNum = LocalUserNum;
	Parms.PlayerState = PlayerState;
	Parms.bIsSystemWide = bIsSystemWide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.NotEqual
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamID                         A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::NotEqual(const struct FSteamID& A, const struct FSteamID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "NotEqual");

	Params::SteamUtilities_NotEqual Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.PublishedFileID_Equals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPublishedFileID                 A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::PublishedFileID_Equals(const struct FPublishedFileID& A, const struct FPublishedFileID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "PublishedFileID_Equals");

	Params::SteamUtilities_PublishedFileID_Equals Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.PublishedFileID_Equals_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPublishedFileID                 A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProIdentical                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::PublishedFileID_Equals_Exec(const struct FPublishedFileID& A, const struct FPublishedFileID& B, ESteamCoreProIdentical* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "PublishedFileID_Equals_Exec");

	Params::SteamUtilities_PublishedFileID_Equals_Exec Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.PublishedFileID_NotEquals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPublishedFileID                 A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPublishedFileID                 B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::PublishedFileID_NotEquals(const struct FPublishedFileID& A, const struct FPublishedFileID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "PublishedFileID_NotEquals");

	Params::SteamUtilities_PublishedFileID_NotEquals Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.ReadFileToBytes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AbsoluteFilePath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> USteamUtilities::ReadFileToBytes(const class FString& AbsoluteFilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "ReadFileToBytes");

	Params::SteamUtilities_ReadFileToBytes Parms{};

	Parms.AbsoluteFilePath = std::move(AbsoluteFilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.ReadFriendList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EFriendListType                         FriendListType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::ReadFriendList(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EFriendListType FriendListType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "ReadFriendList");

	Params::SteamUtilities_ReadFriendList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);
	Parms.FriendListType = FriendListType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.SetLocalHost
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USteamUtilities::SetLocalHost(struct FSteamNetworkingIdentity& SteamNetworkingIdentity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetLocalHost");

	Params::SteamUtilities_SetLocalHost Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SetPSNId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::SetPSNId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, int64 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetPSNId");

	Params::SteamUtilities_SetPSNId Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SetStadiaId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int64                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::SetStadiaId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, int64 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetStadiaId");

	Params::SteamUtilities_SetStadiaId Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);
	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SetSteamId64
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamID                         SteamID                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void USteamUtilities::SetSteamId64(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, const struct FSteamID& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetSteamId64");

	Params::SteamUtilities_SetSteamId64 Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SetType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreNetworkingIdentityType        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::SetType(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, ESteamCoreNetworkingIdentityType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetType");

	Params::SteamUtilities_SetType Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SetXboxPairwiseId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamNetworkingIdentity         SteamNetworkingIdentity                                (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           String                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::SetXboxPairwiseId(struct FSteamNetworkingIdentity& SteamNetworkingIdentity, const class FString& String)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SetXboxPairwiseId");

	Params::SteamUtilities_SetXboxPairwiseId Parms{};

	Parms.SteamNetworkingIdentity = std::move(SteamNetworkingIdentity);
	Parms.String = std::move(String);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SteamNetworkingIdentity = std::move(Parms.SteamNetworkingIdentity);
}


// Function SteamCorePro.SteamUtilities.SteamItemInstanceID_Equals
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FSteamItemInstanceID             A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::SteamItemInstanceID_Equals(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SteamItemInstanceID_Equals");

	Params::SteamUtilities_SteamItemInstanceID_Equals Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.SteamItemInstanceID_Equals_Exec
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSteamItemInstanceID             A                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FSteamItemInstanceID             B                                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESteamCoreProIdentical                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUtilities::SteamItemInstanceID_Equals_Exec(const struct FSteamItemInstanceID& A, const struct FSteamItemInstanceID& B, ESteamCoreProIdentical* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "SteamItemInstanceID_Equals_Exec");

	Params::SteamUtilities_SteamItemInstanceID_Equals_Exec Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function SteamCorePro.SteamUtilities.StopListeningForSessionInviteAccepted
// (Final, Native, Static, Public, BlueprintCallable)

void USteamUtilities::StopListeningForSessionInviteAccepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "StopListeningForSessionInviteAccepted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamUtilities.TryJoinServer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           OutErrorMessage                                        (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSteamServerAddr                 ServerAddr                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class APlayerController*                SpecificPlayer                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUsingSockets                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::TryJoinServer(class FString* OutErrorMessage, const class UObject* WorldContextObject, const struct FSteamServerAddr& ServerAddr, class APlayerController* SpecificPlayer, bool bUsingSockets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "TryJoinServer");

	Params::SteamUtilities_TryJoinServer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ServerAddr = std::move(ServerAddr);
	Parms.SpecificPlayer = SpecificPlayer;
	Parms.bUsingSockets = bUsingSockets;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutErrorMessage != nullptr)
		*OutErrorMessage = std::move(Parms.OutErrorMessage);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.UnmuteRemoteTalker
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LocalUserNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSystemWide                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::UnmuteRemoteTalker(class UObject* WorldContextObject, int32 LocalUserNum, class APlayerState* PlayerState, bool bIsSystemWide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "UnmuteRemoteTalker");

	Params::SteamUtilities_UnmuteRemoteTalker Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LocalUserNum = LocalUserNum;
	Parms.PlayerState = PlayerState;
	Parms.bIsSystemWide = bIsSystemWide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamUtilities.WriteBytesToFile
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bOverwriteIfExists                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AbsoluteFilePath                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           DataBuffer                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamUtilities::WriteBytesToFile(bool bOverwriteIfExists, const class FString& AbsoluteFilePath, const TArray<uint8>& DataBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamUtilities", "WriteBytesToFile");

	Params::SteamUtilities_WriteBytesToFile Parms{};

	Parms.bOverwriteIfExists = bOverwriteIfExists;
	Parms.AbsoluteFilePath = std::move(AbsoluteFilePath);
	Parms.DataBuffer = std::move(DataBuffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.BOverlayNeedsPresent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::BOverlayNeedsPresent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "BOverlayNeedsPresent");

	Params::SteamProUtils_BOverlayNeedsPresent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.DismissFloatingGamepadTextInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::DismissFloatingGamepadTextInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "DismissFloatingGamepadTextInput");

	Params::SteamProUtils_DismissFloatingGamepadTextInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetAppID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetAppID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetAppID");

	Params::SteamProUtils_GetAppID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetAppID_Pure
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetAppID_Pure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetAppID_Pure");

	Params::SteamProUtils_GetAppID_Pure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetConnectedUniverse
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamUniverse                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamUniverse USteamProUtils::GetConnectedUniverse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetConnectedUniverse");

	Params::SteamProUtils_GetConnectedUniverse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetCurrentBatteryPower
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetCurrentBatteryPower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetCurrentBatteryPower");

	Params::SteamProUtils_GetCurrentBatteryPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetEnteredGamepadTextInput
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           Text                                                   (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::GetEnteredGamepadTextInput(class FString* Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetEnteredGamepadTextInput");

	Params::SteamProUtils_GetEnteredGamepadTextInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Text != nullptr)
		*Text = std::move(Parms.Text);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetEnteredGamepadTextLength
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetEnteredGamepadTextLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetEnteredGamepadTextLength");

	Params::SteamProUtils_GetEnteredGamepadTextLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetImageRGBA
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   IImage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<uint8>                           OutBuffer                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::GetImageRGBA(int32 IImage, TArray<uint8>* OutBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetImageRGBA");

	Params::SteamProUtils_GetImageRGBA Parms{};

	Parms.IImage = IImage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBuffer != nullptr)
		*OutBuffer = std::move(Parms.OutBuffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetImageSize
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   IImage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Width                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::GetImageSize(int32 IImage, int32* Width, int32* Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetImageSize");

	Params::SteamProUtils_GetImageSize Parms{};

	Parms.IImage = IImage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Width != nullptr)
		*Width = Parms.Width;

	if (Height != nullptr)
		*Height = Parms.Height;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetIPCCallCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetIPCCallCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetIPCCallCount");

	Params::SteamProUtils_GetIPCCallCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetIPCountry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProUtils::GetIPCountry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetIPCountry");

	Params::SteamProUtils_GetIPCountry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetIPv6ConnectivityState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamCoreIPv6ConnectivityProtocol      Protocol                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamCoreIPv6ConnectivityState         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESteamCoreIPv6ConnectivityState USteamProUtils::GetIPv6ConnectivityState(ESteamCoreIPv6ConnectivityProtocol Protocol)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetIPv6ConnectivityState");

	Params::SteamProUtils_GetIPv6ConnectivityState Parms{};

	Parms.Protocol = Protocol;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetSecondsSinceAppActive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetSecondsSinceAppActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetSecondsSinceAppActive");

	Params::SteamProUtils_GetSecondsSinceAppActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetSecondsSinceComputerActive
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetSecondsSinceComputerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetSecondsSinceComputerActive");

	Params::SteamProUtils_GetSecondsSinceComputerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetServerRealTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USteamProUtils::GetServerRealTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetServerRealTime");

	Params::SteamProUtils_GetServerRealTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetSteamUILanguage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USteamProUtils::GetSteamUILanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetSteamUILanguage");

	Params::SteamProUtils_GetSteamUILanguage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.GetSteamUtils
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProUtils*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProUtils* USteamProUtils::GetSteamUtils()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "GetSteamUtils");

	Params::SteamProUtils_GetSteamUtils Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.InitFilterText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::InitFilterText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "InitFilterText");

	Params::SteamProUtils_InitFilterText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.IsOverlayEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsOverlayEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "IsOverlayEnabled");

	Params::SteamProUtils_IsOverlayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.IsSteamChinaLauncher
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsSteamChinaLauncher()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "IsSteamChinaLauncher");

	Params::SteamProUtils_IsSteamChinaLauncher Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.IsSteamInBigPictureMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsSteamInBigPictureMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "IsSteamInBigPictureMode");

	Params::SteamProUtils_IsSteamInBigPictureMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.IsSteamRunningInVR
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsSteamRunningInVR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "IsSteamRunningInVR");

	Params::SteamProUtils_IsSteamRunningInVR Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.IsVRHeadsetStreamingEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsVRHeadsetStreamingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "IsVRHeadsetStreamingEnabled");

	Params::SteamProUtils_IsVRHeadsetStreamingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.SetGameLauncherMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bLauncherMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUtils::SetGameLauncherMode(bool bLauncherMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "SetGameLauncherMode");

	Params::SteamProUtils_SetGameLauncherMode Parms{};

	Parms.bLauncherMode = bLauncherMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUtils.SetOverlayNotificationInset
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   HorizontalInset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   VerticalInset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUtils::SetOverlayNotificationInset(int32 HorizontalInset, int32 VerticalInset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "SetOverlayNotificationInset");

	Params::SteamProUtils_SetOverlayNotificationInset Parms{};

	Parms.HorizontalInset = HorizontalInset;
	Parms.VerticalInset = VerticalInset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUtils.SetOverlayNotificationPosition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamNotificationPosition              NotificationPosition                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUtils::SetOverlayNotificationPosition(ESteamNotificationPosition NotificationPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "SetOverlayNotificationPosition");

	Params::SteamProUtils_SetOverlayNotificationPosition Parms{};

	Parms.NotificationPosition = NotificationPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUtils.SetVRHeadsetStreamingEnabled
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProUtils::SetVRHeadsetStreamingEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "SetVRHeadsetStreamingEnabled");

	Params::SteamProUtils_SetVRHeadsetStreamingEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUtils.ShowFloatingGamepadTextInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamFloatingGamepadTextInputMode      KeyboardMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TextFieldXPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TextFieldYPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TextFieldWidth                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TextFieldHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::ShowFloatingGamepadTextInput(ESteamFloatingGamepadTextInputMode KeyboardMode, int32 TextFieldXPosition, int32 TextFieldYPosition, int32 TextFieldWidth, int32 TextFieldHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "ShowFloatingGamepadTextInput");

	Params::SteamProUtils_ShowFloatingGamepadTextInput Parms{};

	Parms.KeyboardMode = KeyboardMode;
	Parms.TextFieldXPosition = TextFieldXPosition;
	Parms.TextFieldYPosition = TextFieldYPosition;
	Parms.TextFieldWidth = TextFieldWidth;
	Parms.TextFieldHeight = TextFieldHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.ShowGamepadTextInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESteamGamepadTextInputMode              InputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESteamGamepadTextInputLineMode          LineInputMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Description                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharMax                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ExistingText                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::ShowGamepadTextInput(ESteamGamepadTextInputMode InputMode, ESteamGamepadTextInputLineMode LineInputMode, const class FString& Description, int32 CharMax, const class FString& ExistingText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "ShowGamepadTextInput");

	Params::SteamProUtils_ShowGamepadTextInput Parms{};

	Parms.InputMode = InputMode;
	Parms.LineInputMode = LineInputMode;
	Parms.Description = std::move(Description);
	Parms.CharMax = CharMax;
	Parms.ExistingText = std::move(ExistingText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProUtils.StartVRDashboard
// (Final, Native, Static, Public, BlueprintCallable)

void USteamProUtils::StartVRDashboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProUtils", "StartVRDashboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProUtils.IsSteamRunningOnSteamDeck
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProUtils::IsSteamRunningOnSteamDeck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamProUtils", "IsSteamRunningOnSteamDeck");

	Params::SteamProUtils_IsSteamRunningOnSteamDeck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProVideo.GetOPFSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   VideoAppID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProVideo::GetOPFSettings(int32 VideoAppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProVideo", "GetOPFSettings");

	Params::SteamProVideo_GetOPFSettings Parms{};

	Parms.VideoAppID = VideoAppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProVideo.GetOPFStringForApp
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   VideoAppID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutBuffer                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProVideo::GetOPFStringForApp(int32 VideoAppID, class FString* OutBuffer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProVideo", "GetOPFStringForApp");

	Params::SteamProVideo_GetOPFStringForApp Parms{};

	Parms.VideoAppID = VideoAppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBuffer != nullptr)
		*OutBuffer = std::move(Parms.OutBuffer);

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProVideo.GetSteamVideo
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USteamProVideo*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USteamProVideo* USteamProVideo::GetSteamVideo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProVideo", "GetSteamVideo");

	Params::SteamProVideo_GetSteamVideo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SteamCorePro.SteamProVideo.GetVideoURL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   VideoAppID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamProVideo::GetVideoURL(int32 VideoAppID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProVideo", "GetVideoURL");

	Params::SteamProVideo_GetVideoURL Parms{};

	Parms.VideoAppID = VideoAppID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SteamCorePro.SteamProVideo.IsBroadcasting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   NumViewers                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USteamProVideo::IsBroadcasting(int32* NumViewers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SteamProVideo", "IsBroadcasting");

	Params::SteamProVideo_IsBroadcasting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NumViewers != nullptr)
		*NumViewers = Parms.NumViewers;

	return Parms.ReturnValue;
}

}

